<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>思维导图示例</title>
    <url>/2024/02/20/test/posts/undefined/</url>
    <content><![CDATA[<div class="markmap">
# Redis
  ## String类型
    ### 命令
      - SET
      - GET
      - INCR
    ### 应用
      - 计数器
      - 缓存
  ## Hash类型
    ### 命令
      - HSET
      - HGET
      - HDEL
    ### 应用
      - 用户信息
      - 商品属性
  ## List类型
    ### 命令
      - LPUSH
      - RPUSH
      - LRANGE
    ### 应用
      - 消息队列
      - 最新动态
</div>
]]></content>
  </entry>
  <entry>
    <title>C语言基础知识</title>
    <url>/2025/02/10/c/c-yu-yan-ji-chu-zhi-shi/posts/undefined/</url>
    <content><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li><strong>&amp;</strong> 获取变量地址</li>
<li>***** 说明变量为指针变量，存储的是另一个变量的地址；*<strong>p</strong> 若p本身已经是地址，那么能获取到这个地址对应的值</li>
<li>多级指针使用多个 ***** 表示</li>
<li>数组名不代表整个数组，只代表数组首元素的地址，对这个<strong>地址+1</strong>即可获取数组下一个元素的地址</li>
<li><strong>char</strong> <strong>string[]</strong> 数组定义字符串，<strong>char*</strong> <strong>str</strong> <strong>&#x3D; “x”</strong> 指针定义字符串</li>
<li>函数指针，函数名代表函数的地址。定义函数指针技巧如下: <ul>
<li>把要指向函数头拷贝过来</li>
<li>把函数名称使用小括号括起来</li>
<li>在函数名称前面加上一个 *</li>
<li>修改函数名称</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算func结果，并打印</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printFunc</span><span class="params">(<span class="type">char</span> *prefix, <span class="type">int</span> (*func)(<span class="type">int</span> a, <span class="type">int</span> b), <span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = func(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d %s %d] = %d\n&quot;</span>, a, prefix, b, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a 是一个变量，直接获取a那么得到的是具体的值也就是1</span></span><br><span class="line">    <span class="comment">// 怎么获取变量a的地址呢？&amp;a</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以使用一个指针变量指向a的地址，而不是a</span></span><br><span class="line">    <span class="type">int</span>* b = &amp;a;</span><br><span class="line">    <span class="comment">// 这里表示直接获取变量b的值，我们知道变量b存储的是地址，所以这里显示的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line">    <span class="comment">// 怎么通过这个地址获取到地址指向的值呢？使用 *</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %d\n&quot;</span>, *b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级指针，此变量存放的也是地址，但是不是具体变量的地址，而是一个指针的地址</span></span><br><span class="line">    <span class="type">int</span>** c = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, *c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %d\n&quot;</span>, **c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组名d不代表整个数组,只代表数组首元素的地址</span></span><br><span class="line">    <span class="type">int</span> d[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>, d);</span><br><span class="line">    <span class="type">int</span>* p = d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p0: %d\n&quot;</span>, *(p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: %d\n&quot;</span>, *(p + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2: %d\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义字符串</span></span><br><span class="line">    <span class="comment">// 1. 使用数组</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;我是...&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s: %s\n&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="comment">// 2. 字符串指针指向字符串</span></span><br><span class="line">    <span class="comment">// 用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符</span></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;xxxyyyy...&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str: %p\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str: %s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(str + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="comment">// 函数作为一段程序，在内存中也要占据部分存储空间，它也有一个起始地址</span></span><br><span class="line">    <span class="comment">// 因此可以利用一个指针指向一个函数。其中，函数名就代表着函数的地址</span></span><br><span class="line">    <span class="comment">// 具体格式就是 返回值 指针变量 参数</span></span><br><span class="line">    <span class="comment">// 指针函数定义技巧</span></span><br><span class="line">    <span class="comment">// 1、 把要指向函数头拷贝过来</span></span><br><span class="line">    <span class="comment">// 2、 把函数名称使用小括号括起来</span></span><br><span class="line">    <span class="comment">// 3、 在函数名称前面加上一个 *</span></span><br><span class="line">    <span class="comment">// 4、 修改函数名称</span></span><br><span class="line">    <span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    add = sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add: %p\n&quot;</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add result: %d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 计算并打印</span></span><br><span class="line">    printFunc(<span class="string">&quot;add&quot;</span>, add, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    printFunc(<span class="string">&quot;multi&quot;</span>, multi, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li>结构体中没有初始化的属性可能有垃圾值，这是因为内存没有初始化导致的，建议结构体中内嵌的结构体使用指针的形式，便于使用NULL定义</li>
<li>结构体之间赋值是值拷贝, 而不是地址传递</li>
<li>结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参</li>
<li>sizeof计算普通结构体变量，计算的是结构体整体占用的内存大小；计算指针则是指针本身占用的内存大小</li>
<li>共用体 union 内部所有属性共享一块内存，其中一个属性发生变化，其他属性也会改变</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStudent</span><span class="params">(<span class="type">const</span> Student* student)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s,age:%d,&quot;</span>, student-&gt;name, student-&gt;age);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span> =</span> student-&gt;birthday;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;birthday:%d-%d-%d\n&quot;</span>, birthday.year, birthday.month, birthday.day);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先定义再初始化</span></span><br><span class="line">    <span class="comment">// struct Student student 这里会为整个结构体分配内存，包含内部的三个属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="comment">// memset(&amp;student, 0, sizeof(&amp;student));</span></span><br><span class="line">    student.age = <span class="number">10</span>;</span><br><span class="line">    student.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    printStudent(&amp;student);</span><br><span class="line">    <span class="comment">// 打印没有初始化的birthday属性，会发现有值</span></span><br><span class="line">    <span class="comment">// 这些值是尚未初始化的内存，是内存中原本就有的数据，属于垃圾值</span></span><br><span class="line">    <span class="comment">// 这时候可以考虑使用指针，设置为NULL即可</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span> =</span> student.birthday;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;birthday:%d-%d-%d\n&quot;</span>, birthday.year, birthday.month, birthday.day);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化的时候定义</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;.name = <span class="string">&quot;name&quot;</span>, .age = <span class="number">29</span>&#125;;</span><br><span class="line">    printStudent(&amp;stu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先定义后一次初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu2</span>;</span></span><br><span class="line">    stu2 = (<span class="keyword">struct</span> Student)&#123;<span class="string">&quot;lnj&quot;</span>, <span class="number">35</span>&#125;;</span><br><span class="line">    printStudent(&amp;stu2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义包含结构体的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu3</span> =</span> &#123;.name = <span class="string">&quot;name3&quot;</span>, .age = <span class="number">20</span>, .birthday = &#123;.year = <span class="number">2024</span>, .month = <span class="number">10</span>, .day = <span class="number">22</span>&#125;&#125;;</span><br><span class="line">    printStudent(&amp;stu3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体之间赋值是值拷贝, 而不是地址传递</span></span><br><span class="line">    <span class="comment">// 同理 结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参</span></span><br><span class="line">    <span class="comment">// 这个跟java不一样，java中只要不是基本对象，其他都是拷贝地址，而不是值拷贝</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">copyStudent</span> =</span> student;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age1:%d, age2:%d\n&quot;</span>, student.age, copyStudent.age);</span><br><span class="line">    <span class="comment">// 发现copyStudent对应的数据变化了，但是student数据没有改变</span></span><br><span class="line">    copyStudent.age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age1:%d, age2:%d\n&quot;</span>, student.age, copyStudent.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof</span></span><br><span class="line">    <span class="comment">// 这里计算的是普通变量，也就是整个结构体的大小=24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(student));</span><br><span class="line">    <span class="comment">// 这里计算的是指针变量，也就是计算这个指针变量本身的大小，在64位机器上是8个byte</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;student));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用typeof定义的名称访问</span></span><br><span class="line">    Student studentx = &#123;.name = <span class="string">&quot;x&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s&quot;</span>, studentx.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共用体，内部所有的属性占用同一块内存，修改某个属性会影响到其他属性</span></span><br><span class="line">    <span class="comment">// 通信中的数据包会用到共用体，因为不知道对方会发送什么样的数据包过来，用共用体的话就简单了，定义几种格式的包，收到包之后就可以根据包的格式取出数据</span></span><br><span class="line">    <span class="comment">// 节约内存。如果有2个很长的数据结构，但不会同时使用</span></span><br><span class="line">    <span class="comment">// 某些应用需要大量的临时变量，这些变量类型不同，而且会随时更换。而你的堆栈空间有限，不能同时分配那么多临时变量。这时可以使用共用体让这些变量共享同一个内存空间，这些临时变量不用长期保存，用完即丢，和寄存器差不多，不用维护</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="comment">// 发现这个共用体占用的内存是4，也就是其中某个属性占用内存的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof union: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">    t.age = <span class="number">33</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 33</span></span><br><span class="line">    t.a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.ch = %c\n&quot;</span>, t.a); <span class="comment">// a</span></span><br><span class="line">    <span class="comment">// 修改属性a发现age属性也变化了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 97</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul>
<li>源程序中所有的宏在编译预处理的时候都会进行文本替换</li>
<li>定义一个宏时可以引用已经定义的宏名</li>
<li>可用宏定义表示数据类型,使书写方便  <code>#define String char*</code></li>
<li>带参数的宏定义<ul>
<li>C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参</li>
<li>格式: #define 宏名(形参表) 字符串</li>
<li><ol>
<li>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>
</ol>
</li>
<li><ol start="2">
<li>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数</li>
</ol>
</li>
<li><ol start="3">
<li>计算结果最好也用括号括起来，避免出现一些优先的问题 #define Pow(a) ( (a) * (a) )</li>
</ol>
</li>
</ul>
</li>
<li>条件编译</li>
</ul>
<blockquote>
<p>希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译</p>
</blockquote>
<ul>
<li>宏定义与函数的区别<ul>
<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>
<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>
</ul>
</li>
<li>typedef和#define的区别<ul>
<li>宏定义只是简单的字符串替换,￼是在预处理完成的</li>
<li>typedef是在编译时处理的,它不是作简单的代换,而是对类型说明符￼重新命名。被命名的标识符具有类型定义说明的功能</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替</span></span><br><span class="line"><span class="comment">// 宏名一般用大写字母，以便与变量名区别开来</span></span><br><span class="line"><span class="comment">// 定义一个宏时可以引用已经定义的宏名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用宏定义表示数据类型,使书写方便</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> String char*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的宏定义</span></span><br><span class="line"><span class="comment">// C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参</span></span><br><span class="line"><span class="comment">// 格式: #define 宏名(形参表) 字符串</span></span><br><span class="line"><span class="comment">// 1. 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</span></span><br><span class="line"><span class="comment">// 2. 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数</span></span><br><span class="line"><span class="comment">// 3. 计算结果最好也用括号括起来，避免出现一些优先的问题 #define Pow(a) ( (a) * (a) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> average(a, b) ((a + b) / 2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件编译，希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译</span></span><br><span class="line"><span class="comment">// #if 常量表达式</span></span><br><span class="line"><span class="comment">//      ..code1...</span></span><br><span class="line"><span class="comment">// #else</span></span><br><span class="line"><span class="comment">//      ..code2...</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"><span class="comment">// !! 条件编译后面的条件表达式中不能识别变量,它里面只能识别常量和宏定义，同样的，也只能定义常量和宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCORE 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SCORE &gt; 90</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> printScore() printf(<span class="string">&quot;优秀&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SCORE &gt; 60</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> printScore() printf(<span class="string">&quot;良好&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> printScore() printf(<span class="string">&quot;不及格&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据圆的半径计radius算周长</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">girth</span><span class="params">(<span class="type">float</span> radius)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> g = girth(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;周长为：%f\n&quot;</span>, g);</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str: %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;avg: %d\n&quot;</span>, average(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    printScore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><ul>
<li>malloc 和 free 成对使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 存储在栈中, 内存地址从大到小</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a); <span class="comment">// &amp;a = 0x16b90eb68</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;b = %p\n&quot;</span>, &amp;b); <span class="comment">// &amp;b = 0x16b90eb64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在栈中, 内存地址从小到大</span></span><br><span class="line">    <span class="type">int</span>* p1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1 = %p\n&quot;</span>, p1); <span class="comment">//  p1 = 00762F48</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %p\n&quot;</span>, p2); <span class="comment">// p2 = 00762F58</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc 所在文件:stdlib.h</span></span><br><span class="line">    <span class="comment">// 申请堆内存空间并返回,所申请的空间并未初始化。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * malloc</span></span><br><span class="line"><span class="comment">     * 第一个参数: 需要申请多少个字节空间</span></span><br><span class="line"><span class="comment">     * 返回值类型: void *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %i\n&quot;</span>, *p); <span class="comment">// *p可能是垃圾数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一个参数: 需要初始化的内存地址</span></span><br><span class="line"><span class="comment">     * 第二个初始: 需要初始化的值</span></span><br><span class="line"><span class="comment">     * 第三个参数: 需要初始化对少个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 对申请的内存空间进行初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %i\n&quot;</span>, *p); <span class="comment">// 初始化为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, p);</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %i\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// realloc 扩容/缩容</span></span><br><span class="line">    <span class="comment">// 返回的指针，可能与 ptr 的值相同，也有可能不同。</span></span><br><span class="line">    <span class="comment">// 若相同，则说明在原空间后面申请，否则，则可能后续空间不足，重新申请的新的连续空间，原数据拷贝到新空间， 原有空间自动释放</span></span><br><span class="line">    p = <span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %i\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free stdlib.h</span></span><br><span class="line">    <span class="comment">// 通过malloc申请的存储空间一定要释放, 所以malloc和free函数总是成对出现</span></span><br><span class="line">    <span class="comment">// 释放申请的堆内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_SIZE sizeof(Node)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空链表，包含一个头结点</span></span><br><span class="line">Node* <span class="title function_">createNodeList</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertTail</span><span class="params">(Node* head, <span class="type">int</span> data)</span>;</span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertHead</span><span class="params">(Node* head, <span class="type">int</span> data)</span>;</span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNodeList</span><span class="params">(Node* node)</span>;</span><br><span class="line"><span class="comment">// 释放一个链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeNode</span><span class="params">(Node* head)</span>;</span><br><span class="line"><span class="comment">// 计算链表长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listLength</span><span class="params">(<span class="type">const</span> Node* head)</span>;</span><br><span class="line"><span class="comment">// 链表查找</span></span><br><span class="line">Node* <span class="title function_">searchList</span><span class="params">(Node* head, <span class="type">int</span> key)</span>;</span><br><span class="line"><span class="comment">// 链表删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNodeList</span><span class="params">(Node* head, Node* find)</span>;</span><br><span class="line"><span class="comment">// 反转链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseList</span><span class="params">(Node* head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* head = createNodeList();</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    insertHead(head, <span class="number">1</span>);</span><br><span class="line">    insertHead(head, <span class="number">2</span>);</span><br><span class="line">    insertTail(head, <span class="number">3</span>);</span><br><span class="line">    insertTail(head, <span class="number">4</span>);</span><br><span class="line">    printNodeList(head);</span><br><span class="line">    reverseList(head);</span><br><span class="line">    printNodeList(head);</span><br><span class="line">    <span class="type">int</span> length = listLength(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表长度: %i\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (searchList(head, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为%i的节点\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (searchList(head, <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为%i的节点\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!searchList(head, <span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到值为%i的节点\n&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deleteNodeList(head, searchList(head, <span class="number">4</span>));</span><br><span class="line">    deleteNodeList(head, searchList(head, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    printNodeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">createNodeList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* head = <span class="built_in">malloc</span>(NODE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertTail</span><span class="params">(Node* head, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到尾结点</span></span><br><span class="line">    Node* pre = head;</span><br><span class="line">    <span class="keyword">while</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node = <span class="built_in">malloc</span>(NODE_SIZE);</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertHead</span><span class="params">(Node* head, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = <span class="built_in">malloc</span>(NODE_SIZE);</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNodeList</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* head = node-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> currentData = head-&gt;data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;currentData = %i\n&quot;</span>, currentData);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeNode</span><span class="params">(Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const Node* head 表示指针指向的内容不能修改</span></span><br><span class="line"><span class="comment">// Node* const head 表示这个指针不能修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listLength</span><span class="params">(<span class="type">const</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">searchList</span><span class="params">(Node* head, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == head-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNodeList</span><span class="params">(Node* head, Node* find)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != find)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = find-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseList</span><span class="params">(Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pre, *cur;</span><br><span class="line">    pre = head-&gt;next;</span><br><span class="line">    <span class="comment">// 把head置为一个空链表</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (pre)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 反转链表，相当于头插法</span></span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas</title>
    <url>/2025/02/09/arthas/arthas/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://github.com/alibaba/arthas/issues/71">Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&#x2F;arthas</a></p>
</li>
<li><p><a href="https://github.com/alibaba/arthas/issues/1424">arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&#x2F;arthas</a></p>
</li>
<li><p><a href="https://github.com/alibaba/arthas/issues/537">Arthas实践–jad&#x2F;mc&#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&#x2F;arthas</a></p>
</li>
</ul>
<h3 id="1-获取当前HttpServletRequest"><a href="#1-获取当前HttpServletRequest" class="headerlink" title="1. 获取当前HttpServletRequest"></a>1. 获取当前HttpServletRequest</h3><ul>
<li><p>执行某个request方法</p>
<p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx</code></p>
</li>
<li><p>获取全部的请求头</p>
<p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()</code></p>
</li>
</ul>
<h3 id="2-获取spring-context-并执行某些操作"><a href="#2-获取spring-context-并执行某些操作" class="headerlink" title="2. 获取spring context 并执行某些操作"></a>2. 获取spring context 并执行某些操作</h3><blockquote>
<p><strong>前置</strong> 使用tt记录请求，获取到上下文</p>
</blockquote>
<ul>
<li><p>tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</p>
</li>
<li><p>tt -i 1000 -w ‘target.getApplicationContext().getBean(“jdbcTemplate”)’</p>
</li>
<li><p>tt -i 1000 -w ‘target.getApplicationContext().getBean(“jdbcTemplate”).dataSource.ConnectionPool’</p>
</li>
<li><p>tt -i 1000 -w ‘target.getApplicationContext().getBean(“jdbcTemplate”).getTargetSource().target’</p>
</li>
<li><p>tt -i 1000 -w ‘target.getApplicationContext().getBean(“jdbcTemplate”).getTargetSource().target.cacheMap’</p>
</li>
<li><p>tt -i 1000  -w ‘target.getApplicationContext().getEnvironment().getProperty(“spring.datasource.riskctrl.url”)’</p>
</li>
</ul>
<h3 id="3-使用ognl"><a href="#3-使用ognl" class="headerlink" title="3. 使用ognl"></a>3. 使用<a href="https://commons.apache.org/dormant/commons-ognl/language-guide.html">ognl</a></h3><ul>
<li><p>对前置表达式值进行二次计算  #this 表示前置表达式的值 <strong><code>.()</code></strong> 表示自表达式，产生一个单一值</p>
<p>  <strong><code>listeners.size().(#this &gt; 100? 2\*#this : 20+#this)</code></strong></p>
</li>
<li><p>对前置表达式进行二次计算，产生一个数组</p>
<p>  <strong><code>params[0].&#123;#this == &quot;lei&quot; ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p>
</li>
<li><p>对前置表达式(数组类型)进行二次计算，产生一个新的数组</p>
<p>  <strong><code>params.&#123;#this instanceof String ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p>
</li>
<li><p>返回数组中第一个匹配的对象</p>
<p>  <strong><code>params.&#123;^#this instanceof Integer&#125;</code></strong></p>
</li>
<li><p>调用static方法 使用  <strong>@class@method(<strong><strong>args</strong></strong>)</strong></p>
<p>  <strong><code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes()</code></strong></p>
</li>
<li><p>获取静态字段 <strong>@class@field</strong></p>
</li>
</ul>
<h3 id="4-一些常用命令"><a href="#4-一些常用命令" class="headerlink" title="4. 一些常用命令"></a>4. 一些常用命令</h3><ul>
<li><p>获取classloader hash，如果是springBoot项目取 org.springframework.boot.loader.LaunchedURLClassLoader</p>
<p>  <strong><code>classloader -t</code></strong></p>
</li>
<li><p>容器安装 vim</p>
<p>  <strong><code>apt-get update &amp;&amp; apt-get install -y vim</code></strong></p>
</li>
<li><p>Ognl 获取spring context</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 49c2faae 表示classloader hash</span><br><span class="line"># cn.hutool.extra.spring.SpringUtil 表示能获取到spring容器的方法</span><br><span class="line">ognl -c 49c2faae &#x27;#beanName=&quot;eventDataAuthManage&quot;, #bean=@cn.hutool.extra.spring.SpringUtil@getBean(#beanName), @org.springframework.aop.support.AopUtils@getTargetClass(#bean).getName()&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ognl lambda 表达式</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 使用 =:[] 定义lambda即函数</span><br><span class="line">-- 使用 #getBean() 调用</span><br><span class="line">ognl -c 49c2faae &#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean =:[@cn.hutool.extra.spring.SpringUtil@getBean(#this)],</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean(<span class="string">&quot;syncDataAuthController&quot;</span>).dataCodeList<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找方法</p>
<p>  <strong><code>sm com.xx.class</code></strong></p>
</li>
<li><p>修改静态变量的值</p>
<p>  <strong><code>getstatic com.xyz.HelloWorld s &quot;#s=&#39;abc&#39;&quot;</code></strong></p>
</li>
<li><p>修改变量的值</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 1. 使用 tt 记录方法调用</span><br><span class="line">tt -t com.example.UserService getUserById</span><br><span class="line">-- 2. 查看记录</span><br><span class="line">tt -l</span><br><span class="line">-- 3. 修改捕获的对象 target 代表当前被调用方法的对象实例（即 &quot;this&quot; 对象）</span><br><span class="line">tt -i 1000 -w &#x27;target.name=&quot;newName&quot;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤参数类型为class的方法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 过滤要点就是通过全类名@class拿到class对象，再getName()获取名称</span><br><span class="line">watch com.wangji92.arthas.plugin.demo.controller.StaticTest invokeClass &#x27;&#123;returnObj,throwExp&#125;&#x27;  -n 5  -x 3  </span><br><span class="line">&#x27;params[0].getName().equals(@com.wangji92.arthas.plug.demo.controller.User@class.getName())&#x27; -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找response404的堆栈</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack -E javax.servlet.http.HttpServletResponse sendError|setStatus params[0]==404</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-特殊命令"><a href="#5-特殊命令" class="headerlink" title="5. 特殊命令"></a>5. 特殊命令</h3><ul>
<li><p>Trace 命令多个类、多个方法、指定线程、指定耗时时间</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># trace -E 表示正则</span><br><span class="line">trace -E </span><br><span class="line"># 表示类是 NioEventLoop 或者 SingleThreadEventExecutor</span><br><span class="line">&#x27;io\.netty\.channel\.nio\.NioEventLoop|io\.netty\.util\.concurrent\.SingleThreadEventExecutor&#x27;  </span><br><span class="line"># 表示方法是 select processSelectedKeys runAllTasks</span><br><span class="line">&#x27;select|processSelectedKeys|runAllTasks&#x27; </span><br><span class="line"># @Thread arthas提供表示当前线程 #cost arthas提供，表示耗时</span><br><span class="line">&#x27;@Thread@currentThread().getName().contains(&quot;IO-HTTP-WORKER-IOPool&quot;)&amp;&amp;#cost&gt;500&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取代理对象的原始对象</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -w &#x27;#isProxy=:[ @org.springframework.aop.support.AopUtils@isAopProxy(#this)?1: #this instanceof java.lang.reflect.Proxy ? 0 :-1],#isJdkDynamicProxy =:[@org.springframework.aop.support.AopUtils@isJdkDynamicProxy(#this) ? true :false ],#cglibTarget =:[#hField =#this.getClass().getDeclaredField(&quot;CGLIB$CALLBACK_0&quot;),#hField.setAccessible(true),#dynamicAdvisedInterceptor=#hField.get(#this),#fieldAdvised=#dynamicAdvisedInterceptor.getClass().getDeclaredField(&quot;advised&quot;),#fieldAdvised.setAccessible(true),1==1? #fieldAdvised.get(#dynamicAdvisedInterceptor).getTargetSource().getTarget():null],#jdkTarget=:[ #hField=#this.getClass().getSuperclass().getDeclaredField(&quot;h&quot;),#hField.setAccessible(true),#aopProxy=#hField.get(#this),#advisedField=#aopProxy.getClass().getDeclaredField(&quot;advised&quot;),#advisedField.setAccessible(true),1==1?#advisedField.get(#aopProxy).getTargetSource().getTarget():null],#nonProxyResultFunc = :[#proxyResul=#isProxy(#this),#proxyResul== -1 ?#this :#proxyResul== 0? @java.lang.reflect.Proxy@getInvocationHandler(#this):#isJdkDynamicProxy(#this)? #isJdkDynamicProxy(#this) : #cglibTarget(#this)],#nonProxyTarget=#nonProxyResultFunc(target),#nonProxyTarget&#x27;  -x 1 -i 1002</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-Vmtool-使用"><a href="#6-Vmtool-使用" class="headerlink" title="6. Vmtool 使用"></a>6. Vmtool 使用</h3><blockquote>
<p><code>vmtool</code> 利用 Java 的 Instrumentation API 和 JVM TI（JVM Tool Interface）与 JVM 进行交互，可以绕过spring context 直接获取对象</p>
</blockquote>
<ul>
<li><p>常用子命令</p>
<ul>
<li><code>--action getInstances</code>：获取类的实例</li>
<li><code>--action forceGc</code>：强制执行垃圾回收</li>
<li><code>--action getClassLoader</code>：获取类加载器信息</li>
</ul>
</li>
<li><p>com.xxx.cache.CacheAspect 中的 boolean 变量 cacheEnabled 修改为false</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool: Arthas 的一个命令，用于对 JVM 进行底层操作。</span><br><span class="line">-x 3: 设置执行次数限制为 3 次。</span><br><span class="line">--action getInstances: 指定操作为获取类的实例。</span><br><span class="line">--className com.xxx.cache.CacheAspect: 指定要操作的类名。</span><br><span class="line">--express: 后面跟着的是要执行的 OGNL 表达式</span><br><span class="line">ongl表达式:</span><br><span class="line">反射获取字段 #field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;)</span><br><span class="line">设置为true #field.setAccessible(true)</span><br><span class="line">修改字段 #field.set(instances[0],false)</span><br><span class="line"></span><br><span class="line">vmtool -x 3 --action getInstances --className com.xxx.cache.CacheAspect --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;),#field.setAccessible(true),#field.set(instances[0],false)&#x27; -c 3bd94634</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改final变量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 4 --action getInstances --className com.wangji92.arthas.plugin.demo.controller.CommonController  --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;FINAL_VALUE&quot;),#modifiers=#field.getClass().getDeclaredField(&quot;modifiers&quot;),#modifiers.setAccessible(true),#modifiers.setInt(#field,#field.getModifiers() &amp; ~@java.lang.reflect.Modifier@FINAL),#field.setAccessible(true),#field.set(instances[0],&quot; 3333&quot;)&#x27; -c  18b4aac2</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行某个方法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 1 --action getInstances </span><br><span class="line">--className com.xx.SyncDataAuthController </span><br><span class="line">--express &#x27;instances[0].getDataCodePage(@com.xx.UtilJson@convertValue(&quot;&#123;\&quot;pageIndex\&quot;:0,\&quot;pageSize\&quot;:0&#125;&quot;, @com.xx.BaseQuery@class))&#x27;</span><br><span class="line">-c 49c2faae</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取spring context</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool --action getInstances --className org.springframework.context.ConfigurableApplicationContext --express &#x27;instances[0].getEnvironment().getProperty(&quot;server.port&quot;)&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取 spring Environment 配置</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 3 --action getInstances --className org.springframework.core.env.Environment  --express &#x27;instances[0].getProperty(&quot;server.port&quot;)&#x27; -c 7b5a12ae</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile</title>
    <url>/2025/02/10/docker/dockerfile/posts/undefined/</url>
    <content><![CDATA[<h3 id="Dockerignore"><a href="#Dockerignore" class="headerlink" title="Dockerignore"></a>Dockerignore</h3><blockquote>
<p>dockerfile中忽略特定的文件和目录</p>
</blockquote>
<ul>
<li>示例表示忽略全部，除了一些必要的</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">!pom.xml</span><br><span class="line">!sh</span><br><span class="line">!src</span><br></pre></td></tr></table></figure>

<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><blockquote>
<p>构建java基础项目docker镜像</p>
</blockquote>
<ul>
<li>提供 maven 编译构建 + 运行</li>
<li><code>BASE_JAVA_IMAGE</code> 基础的java镜像，建议选择带有jre的基础java镜像</li>
<li><code>MAVEN_IMAGE</code> maven编译的基础镜像，建议与java版本对应</li>
<li>内置 <code>arthas</code></li>
<li>内置运行脚本 <code>run.sh</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"># Global ARGs (build-time variables)</span></span><br><span class="line"><span class="comment"># ARG 定义的变量在 FROM 指令中是可以直接使用的</span></span><br><span class="line"><span class="comment"># ARG 定义的变量在不同的构建阶段需要重新定义</span></span><br><span class="line"><span class="comment"># ARG 是构建时的变量，不能在容器中访问，而ENV是环境变量</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"># Base images</span></span><br><span class="line"><span class="keyword">ARG</span> BASE_JAVA_IMAGE=eclipse-temurin:<span class="number">8</span>-jdk-jammy</span><br><span class="line"><span class="keyword">ARG</span> MAVEN_IMAGE=maven:<span class="number">3</span>-eclipse-temurin-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application info</span></span><br><span class="line"><span class="keyword">ARG</span> APP_NAME=aws-starter</span><br><span class="line"><span class="keyword">ARG</span> APP_VERSION=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">ARG</span> <span class="keyword">MAINTAINER</span>=<span class="number">17674030991</span>@<span class="number">163</span>.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arthas</span></span><br><span class="line"><span class="keyword">ARG</span> ARTHAS_VERSION=<span class="number">3.7</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory structure</span></span><br><span class="line"><span class="keyword">ARG</span> WORK_HOME=/opt/deployments</span><br><span class="line"><span class="keyword">ARG</span> APP_USER=app</span><br><span class="line"><span class="keyword">ARG</span> APP_GROUP=app</span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"># Stage 0 : Download Arthas</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest AS arthas-downloader</span><br><span class="line"><span class="keyword">ARG</span> ARTHAS_VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache wget unzip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /opt/arthas &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget -q https://maven.aliyun.com/repository/public/com/taobao/arthas/arthas-packaging/<span class="variable">$&#123;ARTHAS_VERSION&#125;</span>/arthas-packaging-<span class="variable">$&#123;ARTHAS_VERSION&#125;</span>-bin.zip -O arthas-bin.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    unzip -q arthas-bin.zip -d /opt/arthas &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -f arthas-bin.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"># Stage 1 : BUILD JAR</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="keyword">FROM</span> $&#123;MAVEN_IMAGE&#125; AS maven-builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maven configuration</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_OPTS=<span class="string">&quot;-Dmaven.test.skip=true -Dmaven.compile.fork=true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 settings.xml</span></span><br><span class="line"><span class="comment"># 使用 --build-arg 传入本地 settings.xml 的路径</span></span><br><span class="line"><span class="comment"># ARG MAVEN_SETTINGS</span></span><br><span class="line"><span class="comment"># COPY $&#123;MAVEN_SETTINGS&#125; /root/.m2/settings.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先复制 pom 文件以利用缓存</span></span><br><span class="line"><span class="comment"># pom 文件不变，依赖的下载就会使用缓存，源代码改变只会触发编译，不会重新下载依赖</span></span><br><span class="line"><span class="comment"># -B: 批处理模式</span></span><br><span class="line"><span class="comment"># dependency:resolve: 预下载声明在 pom.xml 中的依赖</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pom.xml ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn dependency:resolve -B</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制源代码和其他文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src ./src/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> sh ./sh/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建应用</span></span><br><span class="line"><span class="comment"># -am 同时构建所列模块的依赖模块</span></span><br><span class="line"><span class="comment"># -B 以&quot;批处理模式&quot;运行 Maven，减少输出信息</span></span><br><span class="line"><span class="comment"># -DskipUTs 跳过单元测试</span></span><br><span class="line"><span class="comment"># -DskipITs 跳过集成测试</span></span><br><span class="line"><span class="comment"># --no-transfer-progress 不显示文件传输进度，减少输出</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -am -B -DskipUTs -DskipITs --no-transfer-progress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"># Stage 2: BUILD IMAGE</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="keyword">FROM</span> $&#123;BASE_JAVA_IMAGE&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use ARGs in LABEL</span></span><br><span class="line"><span class="keyword">ARG</span> APP_NAME</span><br><span class="line"><span class="keyword">ARG</span> APP_VERSION</span><br><span class="line"><span class="keyword">ARG</span> <span class="keyword">MAINTAINER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;<span class="variable">$&#123;MAINTAINER&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      version=<span class="string">&quot;<span class="variable">$&#123;APP_VERSION&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      description=<span class="string">&quot;<span class="variable">$&#123;APP_NAME&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set environment variables</span></span><br><span class="line"><span class="keyword">ARG</span> WORK_HOME</span><br><span class="line"><span class="keyword">ARG</span> APP_USER</span><br><span class="line"><span class="keyword">ARG</span> APP_GROUP</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> WORK_HOME=$&#123;WORK_HOME&#125;</span><br><span class="line"><span class="keyword">ENV</span> ARTHAS_OUTPUT_DIR=$&#123;WORK_HOME&#125;/arthas-output</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu/Debian 方式创建用户和目录</span></span><br><span class="line"><span class="comment"># install -d -m 避免 chown 命令导致镜像膨胀</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd --system <span class="variable">$&#123;APP_GROUP&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    useradd --system --gid <span class="variable">$&#123;APP_GROUP&#125;</span> --shell /bin/false <span class="variable">$&#123;APP_USER&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    install -d -m 755 -o <span class="variable">$&#123;APP_USER&#125;</span> -g <span class="variable">$&#123;APP_GROUP&#125;</span> <span class="variable">$&#123;WORK_HOME&#125;</span>/logs <span class="variable">$&#123;WORK_HOME&#125;</span>/arthas-output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;WORK_HOME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy application files</span></span><br><span class="line"><span class="comment"># 这里使用 --chown=$&#123;APP_USER&#125;:$&#123;APP_GROUP&#125; 是为了避免单独使用chown -R $&#123;APP_USER&#125;:$&#123;APP_GROUP&#125;命令，导致镜像大小膨胀1倍</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=maven-builder --<span class="built_in">chown</span>=<span class="variable">$&#123;APP_USER&#125;</span>:<span class="variable">$&#123;APP_GROUP&#125;</span> target/*-exec.jar ./app.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=maven-builder --<span class="built_in">chown</span>=<span class="variable">$&#123;APP_USER&#125;</span>:<span class="variable">$&#123;APP_GROUP&#125;</span> sh ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=arthas-downloader --<span class="built_in">chown</span>=<span class="variable">$&#123;APP_USER&#125;</span>:<span class="variable">$&#123;APP_GROUP&#125;</span> /opt/arthas ./arthas/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x ./run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Switch to app user</span></span><br><span class="line"><span class="keyword">USER</span> $&#123;APP_USER&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;./run.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dockerfile</tag>
        <tag>基础镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程异常处理</title>
    <url>/2025/02/09/java/duo-xian-cheng-yi-chang-chu-li/posts/undefined/</url>
    <content><![CDATA[<blockquote>
<p> 多线程场景下，如果没有显示的捕获异常并处理，那么异常会输出到 System.err 中，导致异常信息丢失</p>
</blockquote>
<h3 id="异常被吞噬的例子"><a href="#异常被吞噬的例子" class="headerlink" title="异常被吞噬的例子"></a>异常被吞噬的例子</h3><ul>
<li>新起线程中抛出异常</li>
</ul>
<blockquote>
<p>由于是新启动的线程，此异常并不会抛到父线程或者调用方上，导致异常被没了- - </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个异常!&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程池中抛出的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>)</span><br><span class="line">        .execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;线程池中的异常!&quot;</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>针对上面出现的异常吞噬的例子，有以下解决方案</p>
</blockquote>
<ul>
<li><p>Try catch 显示处理异常</p>
</li>
<li><p>指定<code> Thread.UncaughtExceptionHandler</code></p>
<ul>
<li><p>线程处理</p>
</li>
<li><p>thread.setUncaughtExceptionHandler</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">uncaughtExceptionHandler</span> <span class="operator">=</span> (t, e) -&gt; log.error(<span class="string">&quot;[catch error]thread -&gt; &#123;&#125;, e -&gt; &#123;&#125;&quot;</span>, t, e);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]这是一个异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

</li>
<li><p>线程池处理</p>
</li>
<li><p>new ThreadFactoryBuilder().setUncaughtExceptionHandler  线程工厂中设置</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">uncaughtExceptionHandler</span> <span class="operator">=</span> (t, e) -&gt; log.error(<span class="string">&quot;[catch error]thread -&gt; &#123;&#125;, e -&gt; &#123;&#125;&quot;</span>, t, e);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]这是一个异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS</span><br><span class="line">        , <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>)</span><br><span class="line">        , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setUncaughtExceptionHandler(uncaughtExceptionHandler).build());</span><br><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]线程池中的异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>Hold on…..有人的地方就不存在信任这一说- -</p>
<h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><blockquote>
<p>上面的解决方案是没问题的，但是但是但是，某些开发者可能没有这个意识或者忘记了，导致异常还是被吞噬了</p>
</blockquote>
<p>既然未捕获的异常最终会输出到 <code>System.err</code> 那么重新设置系统的 err 处理，把信息输出到日志系统中。下面这个是兜底方案，会存在部分的不合理，但是为了不丢异常信息还是可以容忍的，日常开发中发现此类异常，需要定位到对应的业务代码，用上面提供的解决方案完善代码；毕竟这只是一个兜底的方案，而不是常规方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stderr</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logErr</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;[UnCatchError]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">STDERR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.err) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">            logErr.error(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            logErr.error(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.setErr(STDERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign 更换 Client</title>
    <url>/2025/02/09/feign/feign-geng-huan-client/posts/undefined/</url>
    <content><![CDATA[<h2 id="基于-loadBalancer-更换-FeignClient-为-vertx-web-实现"><a href="#基于-loadBalancer-更换-FeignClient-为-vertx-web-实现" class="headerlink" title="基于 loadBalancer 更换 FeignClient 为 vertx-web 实现"></a>基于 loadBalancer 更换 FeignClient 为 vertx-web 实现</h2><ul>
<li>feignClient 实现类依旧是 LoadBalancerFeignClient</li>
<li>LoadBalancerFeignClient 中 delegate 更换为自定义实现的 vertx-web-client</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxFeignClient</span> <span class="keyword">implements</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VertxFeignClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line">        <span class="type">WebClientOptions</span> <span class="variable">webClientOptions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebClientOptions</span>()</span><br><span class="line">                .setMaxPoolSize(<span class="number">100</span>)</span><br><span class="line">                .setMaxWaitQueueSize(<span class="number">10000</span>);</span><br><span class="line">        <span class="built_in">this</span>.webClient = WebClient.create(vertx, webClientOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.url();</span><br><span class="line">        <span class="type">var</span> <span class="variable">bodys</span> <span class="operator">=</span> request.requestBody().asBytes();</span><br><span class="line">        Map&lt;String, Collection&lt;String&gt;&gt; headers = request.headers();</span><br><span class="line">        io.vertx.core.http.<span class="type">HttpMethod</span> <span class="variable">vertxMethod</span> <span class="operator">=</span> io.vertx.core.http.HttpMethod.valueOf(request.httpMethod().name());</span><br><span class="line"></span><br><span class="line">        <span class="type">HeadersMultiMap</span> <span class="variable">entries</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeadersMultiMap</span>();</span><br><span class="line">        headers.forEach(entries::add);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Response&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        webClient.requestAbs(vertxMethod, url)</span><br><span class="line">                .putHeaders(entries)</span><br><span class="line">                .sendBuffer(bodys == <span class="literal">null</span> ? Buffer.buffer() : Buffer.buffer(bodys))</span><br><span class="line">                .timeout(options.readTimeoutMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">                .onSuccess(t -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;url[&#123;&#125;] 响应 -&gt; &#123;&#125;&quot;</span>, url, t.bodyAsString());</span><br><span class="line">                    <span class="type">MultiMap</span> <span class="variable">responseHeaders</span> <span class="operator">=</span> t.headers();</span><br><span class="line">                    Map&lt;String, Collection&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                    responseHeaders.forEach((k, v) -&gt; map.put(k, Collections.singleton(v)));</span><br><span class="line">                    completableFuture.complete(Response.builder()</span><br><span class="line">                            .status(t.statusCode())</span><br><span class="line">                            .reason(t.statusMessage())</span><br><span class="line">                            .headers(map)</span><br><span class="line">                            .body(t.bodyAsBuffer().getBytes())</span><br><span class="line">                            .request(request)</span><br><span class="line">                            .build());</span><br><span class="line">                &#125;).onFailure(completableFuture::completeExceptionally);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置类装配 FeignClient bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxFeignClientConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> Client <span class="title function_">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span><br><span class="line"><span class="params">                              SpringClientFactory clientFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadBalancerFeignClient</span>(<span class="keyword">new</span> <span class="title class_">VertxFeignClient</span>(), cachingFactory, clientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>feign</tag>
        <tag>rpc</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign、Hystrix、Ribbon 超时机制</title>
    <url>/2025/02/09/feign/feign-hystrix-ribbon-chao-shi-ji-zhi/posts/undefined/</url>
    <content><![CDATA[<h2 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h2><ul>
<li><p>open-feign、hystrix、ribbon: 2.1.0.RELEASE</p>
</li>
<li><p>feign-okhttp: 10.1.0</p>
</li>
<li><p>archaius: 0.7.6</p>
</li>
<li><p>jackson: 2.17.0</p>
</li>
</ul>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul>
<li>feign.okhttp.enabled&#x3D;true   #feign 使用 OkHttpClient 作为 http 请求框架</li>
<li>feign.hystrix.enabled&#x3D;true   #开启 hystrix</li>
</ul>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img data-src="/images/feign/01.png" alt="img"></p>
<h2 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h2><h3 id="hystrix-超时"><a href="#hystrix-超时" class="headerlink" title="hystrix 超时"></a>hystrix 超时</h3><ul>
<li>最上层是 hystrix 超时，hystrix 会异步提交一个延时任务，延时时间就是配置的超时时间</li>
<li>配置 hystrix 全局的超时时间</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment"># 默认的配置，如果没有独立配置，那么这个会是默认的配置</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>[配置文件]配置具体接口的超时时间，${commandKey} 表示 commandKey，比如接口位于类 HttpBinFeign，方法名为 delay_3（），则 commandKey&#x3D;HttpBinFeign#delay_3（）；默认会优先读取具体接口的配置，具体接口的配置不存在则会使用默认的配置</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix.command.$&#123;commandKey&#125;.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">4000</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/feign/02.png" alt="img"></p>
<p><img data-src="/images/feign/03.png" alt="img"></p>
<ul>
<li><p>[@HystrixCommand]配置具体接口的超时时间</p>
<ol>
<li>启用切面</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HystrixCommandAspect <span class="title function_">hystrixCommandAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HystrixCommandAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>@HystrixCommand 配置，这里用了种取巧的方式，添加上此注解会先转换为 HystrixCommandProperties，然后当 Feign 接口封装为 hystrixCommand 时就会从 factory 中根据 cacheKey 获取，cacheKey 就是 commandKey，所以只需要保证在 feign 接口前面组装此配置就行。这里是取巧的方式，不确定会有什么问题- _ -</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">        commandKey = &quot;HttpBinFeign#delay_3()&quot;,</span></span><br><span class="line"><span class="meta">        commandProperties = &#123;</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delay_3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> httpBinFeign.delay_3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/images/feign/04.png" alt="img"></p>
<h3 id="feign、ribbon-超时配置"><a href="#feign、ribbon-超时配置" class="headerlink" title="feign、ribbon 超时配置"></a>feign、ribbon 超时配置</h3><ul>
<li>feign 未配置时，请求超时按 ribbon 配置；若配置了 feign 超时，则请求超时按 feign 配置</li>
<li>feign 全局超时配置，<strong>注意 connect-timeout 与 read-timeout 两个配置都需要配置</strong>，单独配置不生效</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      # 默认配置</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        connect-timeout: <span class="number">1000</span></span><br><span class="line">        read-timeout: <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/feign/05.png" alt="img"></p>
<ul>
<li><p>单个 feign 接口超时配置</p>
<ol>
<li>优先级： 配置分为 3 种，分别是代码配置、默认配置、单个接口配置文件配置；</li>
</ol>
<p>  默认情况下（feign.client.defaultToProperties&#x3D;true） 时配置优先级为 代码配置 -&gt; 默认配置 -&gt; 单个接口配置文件配置，优先级从低到高，高优先级的会覆盖低优先级的；</p>
<p>  feign.client.defaultToProperties&#x3D;false 时配置优先级为 默认配置 -&gt; 单个接口配置文件配置 -&gt; 代码配置；</p>
<p>  也就是说默认情况下代码配置会被默认配置覆盖，所以如果想要针对单个接口进行配置，必须要使用配置文件进行配置；当然也可以设置 feign.client.defaultToProperties&#x3D;false，这样代码配置的优先级最高</p>
<p>  <img data-src="/images/feign/06.png" alt="img"></p>
<ol start="2">
<li>单个接口配置</li>
</ol>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的httpbin代表的是FeignClient中的contextId</span></span><br><span class="line"><span class="attr">feign.client.config.httpbin.read-timeout</span>=<span class="string">2500</span></span><br><span class="line"><span class="attr">feign.client.config.httpbin.connect-timeout</span>=<span class="string">800</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>单个接口代码配置，注意配置类不能使用@component 注解，否则会全局生效</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFeignConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Request.Options <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Options(<span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;service-httpbin&quot;</span></span><br><span class="line"><span class="meta">        , contextId = &quot;httpbin&quot;, configuration = CustomFeignConfiguration.class</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ribbon 全局配置</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">5000</span> # 请求处理的超时时间</span><br><span class="line">  ConnectTimeout: <span class="number">2000</span> # 请求连接超时时间</span><br><span class="line">  # 以下两个重试配置表示同一个接口最多调用<span class="number">2</span>次，且第二次重试不在同一个实例上</span><br><span class="line">  MaxAutoRetries: <span class="number">0</span> #同一台实例最大重试次数,不包括首次调用</span><br><span class="line">  MaxAutoRetriesNextServer: <span class="number">1</span> # 切换实例的重试次数</span><br><span class="line">  OkToRetryOnAllOperations: <span class="literal">false</span> #重试操作，<span class="literal">false</span>表示只会对get接口进行重试</span><br></pre></td></tr></table></figure>

<h3 id="非负载均衡下调用"><a href="#非负载均衡下调用" class="headerlink" title="非负载均衡下调用"></a>非负载均衡下调用</h3><ul>
<li>feignClient 指定 url 则不会走 loadbalancer 调用，会直接使用 okHttpClient 进行调用，参考关系图中[1]</li>
<li>OkHttpClient 默认超时配置如下</li>
</ul>
<p><img data-src="/images/feign/07.png" alt="img"></p>
<ul>
<li>若配置了 feign 接口超时，则会覆盖 okHttpClient 配置</li>
</ul>
<p><img data-src="/images/feign/08.png" alt="img"></p>
<h3 id="负载均衡下的调用"><a href="#负载均衡下的调用" class="headerlink" title="负载均衡下的调用"></a>负载均衡下的调用</h3><ul>
<li>feignClient 未指定 url 时会根据 name 找到对应的服务，走 loadbalancer 调用，参考关系图中[2]</li>
<li>若指定了 feign 超时配置，则使用 feign 超时配置，否则使用 ribbon 超时配置</li>
</ul>
<p><img data-src="/images/feign/09.png" alt="img"></p>
<h3 id="超时机制总结"><a href="#超时机制总结" class="headerlink" title="超时机制总结"></a>超时机制总结</h3><ol>
<li>Hystrix 配置的超时时间需要大于 feign &amp; ribbon 配置的超时时间</li>
<li>由于 ribbon 有重试机制，所以 hystrix 配置的超时时间需要大于单个请求超时时间 * 请求的总次数（<strong>MaxAutoRetries+ 1）*（MaxAutoRetriesNextServer+1</strong>） </li>
<li>只要配置了 feign 超时，那么无论是 Okhttp 还是 ribbon 的超时都会被覆盖</li>
<li>feign 超时需要同时配置 connectTimeout &amp; readTimeout</li>
<li>建议 hystrix、feign、ribbon 都配置默认的超时时间，且 hystrix 超时时间 &gt; feign &#x3D;&#x3D; ribbon</li>
<li>针对独立接口的配置，需要注意 hystrix、feign 超时都需要配置</li>
</ol>
<h2 id="定制-CachingSpringLoadBalancerFactory，实现负载均衡到本地服务上"><a href="#定制-CachingSpringLoadBalancerFactory，实现负载均衡到本地服务上" class="headerlink" title="定制 CachingSpringLoadBalancerFactory，实现负载均衡到本地服务上"></a>定制 CachingSpringLoadBalancerFactory，实现负载均衡到本地服务上</h2><h3 id="自定义-CachingSpringLoadBalancerFactory，给所有服务添加本地地址"><a href="#自定义-CachingSpringLoadBalancerFactory，给所有服务添加本地地址" class="headerlink" title="自定义 CachingSpringLoadBalancerFactory，给所有服务添加本地地址"></a>自定义 CachingSpringLoadBalancerFactory，给所有服务添加本地地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalCachingSpringLoadBalancerFactory</span> <span class="keyword">extends</span> <span class="title class_">CachingSpringLoadBalancerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, FeignLoadBalancer&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String localHost;</span><br><span class="line">    <span class="keyword">private</span> Integer localPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalCachingSpringLoadBalancerFactory</span><span class="params">(SpringClientFactory factory, String localHost, Integer localPort)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory);</span><br><span class="line">        <span class="built_in">this</span>.localHost = localHost;</span><br><span class="line">        <span class="built_in">this</span>.localPort = localPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FeignLoadBalancer <span class="title function_">create</span><span class="params">(String clientName)</span> &#123;</span><br><span class="line">        <span class="type">FeignLoadBalancer</span> <span class="variable">client</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(clientName);</span><br><span class="line">        <span class="keyword">if</span>(client != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IClientConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">        <span class="type">ILoadBalancer</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">        <span class="comment">// 添加本地地址</span></span><br><span class="line">        lb.addServers(Lists.newArrayList(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="built_in">this</span>.localHost, <span class="built_in">this</span>.localPort)));</span><br><span class="line">        <span class="type">ServerIntrospector</span> <span class="variable">serverIntrospector</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">        client = loadBalancedRetryFactory != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">RetryableFeignLoadBalancer</span>(lb, config, serverIntrospector,</span><br><span class="line">                loadBalancedRetryFactory) : <span class="keyword">new</span> <span class="title class_">FeignLoadBalancer</span>(lb, config, serverIntrospector);</span><br><span class="line">        <span class="built_in">this</span>.cache.put(clientName, client);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入-bean，覆盖默认的配置-FeignRibbonClientAutoConfiguration"><a href="#注入-bean，覆盖默认的配置-FeignRibbonClientAutoConfiguration" class="headerlink" title="注入 bean，覆盖默认的配置 FeignRibbonClientAutoConfiguration"></a>注入 bean，覆盖默认的配置 FeignRibbonClientAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalRibbonConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.local.host:127.0.0.1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String localHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.local.port:8000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer localPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> CachingSpringLoadBalancerFactory <span class="title function_">cachingLBClientFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            SpringClientFactory factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalCachingSpringLoadBalancerFactory</span>(factory, localHost, localPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-BeanPostProcessor-修改-LoadBalancerFeignClient-中的-CachingSpringLoadBalancerFactory"><a href="#使用-BeanPostProcessor-修改-LoadBalancerFeignClient-中的-CachingSpringLoadBalancerFactory" class="headerlink" title="使用 BeanPostProcessor 修改 LoadBalancerFeignClient 中的 CachingSpringLoadBalancerFactory"></a>使用 BeanPostProcessor 修改 LoadBalancerFeignClient 中的 CachingSpringLoadBalancerFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalCachingSpringLoadBalancerFactoryBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String localHost;</span><br><span class="line">    <span class="keyword">private</span> Integer localPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalCachingSpringLoadBalancerFactoryBeanPostProcessor</span><span class="params">(String localHost, Integer localPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.localHost = localHost;</span><br><span class="line">        <span class="built_in">this</span>.localPort = localPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">loadBalancerFeignClient</span> <span class="operator">=</span> (LoadBalancerFeignClient) bean;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">lbClientFactory</span> <span class="operator">=</span> FieldUtils.getDeclaredField(LoadBalancerFeignClient.class, <span class="string">&quot;lbClientFactory&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                lbClientFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">var</span> <span class="variable">clientFactory</span> <span class="operator">=</span> FieldUtils.getDeclaredField(LoadBalancerFeignClient.class, <span class="string">&quot;clientFactory&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                clientFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 获取到 springClientFactory</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">springClientFactory</span> <span class="operator">=</span> (SpringClientFactory) clientFactory.get(loadBalancerFeignClient);</span><br><span class="line">                <span class="comment">// 构建local</span></span><br><span class="line">                <span class="type">LocalCachingSpringLoadBalancerFactory</span> <span class="variable">cachingSpringLoadBalancerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalCachingSpringLoadBalancerFactory</span>(springClientFactory, localHost, localPort);</span><br><span class="line">                <span class="comment">// 设置到值里面</span></span><br><span class="line">                lbClientFactory.set(loadBalancerFeignClient, cachingSpringLoadBalancerFactory);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>feign</tag>
        <tag>rpc</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>LoadBalancerClient 自定义</title>
    <url>/2025/02/09/feign/loadbalancerclient-zi-ding-yi/posts/undefined/</url>
    <content><![CDATA[<h2 id="自定义路由信息"><a href="#自定义路由信息" class="headerlink" title="自定义路由信息"></a>自定义路由信息</h2><blockquote>
<p>日常开发中 loadBalancer 一般是基于服务发现，不需要我们显示的指定；某些场景下（比如单元测试、联调）需要我们自定义 LoadBalancerClient，不走默认的服务发现，而是自定义路由信息</p>
</blockquote>
<ul>
<li><code>LoadBalancerClient</code> 默认的配置是 <code>LoadBalancerClientConfiguration</code></li>
<li>仿造 <code>LoadBalancerClientConfiguration</code> 实现自己的配置</li>
</ul>
<blockquote>
<p>由于<code>LoadBalancerClientConfiguration</code>也是基于 NamedContextFactory，所以我们只需要实现需要修改的配置，其他配置会默认读取<code>LoadBalancerClientConfiguration</code></p>
<p>比如下面的代码中，自定义了服务路由信息，会根据配置返回服务的路由信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceLoadBalanceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title function_">reactorServiceInstanceLoadBalancer</span><span class="params">(Environment environment,</span></span><br><span class="line"><span class="params">                                                                                   LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前 loadBalance 的 client name</span></span><br><span class="line">        <span class="comment">// 由于此配置用在 UserRegistrationService 上，所以这里默认 = user-service</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalancer</span>(</span><br><span class="line">                <span class="comment">// 这里相当于根据这个name，找到对应的子context，从里面获取到 ServiceInstanceListSupplier 对应的bean</span></span><br><span class="line">                <span class="comment">// 也就是相当于这个 UserRegistrationServiceLoadBalanceConfiguration 下配置的 ServiceInstanceListSupplier -&gt; 也就是 ServiceInstanceListSupplier</span></span><br><span class="line">                loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),</span><br><span class="line">                name</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInstanceListSupplier <span class="title function_">userServiceClientServiceInstanceListSupplier</span><span class="params">(</span></span><br><span class="line"><span class="params">            ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceServiceInstanceListSupplier</span>(context.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceServiceInstanceListSupplier</span> <span class="keyword">implements</span> <span class="title class_">ServiceInstanceListSupplier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceServiceInstanceListSupplier</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServiceId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> environment.getProperty(<span class="string">&quot;user-service-name&quot;</span>, <span class="string">&quot;user-service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;List&lt;ServiceInstance&gt;&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultServiceInstance</span> <span class="variable">defaultServiceInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultServiceInstance</span>();</span><br><span class="line">        defaultServiceInstance.setServiceId(getServiceId());</span><br><span class="line">        defaultServiceInstance.setHost(environment.getProperty(<span class="string">&quot;user-service-host&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">        defaultServiceInstance.setPort(Integer.parseInt(environment.getProperty(<span class="string">&quot;user-service-port&quot;</span>, <span class="string">&quot;8080&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> Flux.just(Arrays.asList(defaultServiceInstance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用，注解上指定配置即可</li>
</ul>
<blockquote>
<p>@LoadBalancerClient(name &#x3D; “user-service”, configuration &#x3D; UserServiceLoadBalanceConfiguration.class)</p>
</blockquote>
<ul>
<li>以上就能实现自定义路由的功能</li>
</ul>
]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>feign</tag>
        <tag>rpc</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>JFR入门</title>
    <url>/2025/02/09/jfr/jfr-ru-men/posts/undefined/</url>
    <content><![CDATA[<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li><a href="https://www.zhihu.com/column/c_1264859821121355776">hashcon JFR 全解</a></li>
</ul>
<h3 id="JVM-启动"><a href="#JVM-启动" class="headerlink" title="JVM 启动"></a>JVM 启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java - XX:StartFlightRecording=delay=6s,disk=<span class="literal">true</span>,dumponexit=<span class="literal">true</span>,filename=/Users/wulei/tmp/recording.jfr,maxsize=1024m,maxage=<span class="number">1d</span>,settings=/Users/wulei/IdeaProjects/personal/op-lei4play/op-samples/jfr/lei-<span class="keyword">default</span>.jfc,path-to-gc-roots=<span class="literal">true</span> -XX:FlightRecorderOptions=repository=/Users/wulei/tmp,stackdepth=<span class="number">64</span> test.Main</span><br></pre></td></tr></table></figure>



<p><code>-XX:StartFlightRecording</code>有这个参数就会启用 JFR 记录，以下是相关的参数</p>
<table>
<thead>
<tr>
<th align="center">配置 key</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">delay</td>
<td align="left">0</td>
<td align="left">延迟多久后启动 JFR 记录，支持带单位配置， 例如 delay&#x3D;60s（秒）， delay&#x3D;20m（分钟）， delay&#x3D;1h（小时）， delay&#x3D;1d（天），不带单位就是秒， 0 就是没有延迟直接开始记录。一般为了避免框架初始化等影响，我们会延迟 1 分钟开始记录（例如 Spring cloud 应用，可以看下日志中应用启动耗时，来决定下这个时间</td>
</tr>
<tr>
<td align="center">disk</td>
<td align="left">true</td>
<td align="left">是否写入磁盘，global buffer 满了之后，是直接丢弃还是写入磁盘文件</td>
</tr>
<tr>
<td align="center">dumponexit</td>
<td align="left">false</td>
<td align="left">程序退出时，是否要 dump 出 。jfr 文件</td>
</tr>
<tr>
<td align="center">duration</td>
<td align="left">0</td>
<td align="left">JFR 记录持续时间，同样支持单位配置，不带单位就是秒，0 代表不限制持续时间，一直记录</td>
</tr>
<tr>
<td align="center">filename</td>
<td align="left">启动目录&#x2F;hotspot-pid-26732-id-1-2020_03_12_10_07_22.jfr，pid 后面就是 pid， id 后面是第几个 JFR 记录，可以启动多个 JFR 记录。最后就是时间</td>
<td align="left">dump 的输出文件</td>
</tr>
<tr>
<td align="center">name</td>
<td align="left">无</td>
<td align="left">记录名称，由于可以启动多个 JFR 记录，这个名称用于区分，否则只能看到一个记录 id，不好区分</td>
</tr>
<tr>
<td align="center">maxage</td>
<td align="left">0</td>
<td align="left">这个参数只有在 disk 为 true 的情况下才有效。最大文件记录保存时间，就是 global buffer 满了需要刷入本地临时目录下保存，这些文件最多保留多久的。也可以通过单位配置，没有单位就是秒，默认是 0，就是不限制</td>
</tr>
<tr>
<td align="center">maxsize</td>
<td align="left">250MB</td>
<td align="left">这个参数只有在 disk 为 true 的情况下才有效。最大文件大小，支持单位配置， 不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。设置为 0 代表不限制大小**。虽然官网说默认就是 0，但是实际用的时候，不设置会有提示**： No limit specified， using maxsize&#x3D;250MB as default。 注意，这个配置不能小于后面将会提到的 maxchunksize 这个参数</td>
</tr>
<tr>
<td align="center">path-to-gc-roots</td>
<td align="left">false</td>
<td align="left">是否记录 GC 根节点到活动对象的路径，一般不打开这个，首先这个在我个人定位问题的时候，很难用到，只要你的编程习惯好。还有就是打开这个，性能损耗比较大，会导致 FullGC 一般是在怀疑有内存泄漏的时候热启动这种采集，并且通过产生对象堆栈无法定位的时候，动态打开即可。一般通过产生这个对象的堆栈就能定位，如果定位不到，怀疑有其他引用，例如 ThreadLocal 没有释放这样的，可以在 dump 的时候采集 gc roots</td>
</tr>
<tr>
<td align="center">settings</td>
<td align="left">default.jfc</td>
<td align="left">位于 <code>$JAVA_HOME/lib/jfr/default.jfc</code>采集 Event 的详细配置，采集的每个 Event 都有自己的详细配置。另一个 JDK 自带的配置是 profile.jfc，位于 <code>$JAVA_HOME/lib/jfr/profile.jfc</code>如果需要指定自己的配置，这里可以设置为全路径的配置文件，类似 <code>settings=/Users/wulei/tmp/lei-default.jfc</code></td>
</tr>
</tbody></table>
<p><strong><code>-XX:FlightRecorderOptions</code></strong> 相关的参数</p>
<table>
<thead>
<tr>
<th align="left">配置 key</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allow_threadbuffers_to_disk</td>
<td align="left">false</td>
<td align="left">是否允许 在 thread buffer 线程阻塞的时候，直接将 thread buffer 的内容写入文件。默认不启用，一般没必要开启这个参数，只要你设置的参数让 global buffer 大小合理不至于刷盘很慢，就行了</td>
</tr>
<tr>
<td align="left">globalbuffersize</td>
<td align="left">如果不设置，根据设置的 memorysize 自动计算得出</td>
<td align="left">单个 global buffer 的大小，一般通过 memorysize 设置，不建议自己设置</td>
</tr>
<tr>
<td align="left">maxchunksize</td>
<td align="left">12M</td>
<td align="left">存入磁盘的每个临时文件的大小。默认为 12MB，不能小于 1M。可以用单位配置，不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。注意这个大小最好不要比 memorySize 小，更不能比 globalbuffersize 小，否则会导致性能下降</td>
</tr>
<tr>
<td align="left">memorysize</td>
<td align="left">10M</td>
<td align="left">FR 的 global buffer 占用的整体内存大小，一般通过设置这个参数，numglobalbuffers 还有 globalbuffersize 会被自动计算出。可以用单位配置，不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB</td>
</tr>
<tr>
<td align="left">numglobalbuffers</td>
<td align="left">如果不设置，根据设置的 memorysize 自动计算得出</td>
<td align="left">global buffer 的个数，一般通过 memorysize 设置，不建议自己设置</td>
</tr>
<tr>
<td align="left">old-object-queue-size</td>
<td align="left">256</td>
<td align="left">对于 Profiling 中的 Old Object Sample 事件，记录多少个 Old Object，这个配置并不是越大越好。记录是怎么记录的，会在后面的各种 Event 介绍里面详细介绍。我的建议是，一般应用 256 就够，时间跨度大的，例如 maxage 保存了一周以上的，可以翻倍</td>
</tr>
<tr>
<td align="left">repository</td>
<td align="left">等同于 -Djava.io.tmpdir 指定的目录</td>
<td align="left">JFR 保存到磁盘的临时记录的位置</td>
</tr>
<tr>
<td align="left">retransform</td>
<td align="left">true</td>
<td align="left">是否通过 JVMTI 转换 JFR 相关 Event 类，如果设置为 false，则只在 Event 类加载的时候添加相应的 Java Instrumentation，这个一般不用改，这点内存 metaspace 还是足够的</td>
</tr>
<tr>
<td align="left">samplethreads</td>
<td align="left">true</td>
<td align="left">这个是是否开启线程采集的状态位配置，只有这个配置为 true，并且在 Event 配置中开启线程相关的采集（这个后面会提到），才会采集这些事件</td>
</tr>
<tr>
<td align="left">stackdepth</td>
<td align="left">64</td>
<td align="left">采集事件堆栈深度，有些 Event 会采集堆栈，这个堆栈采集的深度，统一由这个配置指定。注意这个值不能设置过大，如果你采集的 Event 种类很多，堆栈深度大很影响性能。比如你用的是 default.jfc 配置的采集，堆栈深度 64 基本上就是不影响性能的极限了。你可以自定义采集某些事件，增加堆栈深度</td>
</tr>
<tr>
<td align="left">threadbuffersize</td>
<td align="left">8KB</td>
<td align="left">threadBuffer 大小，最好不要修改这个，如果增大，那么随着你的线程数增多，内存占用会增大。过小的话，刷入 global buffer 的次数就会变多。8KB 就是经验中最合适的</td>
</tr>
</tbody></table>
<h3 id="jcmd-命令启动"><a href="#jcmd-命令启动" class="headerlink" title="jcmd 命令启动"></a>jcmd 命令启动</h3><ul>
<li><strong><code>jcmd &lt;pid&gt; JFR.start</code></strong> 启动 JFR 记录，参数和<code>-XX:StartFlightRecording</code>一模一样，请参考上面的表格。但是注意这里不再是逗号分割，而是空格示例，代表启动一个名称为 profile_online， 最多保留一天，最大保留 1G 的本地文件记录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jcmd 21 JFR.start name=profile_online maxage=1d maxsize=1g</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>jcmd &lt;pid&gt; JFR.stop</code></strong> 停止 JFR 记录，需要传入名称，例如如果要停止上面打开的，则执行：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jcmd 21 JFR.stop name=profile_online</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>jcmd &lt;pid&gt; JFR.check</code></strong> 查看当前正在执行的 JFR 记录</li>
<li><strong><code>jcmd &lt;pid&gt; JFR.configure</code></strong> 如果不传入参数，则是查看当前配置，传入参数就是修改配置。配置与-XX:FlightRecorderOptions 的一模一样。请参考上面的表格 示例</li>
<li><strong><code>jcmd &lt;pid&gt; JFR.dump</code></strong> 生成 jfr 文件</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">无</td>
<td align="left">指定要查看的 JFR 记录名称</td>
</tr>
<tr>
<td align="left">filename</td>
<td align="left">无</td>
<td align="left">指定文件输出位置</td>
</tr>
<tr>
<td align="left">maxage</td>
<td align="left">0</td>
<td align="left">dump 最多的时间范围的文件，可以通过单位配置，没有单位就是秒，默认是 0，就是不限制</td>
</tr>
<tr>
<td align="left">maxsize</td>
<td align="left">0</td>
<td align="left">dump 最大文件大小，支持单位配置， 不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。设置为 0 代表不限制大小</td>
</tr>
<tr>
<td align="left">begin</td>
<td align="left">无</td>
<td align="left">dump 开始位置， 可以这么配置：09:00， 21:35:00， 2018-06-03T18:12:56.827Z， 2018-06-03T20:13:46.832， -10m， -3h， or -1d</td>
</tr>
<tr>
<td align="left">end</td>
<td align="left">无</td>
<td align="left">dump 结束位置，可以这么配置： 09:00， 21:35:00， 2018-06-03T18:12:56.827Z， 2018-06-03T20:13:46.832， -10m， -3h， or -1d （STRING， no default value）</td>
</tr>
<tr>
<td align="left">path-to-gc-roots</td>
<td align="left">false</td>
<td align="left">是否记录 GC 根节点到活动对象的路径，一般不记录，dump 的时候打开这个肯定会触发一次 fullGC，对线上应用有影响。最好参考之前对于 JFR 启动记录参数的这个参数的描述，考虑是否有必要</td>
</tr>
</tbody></table>
<h3 id="jfr-配置文件"><a href="#jfr-配置文件" class="headerlink" title="jfr 配置文件"></a>jfr 配置文件</h3><ul>
<li>openJdk 11.0.22</li>
</ul>
<p> <a href="/files/default.jfc">default.jfc</a> </p>
<p> <a href="/files/profile.jfc">profile.jfc</a> </p>
<ul>
<li>优化后的配置文件，基于 openJdk 11.2.22 default.jfr，根据👇🏻JFR Event 中的建议对于某些事件进行了关闭或者调整</li>
</ul>
<p> <a href="/files/lei-default.jfc">lei-default.jfc</a> </p>
<h3 id="JFR-Event"><a href="#JFR-Event" class="headerlink" title="JFR Event"></a>JFR Event</h3><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/124242959">EVENT-1</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/126709861">EVENT-2</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/158592899">EVENT-3</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/158592899">JIT相关jfr事件</a></p>
</li>
</ul>
<p><img data-src="/images/jfr_01_01.png" alt="img"></p>
]]></content>
      <categories>
        <category>JFR</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JFR</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>JFR详解</title>
    <url>/2025/02/20/jfr/jfr-xiang-jie/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本篇文章参考张哥JFR全系列</a></li>
</ul>
<h2 id="为什么需要JFR"><a href="#为什么需要JFR" class="headerlink" title="为什么需要JFR?"></a>为什么需要JFR?</h2><h3 id="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式"><a href="#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式" class="headerlink" title="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式"></a>我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 <code>OpenTelemetry</code> 标准的监控方式</h3><ul>
<li>arthas: 主要用于实时定位问题，必须有问题线程，必须复现才能定位，没法事后定位，如果有应用问题也可能挂载不上。<br>JFR可以实现从JVM启动开始一直持续采集监控与事后定位，即使应用有问题卡住，也基本能通过JFR定位。</li>
<li>APM 框架: 例如 micrometer，open-telemetry，Skywalking 等等，大部分基于 <code>Java Agent</code> 和侵入代码的方式结合实现，<br>这些对于JFR来说：<ul>
<li>这些框架没办法采集JVM层面的指标</li>
<li>JVM协调安全点，JVM卡住，Java应用有问题，CPU吃满等等，这些框架会受很大影响</li>
</ul>
</li>
</ul>
<h3 id="结合学习-JVM-JDK-的最佳方式"><a href="#结合学习-JVM-JDK-的最佳方式" class="headerlink" title="结合学习 JVM + JDK 的最佳方式"></a>结合学习 JVM + JDK 的最佳方式</h3><ul>
<li>JFR 有哪些事件，为啥要采集这些事件</li>
<li>采集这些事件的机制</li>
<li>搞懂上面的问题，基本从 JVM 到 JDK 的任意一个细节都搞懂了，比如：<ul>
<li>JVM GC 的时候有哪些阶段，每个阶段耗时与做了什么？看 GC 相关 JFR 事件</li>
<li>JVM Safepoint 是啥，有啥原因会进入 safePoint？看 Safepoint 相关 JFR 事件</li>
<li>JDK 中的 AQS 究竟基于啥，实现原理是啥？看 Thread Park 事件属性与对应线程栈</li>
</ul>
</li>
</ul>
<h2 id="JFR-如何实现高效"><a href="#JFR-如何实现高效" class="headerlink" title="JFR 如何实现高效"></a>JFR 如何实现高效</h2><ul>
<li><img data-src="/images/jfr/01.png" alt="img"></li>
</ul>
<h2 id="JFR-如何从-JVM-启动一开始监控到任意时候"><a href="#JFR-如何从-JVM-启动一开始监控到任意时候" class="headerlink" title="JFR 如何从 JVM 启动一开始监控到任意时候"></a>JFR 如何从 JVM 启动一开始监控到任意时候</h2><blockquote>
<p>突破 JFR 本身限制，不用 dumponexit，不用主动 dump</p>
</blockquote>
<ul>
<li>JFR 写入磁盘的 Data Chunk，默认在临时目录(<code>java.io.tmpdir</code>)，这个可以通过<br>JFR 配置限制<ul>
<li><code>maxage</code>：限制保留的 JFR 事件的最早时间</li>
<li><code>maxsize</code>：限制保留在本地磁盘临时文件的最大总大小</li>
</ul>
</li>
<li>Java 14开始，增加了 JFR Event Streaming 机制<ul>
<li>写入的临时文件不再是.part，而是.jfr，这样即使JMC无法解析，也可以使用jfr命令解析</li>
<li>java 14 引入定时任务定时（默认1s）执行 JFR Flush 将元数据刷入本地文件 Data Chunk，这样大概率最新的文件就是数据完整的，即可以被JMC解析</li>
</ul>
</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Java-17-以上的-JDK"><a href="#Java-17-以上的-JDK" class="headerlink" title="Java 17 以上的 JDK"></a>Java 17 以上的 JDK</h3><blockquote>
<p>Azul、Corretto、OpenJdk随意</p>
</blockquote>
<h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><blockquote>
<p>下载最新版本即可，即 JMC 9</p>
</blockquote>
<h3 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h3><blockquote>
<p><code>WhiteBox API</code> 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的API暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解JVM并调优参数</p>
</blockquote>
<ul>
<li>编译 WhiteBox API<ol>
<li>拉取 openjdk 源码</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 --filter=blob:none --sparse https://github.com/openjdk/jdk</span><br><span class="line">cd jdk</span><br><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout set test/lib/jdk/test/whitebox</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建 maven 空项目，将刚刚拉取的代码复制进去，执行 <code>maven package</code> 即可</li>
<li>将编译的 jar 包放在项目根目录，通过 maven 本地 system 依赖的方式将 jar 包加入依赖<br><img data-src="/images/jfr/02.png" alt="img"></li>
<li>不想自己构建可以使用 <a href="/files/jfr/whitebox-1.0-SNAPSHOT.jar">whitebox-1.0-SNAPSHOT.jar</a></li>
<li>编写测试代码<ul>
<li>代码</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWhiteBox</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            主要用于添加WhiteBox测试API的jar包，这个jar必须通过引导类加载器加载，因为它需要访问JVM内部功能，/a 表示append，将指定的jar追加到引导类路径末尾</span></span><br><span class="line"><span class="comment">            -Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            解锁JVM诊断选项，启用一些默认被禁用的诊断/调试选项，这是使用WhiteBox API的前提条件</span></span><br><span class="line"><span class="comment">            -XX:+UnlockDiagnosticVMOptions</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            启用WhiteBox测试API，WhiteBox API提供了访问JVM内部状态的能力</span></span><br><span class="line"><span class="comment">            -XX:+WhiteBoxAPI</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            开启GC日志记录，输出带有gc标签的日志</span></span><br><span class="line"><span class="comment">            -Xlog:gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 获取 ReservedCodeCacheSize 这个 JVM flag 的值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">reservedCodeCacheSize</span> <span class="operator">=</span> whiteBox.getUintxVMFlag(<span class="string">&quot;ReservedCodeCacheSize&quot;</span>);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        <span class="comment">// 打印内存各项指标</span></span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        <span class="comment">// 执行 full GC</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        <span class="comment">// 保持进程不退出，打印完整日志</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动VM Options</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果，出现 NoSuchMethodError 错误没关系，因为打包的是最新的 whitebox，使用的jdk版本可能没有某些最新的api<br><img data-src="/images/jfr/03.png" alt="img"></li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JFR</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JFR</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存相关的监控指标</title>
    <url>/2025/02/09/jvm/jvm-nei-cun-xiang-guan-de-jian-kong-zhi-biao/posts/undefined/</url>
    <content><![CDATA[<p><img data-src="/images/jvm/jvm-memory.PNG" alt="jvm内存图片"></p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><blockquote>
<p>JVM Heap代表存放Java Objects的Heap</p>
</blockquote>
<h3 id="Non-Heap"><a href="#Non-Heap" class="headerlink" title="Non-Heap"></a>Non-Heap</h3><h4 id="1-SpringBoot的JVM-metrics埋点代码"><a href="#1-SpringBoot的JVM-metrics埋点代码" class="headerlink" title="1. SpringBoot的JVM metrics埋点代码"></a>1. SpringBoot的JVM metrics埋点代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过io.micrometer.core引入了JVMMemoryuMetrics这个埋点实现</span></span><br><span class="line"><span class="keyword">for</span> (MemoryPoolMXBean memoryPoolBean : ManagementFactory.getPlatformMXBeans(MemoryPoolMXBean.class)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> MemoryType.HEAP.equals(memoryPoolBean.getType()) ? <span class="string">&quot;heap&quot;</span> : <span class="string">&quot;nonheap&quot;</span>;</span><br><span class="line">    Iterable&lt;Tag&gt; tagsWithId = Tags.concat(tags, <span class="string">&quot;id&quot;</span>, memoryPoolBean.getName(), <span class="string">&quot;area&quot;</span>, area);</span><br><span class="line"></span><br><span class="line">    Gauge.builder(<span class="string">&quot;jvm.memory.used&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getUsed))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The amount of used memory&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line"></span><br><span class="line">    Gauge</span><br><span class="line">        .builder(<span class="string">&quot;jvm.memory.committed&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getCommitted))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The amount of memory in bytes that is committed for the Java virtual machine to use&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line"></span><br><span class="line">    Gauge.builder(<span class="string">&quot;jvm.memory.max&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getMax))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The maximum amount of memory in bytes that can be used for memory management&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MemoryPoolMXBean接口的实现类是sun.management.MemoryPoolImpl，该类通过native method得到JVM提供的内存使用信息</span></span><br><span class="line"><span class="comment">// Native VM support</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> MemoryUsage <span class="title function_">getUsage0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-JVM本身的代码"><a href="#2-JVM本身的代码" class="headerlink" title="2. JVM本身的代码"></a>2. JVM本身的代码</h4><blockquote>
<p>设置-XX:NativeMemoryTracking&#x3D;summary或者details，然后使用jcmd去查看</p>
</blockquote>
<ul>
<li>CodeCache</li>
<li>Metaspace</li>
<li>CompressedClassSpace</li>
<li>DirectBuffer</li>
<li>Thread Stacks</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-JVM里used内存很低，但是容器物理内存占用很高"><a href="#1-JVM里used内存很低，但是容器物理内存占用很高" class="headerlink" title="1. JVM里used内存很低，但是容器物理内存占用很高"></a>1. JVM里used内存很低，但是容器物理内存占用很高</h4><p>因为k8s不允许使用交换分区，所以这里不用考虑外存和内存的交换关系。</p>
<p>JVM申请内存的时候，会预先使用<strong>pretouch</strong>的方式声明去告知OS，期望使用多少size的内存，由于物理内存的分配（内核本身的虚拟内存-物理内存管理）时惰性的，所以声明要使用多少size，不代表物理内存就立刻分配多少。</p>
<p>比如JavaHeap声明了1G的内存需要使用，但实际使用过程中，物理内存也是逐步被分配的，由于JavaHeap的内存被JVM的GC管理，当Heap满时，JVM的GC会内部释放内存空间，很明显，GC的过程不会让OS感知，不会去释放物理内存，假如FGC后，JavaHeap实际used的内存（常驻在JavaHeap）中只有200M，但此时容器物理内存很可能是1G多。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>监控</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM重要参数</title>
    <url>/2025/02/09/jvm/jvm-chong-yao-can-shu/posts/undefined/</url>
    <content><![CDATA[<h2 id="常规启动配置参数"><a href="#常规启动配置参数" class="headerlink" title="常规启动配置参数"></a>常规启动配置参数</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+PrintFlagsFinal</td>
<td align="left">启动时打印出所有JVM参数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;heap.hprof-XX:+ExitOnOutOfMemoryError</td>
<td align="left">开启OOM时堆转储指定dump文件位置发生 OOM 时强制 JVM 立即退出</td>
<td align="left">！！dump hprof文件时要求内存比较大，这块后续要再找更好的方案</td>
</tr>
<tr>
<td align="left">-Xlog:gc*:file&#x3D;gc.log::filecount&#x3D;5,filesize&#x3D;20M</td>
<td align="left">JDK 9+ 的新版 GC 日志参数-Xlog:  gc*                    # 记录所有gc相关日志  :file&#x3D;gc.log          # 输出到gc.log文件  :                           # 空的tag过滤器  :filecount&#x3D;5,         # 最多保留5个文件  filesize&#x3D;20M          # 每个文件最大20MB</td>
<td align="left">等价  jdk8           -verbose:gc        -Xloggc:&#x2F;path&#x2F;to&#x2F;gc.log        -XX:+PrintGCDetails        -XX:+PrintGCDateStamps        -XX:+PrintGCTimeStamps        -XX:+UseGCLogFileRotation        -XX:NumberOfGCLogFiles&#x3D;5        -XX:GCLogFileSize&#x3D;20M</td>
</tr>
<tr>
<td align="left">-XX:StartFlightRecording&#x3D;delay&#x3D;1s,disk&#x3D;true,dumponexit&#x3D;true,filename&#x3D;.&#x2F;logs&#x2F;recording.jfr,maxsize&#x3D;1024m,maxage&#x3D;1d,path-to-gc-roots&#x3D;true-XX:FlightRecorderOptions&#x3D;stackdepth&#x3D;128</td>
<td align="left">jfr启动参数，具体参考 <a href="https://rq3nt70g815.feishu.cn/wiki/CtdmwY0yPiUkgKkXidecur63nVc">JFR</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-Xlog:safepoint&#x3D;debug:file&#x3D;.&#x2F;logs&#x2F;safepoint.log:utctime,level,tags:filecount&#x3D;50,filesize&#x3D;100M</td>
<td align="left">safepoint</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><img data-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBwgHBgkIBwgKCgkLDRYPDQwMDRsUFRAWIB0iIiAdHx8kKDQsJCYxJx8fLT0tMTU3Ojo6Iys/RD84QzQ5OjcBCgoKDQwNGg8PGjclHyU3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3N//AABEIAJIAmgMBIgACEQEDEQH/xAAbAAABBQEBAAAAAAAAAAAAAAAAAQIDBAUGB//EADsQAAEDAgQEBAQEBAUFAAAAAAEAAgMEEQUSIUETMVFxBhRhgQciUrEyQmKhI5HB8BUz0eHxJFOCosL/xAAaAQADAQEBAQAAAAAAAAAAAAAAAQIDBAUG/8QAIhEAAgICAgIDAQEAAAAAAAAAAAECEhETAyEEQTFRYSMi/9oADAMBAAIRAxEAPwD0MytCXjsHM2WZIHEfiUeUlti7mttiDWawnYeTk4vbb8Sw8hjdo4+ysRhz/wAx90XQay/dpv8AMo3ZTpmVKanIcCye3UJhL9AZOSWxD1l405GpfYKpOGC9pNU08U2u+4TTAXcnJbS1xkcbXF3op3RtylDKZ312UsdC69890nzBUqGN9tCAE3hzX+V5stZlM0bk+ym4AaBbL/JQ+YMIxmmpHJTWlIHG5bLQdEdiB2CjdC473S3DwVHWI7clVdcHVaYoiTqLqVuHjcAd0tw8IxmuN9BdTszDa11rigYOdvZPEEDOQBPqpfKw6M+NjrcrqXK76VbztbsB2ScVqWxhj8Mhpc5SiMDkpwY+rT2Trx/pWO03oRNjupG05HIXupWmP09lI0xpbBOBX8oz8zdUjqSPTQDurgyHkbJbDYg90tgqlIUjNiB2S+VaN7q0RbYHsmPIAJcGgW1JHJLYWkzm/F2Lnw/QxywRtdPNJkYZBdjdLkkb9lV8L+IcRqKgwYtE17XluSaKMM5i/UXHL16rlMfxHw/iviGWoqa+udTmwY1sRyxkC1tTexIHIb+67Dw6aOqjilo6uN7WkaAXJHr0OhQ3L5NlCDj+nWtdcaa+ycNVUL3A80GR+zkrMx1P0XCBum2aFSMkn1Jpkfu5Fh6WXjKByUbpVSMjut0mc7pWZa4C0ZTsk4p3VXOdkcRyVh6S1nvtdJn/AEqtxHJOI5Kw9QgicVI2E7q5wkcMjksrmmSrwrJwblU5jcmmNydhEd7b2Rn9bp3Dd6e6DGd8qLDqMLhvf2XEePfFIpoZcJw94NQ9uWeRpvwwfyj1OvYLovFWKf4JgdTVtLeNbJCDu88tPTU9gVyHgDwzHVsOM4pEJxI69OyTW5vq8g89eW2hO4WsGkrMMd4OJno6mmYx9TTyRMe0Oa57bZgeVvRXMFqoYZeDVSPZTSOaXPZq6F7TdkjfVpv7Fw3Xp3jiJsnh+UvLQ5rhlceQJ0sb7G9u9l5A0NIFtH7EfddEJWXRLiz0Ol8e8OpMOI04tZp4kJ5XAPI9/Rb1L4pwWpbf/EY4zzLZ/k/c6KpgsGD+IsEp5KiipZZY2COT5QHMIHUajSxTJvAmDSA5BUw6/kmv9wVjJwz2ilGXo6Jk8MgjeyeMtkPyFrwQ62hsd9U/Kd1nYdgNBQUkEEcb3CH8L5Hkm981+nMk8t1p5RfUg9llJr0XhjbIspA1qcA1TYMMiDUZFLZqDbZKwYIuGjhqRCVgwWfMt+k+yXzDehHdUgxyMjlhdGmuJcNQNkwzqtkcs7G8UGD08dRLDJIx0gZmb+FhPLMdht3Kall4QUijXfUBrSXGwHM35Ko3FKNzS5tTFZvMl4H3XGVWL1GIuBlJEIdpHHqB6n6j/eyeyOM5JcjZBe4DxcHp6FbqHXZOUjS8QR4Z4jdDSy1BkawEtEb7XcdARsSP6roKaCOlp4aeEAQxRtjaB0AsFQo5G4lLG9sYDaYXyEcnnp6WBWkWHYLOc8Kv0Woo434iVcjKeKm+bgvaXECxzO2/l/W+y82zG3ys6a6C69N+JMLRgLZnCz2yhjf/AC/4XneH0VTiFU2lo4uLM4EtbcDlvc6Ls4ZpwyYci/0WsAxmfBsRZU04zxZck0OYgSj+mu9tl2MPxEp3H+Nh0zevDlDvfkFk0Xw9xWY3q6impm6XsTI7+QsP/Za0nw4g4IbBisrZur4QWn2uPuonPib7ZcVKJoM8d4OYOJ/1Qf8A9rhfN97fuoHePqO38KhqXH9bmt+xKyKn4e4lE29LWU1RbYgxk/cfuqB8LY7Gcpw+Q+rZGOH7FZ/y+zWP6dzgXiWnxepNOKeSGXLmaHOBBW+BfnsvLKenxbAaiKudRyRGIkB72EsFxbW3ddTgjccxt8dVXVLoaLRwji+TijoLa27rKeF8MprHZ1YanZUoYSBdPbGsrGTYzKNzZGVv1KbIjIixDkU7uCM7k2zvqRkv+Ik9lhc36FzndRVcMVXTS09RG2SGRuV7DuFJkA5BxRb9DihTDo8xrKSowDEjTyvc9hGaOU/nb179R773OxDJFKxsmrIsoL7n83Rv96LqMZwuHFKMwSscyQHNFIBqx3X/AGWRguGPpI5KjFoGxNpb2Jddrg0Xz9u9uwXdDyE4mcomng1M9ofNIAwyCzGci1vUrQztcdJGk22PNeD43PTVGLVtRSZxTzzGRmcWPzakW7kqAUU7rWo5rHlaE2Wj8a3bkTswehfFHEBw6LDmvHzEzPsdRrlH75knwxobmrxF45WhjPU83f8AyuNoMCxaslEdLh1Wb7uic1o9zovZMAwyLB8IpqFpa50bfnf9TzqT2udPSyXNNcfHUI9yyXAbbXT2u/Slu3qB2S3ZubrgcmzVtCZjsLIuTzTg6MbA904PZs1qVmTZDC0OGUi4I5KSNmgyiwGiUSAcgB2ThIlZkuRI2NxUjY3JjH3ViJ1yjLMpNjRE4peC5XYos3JTcILakvRhtOQ80jzSwvNu+pHmnH8ypeOd2TcNSk8ysTzLut0nmTunoDJuGqXL/EGqqXeH+DSNc4z1DI5A3nlN9Pc5R7q4ai/X2TWzZb6kX6q4cVZZJfaDwxgVJgNKyzI31xH8WoIub/S0nkFueZ/UsU1HrdJx1UuOUpZYLCNg1P6k3zPrdZJmSGZLSGTX8yjzCx+KniVGlBk1hUJwqFkiRSCRS+JAagnUjZ1ltkUzJFL40NI1opVdgk1WLFIrkU1uZsoccClDJ0UE4jFz0TvPtXL1+I8Mtha7XmVVOIuv+JZT8mcXVER8By7OWEiUSLLfX08Oks8TT0LgqsniCgZye55H0tP9f9V69Asb/EQJFiQ47QzW/jhh6PBH+yuxzskF43teOrSD9kUCxf4iOIqXERxE6CsXeIjiKmJEGRFAsXOIjiKlxEcROgrF3ipwlVDiJwkQ4BY0RKpWyrNEqkbIs3AtSNISqRsqz2yKQSrNxNEzTZNZTipDGuLuQF1lNlT+JmaW9QQs3E0XyUZK8zSOkdzcbpvm1jvlySOb0NknHXE+LLPUWMHFAADQAdkIQvcPnxCla4tN2lwdsWmyEIAuRYpXx8ql5A2f833VyLxFO0gTRROHUaFY6LIA7eKYSRtkYczHC7SnZ1z+BVpEZpn7as7LW4+mipLJDeC1nRnVYT90cfv7p4DJZzpQ9U+OkM52RUDRD1I2RZYmcnCY7qXAtM1RKN1I2YbLKEikbIocDRM1ROnCdZgkOydxDa5WbgaJmdXPtVSepuoOInYobVF+oVPOuaUOzsjydGGhCF3nlghCEACEIQA6N7o5GvbzabhdNDO2aNsjOThdcv2WhhM+Rxid+F2o7pxEzbz2Rnuoc4PfdGZWSTZgeaS7VFmRmTAluByTg5Vy5AfZAFtr08SKlxE4SKGi0y6JUvEuFT4iOIocS0yLFDfL6LOMmqu1rrxLJus3E2jyYRVQhC1OYEIQgAQhCABPg/zmd0ITA3hyQUIVokVIhCABBQhACJQhCAQ5CEKWUQ1X+Wso80IUSLR//9k=" alt="123"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm监控和故障处理工具</title>
    <url>/2025/02/19/jvm/jvm-jian-kong-he-gu-zhang-chu-li-gong-ju/posts/undefined/</url>
    <content><![CDATA[<h3 id="命令行处理工具"><a href="#命令行处理工具" class="headerlink" title="命令行处理工具"></a>命令行处理工具</h3><h4 id="1-jps"><a href="#1-jps" class="headerlink" title="1. jps"></a>1. jps</h4><blockquote>
<p>显示指定系统类所有的HotSpot虚拟机进程</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有java进程，输出主类的名称</span></span><br><span class="line">jps -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机进程启动时传给主类main()函数的参数</span></span><br><span class="line">jps -m </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机启动时JVM参数</span></span><br><span class="line">jps -v</span><br></pre></td></tr></table></figure>

<h4 id="2-jstat"><a href="#2-jstat" class="headerlink" title="2. jstat"></a>2. jstat</h4><blockquote>
<p>用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
</blockquote>
<blockquote>
<p>命令格式: jstat [ option vmind [interval[s|ms]] [count] ]-printcompilation</p>
</blockquote>
<ul>
<li>选项<code>option</code>代表用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况 使用 <code>jstat -options</code> 获取支持的options</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
<td><img data-src="/images/jvm/img.png" alt="img.png"></td>
</tr>
<tr>
<td>-gc</td>
<td>监视java堆状况</td>
<td><img data-src="/images/jvm/img2.png" alt="img.png">  <img data-src="/images/jvm/img3.png" alt="img.png"></td>
</tr>
<tr>
<td>-gccapacity</td>
<td>与-gc基本相同，主要关注堆各个区域使用到的最大最小空间</td>
<td><img data-src="/images/jvm/img4.png" alt="img.png"></td>
</tr>
<tr>
<td>-gcutil</td>
<td>与-gc基本相同，主要关注已使用空间占总空间的百分比</td>
<td><img data-src="/images/jvm/img5.png" alt="img.png"></td>
</tr>
<tr>
<td>-gccause</td>
<td>与-gcutil基本相同，但是会额外输出导致上一次GC产生的原因</td>
<td>LGCC: 上一次垃圾收集的原因 GCC: 触发垃圾收集的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
<td></td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>与gcnew基本相同，主要关注使用到的最大、最小空间</td>
<td></td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC状况</td>
<td></td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>与gcold基本相同，主要关注使用到的最大、最小空间</td>
<td></td>
</tr>
<tr>
<td>-gcmetacapacity</td>
<td>metaspace用的最大、最小空间</td>
<td></td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译器编译过的方法、耗时等信息</td>
<td></td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被JIT编译的方法</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-jinfo"><a href="#3-jinfo" class="headerlink" title="3. jinfo"></a>3. jinfo</h4><blockquote>
<p>Java配置信息工具。使用<code>jps -v</code>可以查看虚拟机启动时显示指定的参数列表，如果想知道未被显示指定的参数的系统默认值，可以使用 jinfo 的 -flag 选项查询</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看进程所有的参数</span></span><br><span class="line">jinfo -flags #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个参数</span></span><br><span class="line">jinfo -flag UseG1GC #pid</span><br></pre></td></tr></table></figure>

<h4 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4. jmap"></a>4. jmap</h4><blockquote>
<p>jmap(Memory Map for Java) 命令用于生产堆快照(heapdump)。还可以查询finalize执行队列、java堆和metaspace的详细信息，如空间使用率、当前使用的是哪种收集器</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 jmap 查看更多命令</span></span><br><span class="line">jmap </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示堆中对象统计信息，包括类、实例数量、合计容量</span></span><br><span class="line">jmap -histo:live,file=histo.data #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成dump快照 在线分析工具 https://heaphero.io/</span></span><br><span class="line">jmap -dump:live,format=b,file=hh.bin #pid</span><br></pre></td></tr></table></figure>

<h4 id="5-jstack"><a href="#5-jstack" class="headerlink" title="5. jstack"></a>5. jstack</h4><blockquote>
<p>用于生成虚拟机当前时刻的线程快照</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前线程堆栈输出到某个文件</span></span><br><span class="line">jstack -l 17723 &gt; thread.info</span><br></pre></td></tr></table></figure>

<h4 id="6-jcmd"><a href="#6-jcmd" class="headerlink" title="6. jcmd"></a>6. jcmd</h4><blockquote>
<p>jcmd 是从 Java 7 开始引入的一个命令行工具。它提供了一种非常强大和灵活的方式来与 JVM 进行交互，可以用于诊断和监控 Java 应用程序。jcmd是以上工具的集合</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用命令</span></span><br><span class="line">jcmd &lt;pid&gt; help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 JVM 运行时信息</span></span><br><span class="line">jcmd &lt;pid&gt; VM.info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印堆转储</span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump &lt;filename&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印线程信息</span></span><br><span class="line">jcmd &lt;pid&gt; Thread.print</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印系统属性</span></span><br><span class="line">jcmd &lt;pid&gt; VM.system_properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 JVM 配置参数</span></span><br><span class="line">jcmd &lt;pid&gt; VM.flags</span><br></pre></td></tr></table></figure>

<h3 id="可视化处理工具"><a href="#可视化处理工具" class="headerlink" title="可视化处理工具"></a>可视化处理工具</h3><h4 id="1-JCconsole"><a href="#1-JCconsole" class="headerlink" title="1. JCconsole"></a>1. JCconsole</h4><blockquote>
<p>JConsole 是一个图形化界面，用于监控和配置 Java 应用程序。它提供了一些基本的监控功能，如线程、内存、垃圾回收、类加载等，并提供了插件机制，可以扩展到更复杂的监控需求。</p>
</blockquote>
<p>a. 启动JConsole</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位于jdk/bin目录下</span></span><br><span class="line">open `sdk home java 17.0.11-zulu`/bin/jconsole</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>监控</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s监控</title>
    <url>/2025/02/10/k8s/k8s-jian-kong/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://kubernetes.io/zh-cn/docs/home/">官方文档</a></li>
</ul>
<h3 id="metric-server"><a href="#metric-server" class="headerlink" title="metric-server"></a>metric-server</h3><p>从 Kubernetes v1.8 开始，资源使用情况的监控可以通过 <strong>Metrics</strong> <strong>API</strong> 的形式获取，例如容器 CPU 和内存使用率。这些度量可以由用户直接访问（例如，通过使用 kubectl top 命令）；<strong>Metrics-Server</strong> 是集群核心监控数据的聚合器。通俗地说，它存储了集群中各节点的监控数据，并且提供了 API 以供分析和使用。Metrics-Server 作为一个 Deployment 对象默认部署在 Kubernetes 集群中。不过准确地说，它是 Deployment，Service，ClusterRole，ClusterRoleBinding，APIService，RoleBinding 等资源对象的综合体。</p>
<ul>
<li>metric-server 提供的是实时的指标（实际是最近一次采集的数据，保存在内存中），并没有数据库来存储</li>
<li>这些数据指标并非由 metric-server 本身采集，而是由每个节点上的 cadvisor 采集，metric-server 只是发请求给 cadvisor 并将 metric 格式的数据转换成 aggregate api</li>
<li><a href="https://cloud.tencent.com/developer/article/2180278">K8s 监控之 Metrics-Server 指标获取链路分析</a></li>
</ul>
<h4 id="一、验证-metric-server-功能"><a href="#一、验证-metric-server-功能" class="headerlink" title="一、验证 metric-server 功能"></a>一、验证 metric-server 功能</h4><ol>
<li><p>通过 raw api 获取 cadvisor 指标</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw=/api/v1/nodes/&#123;nodename&#125;/proxy/metrics/cadvisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 cAdvisor 的本地接口&#x2F;metrics&#x2F;cadvisor 获取数据</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的token查看👇🏻这章的内容 </span></span><br><span class="line">curl -k -H <span class="string">&quot;Authorization: Bearer <span class="variable">$TOKEN</span>&quot;</span> https://127.0.0.1:10250/metrics/cadvisor</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="二、处理-cadvisor-权限问题"><a href="#二、处理-cadvisor-权限问题" class="headerlink" title="二、处理 cadvisor 权限问题"></a>二、处理 cadvisor 权限问题</h4><ol>
<li><p>新建 ServiceAccount</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">monitor</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 ClusterRole，构造访问权限</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">metrics-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodes/stats</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodes/metrics</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodes/proxy</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定账号和角色 ClusterRoleBinding</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">monitor-clusterrolebinding-i26re</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">metrics-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">monitor</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给 ServiceAccount 生成 token</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;:</span> <span class="string">&quot;Secret&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;:</span> <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;monitor-token&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;annotations&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;kubernetes.io/service-account.name&quot;:</span> <span class="string">&quot;monitor&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;kubernetes.io/service-account-token&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看创建的 token</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">secret</span> <span class="string">monitor-token</span> <span class="string">-n</span> <span class="string">kube-system</span> <span class="string">-o</span> <span class="string">jsonpath=&#x27;&#123;.data.token&#125;&#x27;</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">--decode</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="三、配置-prometheus"><a href="#三、配置-prometheus" class="headerlink" title="三、配置 prometheus"></a>三、配置 prometheus</h4><ol>
<li><p>具体配置</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cadvisor</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-cadvisor&#x27;</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">    <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">authorization:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Bearer</span></span><br><span class="line">    <span class="attr">credentials:</span> <span class="string">token</span> <span class="comment"># 替换为ServiceAccount生成的token</span></span><br><span class="line"><span class="attr">kubernetes_sd_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">api_server:</span> <span class="string">https://192.168.8.10:6443</span>  <span class="comment"># 替换为 Kubernetes API 服务器地址</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">    <span class="attr">tls_config:</span></span><br><span class="line">    <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">authorization:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Bearer</span></span><br><span class="line">    <span class="attr">credentials:</span> <span class="string">token</span> <span class="comment"># 替换为ServiceAccount生成的token</span></span><br><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">    <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_node_address_InternalIP</span>] <span class="comment"># 这里实际是通过服务发现查询到其他的k8s集群结点</span></span><br><span class="line">    <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">    <span class="attr">replacement:</span> <span class="string">$&#123;1&#125;:10250</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_node_name</span>]</span><br><span class="line">    <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">    <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">    <span class="attr">replacement:</span> <span class="string">/metrics/cadvisor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看配置是否成功</p>
</li>
</ol>
<p><img data-src="/images/k8s/01.png" alt="img"></p>
<h4 id="四、配置-grafana"><a href="#四、配置-grafana" class="headerlink" title="四、配置 grafana"></a>四、配置 grafana</h4><blockquote>
<p>这里配置一个简单的 cpu、内存 <code>deployment</code> 图表</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;annotations&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;builtIn&quot;:</span> <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;grafana&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;-- Grafana --&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;enable&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;hide&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;iconColor&quot;:</span> <span class="string">&quot;rgba(0, 211, 255, 1)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;Annotations &amp; Alerts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;dashboard&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;editable&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;fiscalYearStartMonth&quot;:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;graphTooltip&quot;:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;:</span> <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;links&quot;:</span> [],</span><br><span class="line">  <span class="attr">&quot;panels&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;default&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;fieldConfig&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;defaults&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;color&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;palette-classic&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;custom&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;axisBorderShow&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;axisCenteredZero&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;axisColorMode&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;axisLabel&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;axisPlacement&quot;:</span> <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;axisSoftMax&quot;:</span> <span class="number">10</span>,</span><br><span class="line">            <span class="attr">&quot;axisSoftMin&quot;:</span> <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;barAlignment&quot;:</span> <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;barWidthFactor&quot;:</span> <span class="number">0.6</span>,</span><br><span class="line">            <span class="attr">&quot;drawStyle&quot;:</span> <span class="string">&quot;line&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fillOpacity&quot;:</span> <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;gradientMode&quot;:</span> <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;hideFrom&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;legend&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">&quot;tooltip&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">&quot;viz&quot;:</span> <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;insertNulls&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;lineInterpolation&quot;:</span> <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;lineWidth&quot;:</span> <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;pointSize&quot;:</span> <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;scaleDistribution&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;linear&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;showPoints&quot;:</span> <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;spanNulls&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;stacking&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;group&quot;:</span> <span class="string">&quot;A&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;thresholdsStyle&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;mappings&quot;:</span> [],</span><br><span class="line">          <span class="attr">&quot;max&quot;:</span> <span class="number">10</span>,</span><br><span class="line">          <span class="attr">&quot;min&quot;:</span> <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;thresholds&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;absolute&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;steps&quot;:</span> [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;color&quot;:</span> <span class="string">&quot;green&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;value&quot;:</span> <span class="literal">null</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;color&quot;:</span> <span class="string">&quot;red&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;value&quot;:</span> <span class="number">80</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;unit&quot;:</span> <span class="string">&quot;percent&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;overrides&quot;:</span> [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;__systemRef&quot;:</span> <span class="string">&quot;hideSeriesFrom&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;matcher&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;byNames&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;options&quot;:</span> &#123;</span><br><span class="line">                <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;exclude&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;names&quot;:</span> [</span><br><span class="line">                  <span class="string">&quot;nginx-77c6dcdbff-rjrpk&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;prefix&quot;:</span> <span class="string">&quot;All except:&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;readOnly&quot;:</span> <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;properties&quot;:</span> [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;custom.hideFrom&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;value&quot;:</span> &#123;</span><br><span class="line">                  <span class="attr">&quot;legend&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">                  <span class="attr">&quot;tooltip&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">                  <span class="attr">&quot;viz&quot;:</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;gridPos&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;h&quot;:</span> <span class="number">8</span>,</span><br><span class="line">        <span class="attr">&quot;w&quot;:</span> <span class="number">12</span>,</span><br><span class="line">        <span class="attr">&quot;x&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;y&quot;:</span> <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;id&quot;:</span> <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;options&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;legend&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;calcs&quot;:</span> [],</span><br><span class="line">          <span class="attr">&quot;displayMode&quot;:</span> <span class="string">&quot;table&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;placement&quot;:</span> <span class="string">&quot;right&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;showLegend&quot;:</span> <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;tooltip&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;single&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sort&quot;:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;targets&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum(rate(container_cpu_usage_seconds_total&#123;namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;[5m])) by (pod)&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;__auto&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;title&quot;:</span> <span class="string">&quot;Nginx CPU Usage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;timeseries&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;default&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;description&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fieldConfig&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;defaults&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;color&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;palette-classic&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;custom&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;axisBorderShow&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;axisCenteredZero&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;axisColorMode&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;axisLabel&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;axisPlacement&quot;:</span> <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;barAlignment&quot;:</span> <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;barWidthFactor&quot;:</span> <span class="number">0.6</span>,</span><br><span class="line">            <span class="attr">&quot;drawStyle&quot;:</span> <span class="string">&quot;line&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fillOpacity&quot;:</span> <span class="number">13</span>,</span><br><span class="line">            <span class="attr">&quot;gradientMode&quot;:</span> <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;hideFrom&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;legend&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">&quot;tooltip&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">&quot;viz&quot;:</span> <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;insertNulls&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;lineInterpolation&quot;:</span> <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;lineStyle&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;fill&quot;:</span> <span class="string">&quot;solid&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;lineWidth&quot;:</span> <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;pointSize&quot;:</span> <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;scaleDistribution&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;linear&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;showPoints&quot;:</span> <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;spanNulls&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;stacking&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;group&quot;:</span> <span class="string">&quot;A&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;thresholdsStyle&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;mappings&quot;:</span> [],</span><br><span class="line">          <span class="attr">&quot;thresholds&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;absolute&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;steps&quot;:</span> [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;color&quot;:</span> <span class="string">&quot;green&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;value&quot;:</span> <span class="literal">null</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;color&quot;:</span> <span class="string">&quot;red&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;value&quot;:</span> <span class="number">80</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;unit&quot;:</span> <span class="string">&quot;MB&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;overrides&quot;:</span> []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;gridPos&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;h&quot;:</span> <span class="number">8</span>,</span><br><span class="line">        <span class="attr">&quot;w&quot;:</span> <span class="number">12</span>,</span><br><span class="line">        <span class="attr">&quot;x&quot;:</span> <span class="number">12</span>,</span><br><span class="line">        <span class="attr">&quot;y&quot;:</span> <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;id&quot;:</span> <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;options&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;legend&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;calcs&quot;:</span> [</span><br><span class="line">            <span class="string">&quot;max&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mean&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;displayMode&quot;:</span> <span class="string">&quot;table&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;placement&quot;:</span> <span class="string">&quot;right&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;showLegend&quot;:</span> <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;tooltip&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;mode&quot;:</span> <span class="string">&quot;multi&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sort&quot;:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;targets&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;exemplar&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  container_memory_rss&#123;namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - RSS&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  container_memory_usage_bytes&#123;namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hide&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - Usage&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  container_memory_working_set_bytes&#123;namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hide&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - Working Set&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  container_memory_cache&#123;namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hide&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - Cache&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;D&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  kube_pod_container_resource_requests&#123;resource=\&quot;memory\&quot;,namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hide&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - Requests&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;E&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;editorMode&quot;:</span> <span class="string">&quot;code&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;sum by (pod) (\n  kube_pod_container_resource_limits&#123;resource=\&quot;memory\&quot;,namespace=\&quot;$namespace\&quot;,container=~\&quot;$deployment\&quot;,pod=~\&quot;$pod\&quot;&#125;\n) / 1024 / 1024&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hide&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;instant&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;legendFormat&quot;:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;pod&#125;&#125;</span> - Limits&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;range&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;title&quot;:</span> <span class="string">&quot;Nginx Pods - Memory Metrics&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;timeseries&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;schemaVersion&quot;:</span> <span class="number">39</span>,</span><br><span class="line">  <span class="attr">&quot;tags&quot;:</span> [],</span><br><span class="line">  <span class="attr">&quot;templating&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;current&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;selected&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;text&quot;:</span> <span class="string">&quot;cadvisor&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;:</span> <span class="string">&quot;cadvisor&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;definition&quot;:</span> <span class="string">&quot;label_values(namespace)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hide&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;includeAll&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;:</span> <span class="string">&quot;namespace&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;multi&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;namespace&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;options&quot;:</span> [],</span><br><span class="line">        <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;qryType&quot;:</span> <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;query&quot;:</span> <span class="string">&quot;label_values(namespace)&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;PrometheusVariableQueryEditor-VariableQuery&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;refresh&quot;:</span> <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;regex&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;skipUrlSync&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;query&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;allValue&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;current&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;selected&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;text&quot;:</span> <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;definition&quot;:</span> <span class="string">&quot;label_values(&#123;namespace=\&quot;$namespace\&quot;&#125;,container)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hide&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;includeAll&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;:</span> <span class="string">&quot;deployment&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;multi&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;deployment&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;options&quot;:</span> [],</span><br><span class="line">        <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;qryType&quot;:</span> <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;query&quot;:</span> <span class="string">&quot;label_values(&#123;namespace=\&quot;$namespace\&quot;&#125;,container)&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;PrometheusVariableQueryEditor-VariableQuery&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;refresh&quot;:</span> <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;regex&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;skipUrlSync&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;query&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;current&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;selected&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;text&quot;:</span> <span class="string">&quot;All&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;:</span> <span class="string">&quot;$__all&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;datasource&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;ddz6drhemat4wf&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;definition&quot;:</span> <span class="string">&quot;label_values(&#123;namespace=\&quot;$namespace\&quot;, container=\&quot;$deployment\&quot;&#125;,pod)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hide&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;includeAll&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;:</span> <span class="string">&quot;pod&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;multi&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;pod&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;options&quot;:</span> [],</span><br><span class="line">        <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;qryType&quot;:</span> <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;query&quot;:</span> <span class="string">&quot;label_values(&#123;namespace=\&quot;$namespace\&quot;, container=\&quot;$deployment\&quot;&#125;,pod)&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;refId&quot;:</span> <span class="string">&quot;PrometheusVariableQueryEditor-VariableQuery&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;refresh&quot;:</span> <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;regex&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;skipUrlSync&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;query&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;time&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;from&quot;:</span> <span class="string">&quot;now-5m&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;to&quot;:</span> <span class="string">&quot;now&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;timepicker&quot;:</span> &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;timezone&quot;:</span> <span class="string">&quot;browser&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;:</span> <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;uid&quot;:</span> <span class="string">&quot;cdz7nqi6hjvnkf&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;:</span> <span class="number">20</span>,</span><br><span class="line">  <span class="attr">&quot;weekStart&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>容器内存</title>
    <url>/2025/02/10/k8s/rong-qi-nei-cun/posts/undefined/</url>
    <content><![CDATA[<h3 id="WorkingSet-与PageCache-监控"><a href="#WorkingSet-与PageCache-监控" class="headerlink" title="WorkingSet 与PageCache 监控"></a><a href="https://www.cnblogs.com/alisystemsoftware/p/18196395">WorkingSet 与PageCache 监控</a></h3><h3 id="K8s监控的内存指标"><a href="#K8s监控的内存指标" class="headerlink" title="K8s监控的内存指标"></a>K8s监控的内存指标</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    memoryStats = &amp;statsapi.MemoryStats&#123;</span><br><span class="line">        Time:            metav1.NewTime(cstat.Timestamp),</span><br><span class="line">        UsageBytes:      &amp;cstat.Memory.Usage,</span><br><span class="line">        WorkingSetBytes: &amp;cstat.Memory.WorkingSet,</span><br><span class="line">        RSSBytes:        &amp;cstat.Memory.RSS,</span><br><span class="line">        PageFaults:      &amp;pageFaults,</span><br><span class="line">        MajorPageFaults: &amp;majorPageFaults,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// availableBytes = memory limit (if known) - workingset</span></span><br><span class="line">    <span class="keyword">if</span> !isMemoryUnlimited(info.Spec.Memory.Limit) &#123;</span><br><span class="line">        availableBytes := info.Spec.Memory.Limit - cstat.Memory.WorkingSet</span><br><span class="line">        memoryStats.AvailableBytes = &amp;availableBytes</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">type MemoryStats struct &#123;</span><br><span class="line"><span class="comment">// Current memory usage, this includes all memory regardless of when it was</span></span><br><span class="line"><span class="comment">// accessed.</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">Usage uint64 `json:<span class="string">&quot;usage&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Maximum memory usage recorded.</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">MaxUsage uint64 `json:<span class="string">&quot;max_usage&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Number of bytes of page cache memory.</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">Cache uint64 `json:<span class="string">&quot;cache&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The amount of anonymous and swap cache memory (includes transparent</span></span><br><span class="line"><span class="comment">// hugepages).</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">RSS uint64 `json:<span class="string">&quot;rss&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The amount of swap currently used by the processes in this cgroup</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">Swap uint64 `json:<span class="string">&quot;swap&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The amount of memory used for mapped files (includes tmpfs/shmem)</span></span><br><span class="line">MappedFile uint64 `json:<span class="string">&quot;mapped_file&quot;</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The amount of working set memory, this includes recently accessed memory,</span></span><br><span class="line"><span class="comment">// dirty memory, and kernel memory. Working set is &lt;= &quot;usage&quot;.</span></span><br><span class="line"><span class="comment">// Units: Bytes.</span></span><br><span class="line">WorkingSet uint64 `json:<span class="string">&quot;working_set&quot;</span>`</span><br></pre></td></tr></table></figure>

<h4 id="OOM的判断"><a href="#OOM的判断" class="headerlink" title="OOM的判断"></a>OOM的判断</h4><blockquote>
<p>availableBytes &#x3D; memory limit (if known) - workingset</p>
</blockquote>
<p>working_set这个指标是否逼近MemoryLimit的值，可以有助于我们判断容器是否在未来发生OOM。</p>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>定义</th>
<th>特点</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>内存使用量 (Usage)</td>
<td>容器当前使用的总内存量</td>
<td>包括应用程序内存、缓存等</td>
<td>反映总体内存占用</td>
</tr>
<tr>
<td>工作集 (Working Set)</td>
<td>容器活跃使用的内存集合</td>
<td>≈ Usage - Cache</td>
<td>反映应用实际需要的内存</td>
</tr>
<tr>
<td>RSS (Resident Set Size)</td>
<td>进程实际占用的物理内存</td>
<td>不包括已换出的内存</td>
<td>反映实际物理内存使用</td>
</tr>
<tr>
<td>缓存 (Cache)</td>
<td>主要是页面缓存</td>
<td>可被回收的内存</td>
<td>提高文件I&#x2F;O性能</td>
</tr>
<tr>
<td>内存限制 (Memory Limit)</td>
<td>容器的内存使用上限</td>
<td>硬性限制</td>
<td>资源控制和OOM判定</td>
</tr>
<tr>
<td>内存请求 (Memory Request)</td>
<td>容器请求的最小内存量</td>
<td>软性限制</td>
<td>调度决策和资源分配</td>
</tr>
<tr>
<td>可分配内存 (Allocatable)</td>
<td>节点上可供Pod使用的内存</td>
<td>总内存 - 系统预留 - Kube预留</td>
<td>资源规划和调度</td>
</tr>
<tr>
<td>OOM风险指标</td>
<td>Memory Limit - Working Set</td>
<td>值越小风险越高</td>
<td>评估OOM风险</td>
</tr>
<tr>
<td>内存利用率</td>
<td>Usage &#x2F; Limit 或 Working Set &#x2F; Limit</td>
<td>百分比表示</td>
<td>评估内存使用效率</td>
</tr>
<tr>
<td>匿名内存</td>
<td>不与文件关联的内存</td>
<td>如堆和栈</td>
<td>反映核心内存使用</td>
</tr>
<tr>
<td>活跃文件内存</td>
<td>最近访问的文件缓存</td>
<td>不易被回收</td>
<td>评估热数据占用</td>
</tr>
<tr>
<td>非活跃文件内存</td>
<td>长时间未访问的文件缓存</td>
<td>易被回收</td>
<td>评估可回收内存</td>
</tr>
<tr>
<td>共享内存</td>
<td>多个进程共享的内存</td>
<td>可能在RSS中重复计算</td>
<td>评估内存共享情况</td>
</tr>
<tr>
<td>Swap使用量 (如启用)</td>
<td>使用的交换空间大小</td>
<td>通常在容器中禁用</td>
<td>性能评估（如启用）</td>
</tr>
</tbody></table>
<ul>
<li>Usage ≈ Working Set + Cache</li>
<li>Working Set ≈ RSS + 一些可能被换出的匿名页面</li>
<li>OOM风险 ∝ 1 &#x2F; (Memory Limit - Working Set)</li>
</ul>
<p>k8s底层的容器运行时，完全使用了linux内核OOMKiller的score机制，当容器的物理内存达到设置的memory limit时，score对应的权重，决定了容器被Kill的优先级。</p>
<p>强烈建议在生产环境，把 <strong>memory limit</strong> 和 <strong>memory request</strong> 设置成<strong>相同的值</strong>，其实有一个重要原因，就是两者相同时，默认的score adj是-997，被Kill的优先级相对低。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>k8s</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>loom-springboot</title>
    <url>/2025/02/19/loom/loom-springboot/posts/undefined/</url>
    <content><![CDATA[<h4 id="Spring-Boot-使用-project-loom"><a href="#Spring-Boot-使用-project-loom" class="headerlink" title="Spring Boot 使用 project loom"></a>Spring Boot 使用 project loom</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul>
<li>jdk 22.0.1-graal</li>
<li>maven 3.6.3</li>
<li>内置容器 tomcat，最大线程数量 256</li>
<li>Xms200M Xmx300M</li>
<li>压测条件: 1000线程 循环100次 Ramp-up&#x3D;10s</li>
<li>M1 max 64g</li>
<li>SpringBoot 3.3.0</li>
</ul>
<h5 id="普通线程，同步请求"><a href="#普通线程，同步请求" class="headerlink" title="普通线程，同步请求"></a>普通线程，同步请求</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>压测吞吐量253&#x2F;s，与配置最大线程 256 基本一致</li>
</ul>
<p><img data-src="/images/loom/img4.png" alt="img.png"></p>
<ul>
<li>内存、线程占用情况</li>
</ul>
<p><img data-src="/images/loom/img3.png" alt="普通线程.png"></p>
<h5 id="虚拟线程，异步servlet"><a href="#虚拟线程，异步servlet" class="headerlink" title="虚拟线程，异步servlet"></a>虚拟线程，异步servlet</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/loom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">helloLoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回异步 -&gt; springmvc会处理为异步servlet，提升吞吐量</span></span><br><span class="line">    DeferredResult&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;();</span><br><span class="line">    Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setResult(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>压测吞吐量879&#x2F;s，大概是普通线程的3~4倍</li>
</ul>
<p><img data-src="/images/loom/img6.png" alt="&#x2F;images&#x2F;loom"></p>
<ul>
<li>内存、线程占用情况，可以发现虚拟线程的内存比普通线程占用要大<br>这个很好理解，因为开启的虚拟线程多了，虚拟线程也是对象，自然占用的内存会大一些</li>
</ul>
<p><img data-src="/images/loom/img5.png" alt="img.png"></p>
<h5 id="旧版本tomcat不支持异步线程"><a href="#旧版本tomcat不支持异步线程" class="headerlink" title="旧版本tomcat不支持异步线程"></a>旧版本tomcat不支持异步线程</h5><ul>
<li>版本9.0.60</li>
<li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法是用 <code>synchronized</code><br>包裹住的，导致虚拟线程无法卸载，这个版本下即使替换了tomcat线程池为虚拟线程池，也会造成阻塞<br><img data-src="/images/loom/img.png" alt="img.png"></li>
<li>之所以在这里需要使用锁是因为对于一个socket来说，需要保证并发安全，因为这里是在业务线程池executor执行的，会有多个线程访问同一个socket，这里的锁就是锁住每个连接，防止单个连接多个请求并发(题外话: netty高明之处就在于事件监听+事件处理都是用一个eventLoop，就不存在并发问题，如果使用者使用了异步线程池，也只需要在涉及channel的操作放到eventLoop中执行大概率不会有什么并发问题)</li>
<li>如果在此版本下想要支持虚拟线程，可以使用上面的方式，将同步servlet转换为异步servlet，再使用虚拟线程包裹一层</li>
</ul>
<h5 id="新版本tomcat支持异步线程"><a href="#新版本tomcat支持异步线程" class="headerlink" title="新版本tomcat支持异步线程"></a>新版本tomcat支持异步线程</h5><ul>
<li>版本10.1.24</li>
<li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法调整为用 <code>ReentrantLock</code> 进行加锁，这样虚拟线程可以正常卸载<br><img data-src="/images/loom/img2.png" alt="img.png"></li>
<li>此版本下如何启用虚拟线程?<ol>
<li>自定义 <code>WebServerFactoryCustomizer</code> 修改tomcat执行线程池</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadExecutorWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableTomcatWebServerFactory&gt;, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(ConfigurableTomcatWebServerFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newThreadPerTaskExecutor(Thread.ofVirtual().name(<span class="string">&quot;tomcat-virtual-&quot;</span>, <span class="number">0</span>).factory());</span><br><span class="line">        factory.addProtocolHandlerCustomizers(</span><br><span class="line">                (protocolHandler) -&gt; protocolHandler.setExecutor(executorService));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用框架自带的 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code></li>
<li>测试发现二者性能相差不大，可自行选择，不过 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code> 底层使用了反射，性能可能略有损耗，更推荐第一种自定义的</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>loom</category>
      </categories>
      <tags>
        <tag>loom</tag>
        <tag>虚拟线程</tag>
        <tag>java</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>loom</title>
    <url>/2025/02/19/loom/loom/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://wiki.openjdk.org/display/loom">openjdk loom</a></li>
<li><a href="https://openjdk.org/jeps/444">虚拟线程</a></li>
<li><a href="https://openjdk.org/jeps/480">结构化并发</a></li>
<li><a href="https://inside.java/2021/05/10/networking-io-with-virtual-threads/">虚拟线程网络IO实现原理</a></li>
<li><a href="https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html">Project Loom: Java虚拟机的纤程和计算续体</a></li>
<li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html">State of Loom: part 1</a></li>
<li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part2.html">State of Loom: part 2</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/685013298">虚拟线程不推荐上生产的思考</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/686222059">Java 虚拟线程截止 2024-3-10 在 OpenJDK 还没有解决消息的问题</a></li>
<li><a href="https://openjdk.org/jeps/481">Scoped Values</a></li>
</ul>
<h3 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h3><blockquote>
<p>We say that a virtual thread is <code>pinned</code> to its carrier if it is mounted but is in a state in which it cannot be unmounted. If a virtual thread blocks while pinned, it blocks its carrier. This behavior is still correct, but it holds on to a worker thread for the duration that the virtual thread is blocked, making it unavailable for other virtual threads.</p>
</blockquote>
<ul>
<li>Java 代码调用本地代码 (JNI)</li>
<li>synchronized 块或方法</li>
</ul>
<h4 id="减少pin发生"><a href="#减少pin发生" class="headerlink" title="减少pin发生"></a>减少pin发生</h4><ul>
<li>synchronized 保护的普通 I&#x2F;O 操作，请用 <code>ReentrantLock</code> 替换监视器，（如果可以的话，使用性能更高的 <code>StampedLock</code> 效果会更好）。</li>
</ul>
<h4 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h4><ol>
<li>Synchronization<ul>
<li>synchronized最终会解决，但是JNI不会处理</li>
<li>java.util.concurrent 中部分已经调整，比如LockSupport.park &#x2F; unpark 但是还有大部分的工作</li>
</ul>
</li>
<li>I&#x2F;O<ul>
<li>java.nio.channels 和 ServerSocketChannel 和 DatagramChannel 类改造为支持虚拟线程。当它们的同步操作（如 read 和 write ）在虚拟线程上执行时，在底层仅使用非阻塞 I&#x2F;O。</li>
<li>getHostName 、 getCanonicalHostName 和 getByName 方法的 DNS 查找仍然委托给操作系统,而操作系统仅提供一个阻塞操作系统线程的 API。正在探索替代方案。</li>
<li>Http(s)URLConnection 和 TLS&#x2F;SSL 的实现已更改为依赖 j.u.c 锁并避免pin</li>
<li>文件 I&#x2F;O 存在问题。内部,JDK 对文件使用缓冲 I&#x2F;O,即使读取操作会阻塞,也始终报告可用字节数。在 Linux 上,我们计划使用 io_uring 进行异步文件 I&#x2F;O,同时我们正在使用 ForkJoinPool.ManagedBlocker 机制,通过向工作池添加更多 OS 线程来平滑阻塞文件 I&#x2F;O 操作。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>loom</category>
      </categories>
      <tags>
        <tag>loom</tag>
        <tag>虚拟线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>1-Netty Reactor启动流程</title>
    <url>/2025/02/09/netty/1.netty-reactor-qi-dong-liu-cheng/posts/undefined/</url>
    <content><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://zhuanlan.zhihu.com/p/459313682">详细图解Netty Reactor启动全流程 | 万字长文 | 多图预警</a></p>
<p><img data-src="/images/netty_01_01.png" alt="netty"></p>
<h2 id="Netty-服务端的启动流程"><a href="#Netty-服务端的启动流程" class="headerlink" title="Netty 服务端的启动流程"></a>Netty 服务端的启动流程</h2><ul>
<li>创建服务端<code>NioServerSocketChannel</code>并初始化</li>
<li>将服务端<code>NioServerSocketChannel</code>注册到<code>主Reactor线程组</code>中</li>
<li>注册成功后，开始初始化<code>NioServerSocketChannel</code>中的 pipeline，然后在 pipeline 中触发 channelRegister 事件。</li>
<li>随后由<code>NioServerSocketChannel</code>绑定端口地址。</li>
<li>绑定端口地址成功后，向<code>NioServerSocketChannel</code>对应的<code>Pipeline</code>中触发传播<code>ChannelActive事件</code>，在<code>ChannelActive事件回调</code>中向<code>Main Reactor</code>注册<code>OP_ACCEPT事件</code>，开始等待客户端连接。服务端启动完成。</li>
</ul>
<p><img data-src="/images/netty_01_02.png" alt="netty"></p>
<h2 id="1-initAndRegister"><a href="#1-initAndRegister" class="headerlink" title="1. initAndRegister"></a>1. initAndRegister</h2><p><img data-src="/images/netty_01_03.png" alt="netty"></p>
<p>开始注册</p>
<p><img data-src="/images/netty_01_04.png" alt="netty"></p>
<h2 id="2-Bind"><a href="#2-Bind" class="headerlink" title="2. Bind"></a>2. Bind</h2><p><code>bind事件</code>在 Netty 中被定义为<code>outbound事件</code>，所以它在<code>pipeline</code>中是反向传播。先从<code>TailContext</code>开始反向传播直到<code>HeadContext</code>；<code>bind</code>的核心逻辑也正是实现在<code>HeadContext</code>中</p>
<blockquote>
<p>headContext 中的绑定方法</p>
</blockquote>
<p><img data-src="/images/netty_01_05.png" alt="netty"></p>
<blockquote>
<p>NioServerSocketChannel 中的绑定动作</p>
</blockquote>
<p><img data-src="/images/netty_01_06.png" alt="netty"></p>
<blockquote>
<p>绑定完成后触发 active 操作 –&gt; HeadContext</p>
</blockquote>
<p><img data-src="/images/netty_01_07.png" alt="netty"></p>
<blockquote>
<p>io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead</p>
</blockquote>
<p><img data-src="/images/netty_01_08.png" alt="netty"></p>
<blockquote>
<p>io.netty.channel.nio.AbstractNioChannel#doBeginRead</p>
</blockquote>
<p><img data-src="/images/netty_01_09.png" alt="netty"></p>
<h2 id="细节点"><a href="#细节点" class="headerlink" title="细节点"></a>细节点</h2><h3 id="Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的"><a href="#Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的" class="headerlink" title="Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的"></a><code>Reactor线程</code>的启动是在向<code>Reactor</code>提交第一个异步任务的时候启动的</h3><blockquote>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable, boolean)</p>
</blockquote>
<p><img data-src="/images/netty_01_10.png" alt="netty"></p>
<h3 id="Reactor线程的核心工作-轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务"><a href="#Reactor线程的核心工作-轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务" class="headerlink" title="Reactor线程的核心工作 轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务"></a><code>Reactor</code>线程的核心工作 <code>轮询所有注册其上的Channel中的IO就绪事件</code>，<code>处理对应Channel上的IO事件</code>，<code>执行异步任务</code></h3><blockquote>
<p>io.netty.channel.nio.NioEventLoop#run</p>
</blockquote>
<p><img data-src="/images/netty_01_11.png" alt="netty"></p>
<h3 id="Channel-的各种事件触发顺序"><a href="#Channel-的各种事件触发顺序" class="headerlink" title="Channel 的各种事件触发顺序"></a>Channel 的各种事件触发顺序</h3><ol>
<li><p>handlerAdded</p>
<p> socket 向 jdk selector 注册后、在通知注册的 promise 完成之前（也就是 promise 回调之前）触发</p>
<p> <img data-src="/images/netty_01_12.png" alt="netty"></p>
</li>
<li><p>channelRegistered</p>
<p> 在通知 promise 完成后（也就是回调执行完成之后）会传播 Registered 事件</p>
<p> <img data-src="/images/netty_01_13.png" alt="netty"></p>
</li>
<li><p>Active </p>
<p>a. 服务端 NioServerSocketChannel 判断是否激活的标准为端口是否绑定成功。</p>
<p>b. </p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractNioMessageChannel</span></span><br><span class="line">                             <span class="keyword">implements</span> <span class="title class_">io</span>.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isOpen() &amp;&amp; javaChannel().socket().isBound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c. 客户端<code>NioSocketChannel</code>判断是否激活的标准为是否处于<code>Connected状态</code>。</p>
<p>d. </p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> javaChannel();</span><br><span class="line">    <span class="keyword">return</span> ch.isOpen() &amp;&amp; ch.isConnected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> e. 向后传播 active 事件<br> f. <code>readIfIsAutoRead</code></p>
<blockquote>
<p>如果开启了自动读（io.netty.channel.ChannelConfig#isAutoRead），则注册对应感兴趣的事件</p>
</blockquote>
<ul>
<li>server 连接注册 OP_ACCEPT 事件</li>
<li>client 连接注册 OP_READ 事件</li>
</ul>
</li>
</ol>
<h3 id="向底层-selector-注册"><a href="#向底层-selector-注册" class="headerlink" title="向底层 selector 注册"></a>向底层 selector 注册</h3><blockquote>
<p>io.netty.channel.nio.AbstractNioChannel#doRegister</p>
</blockquote>
<p><img data-src="/images/netty_01_14.png" alt="netty"></p>
<h3 id="NioServerSocketChannel-注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行"><a href="#NioServerSocketChannel-注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行" class="headerlink" title="NioServerSocketChannel 注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行"></a>NioServerSocketChannel 注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行</h3><p><img data-src="/images/netty_01_15.png" alt="netty"></p>
<h3 id="事件在pipeline中的传播"><a href="#事件在pipeline中的传播" class="headerlink" title="事件在pipeline中的传播"></a>事件在<code>pipeline</code>中的传播</h3><ul>
<li><code>inbound事件</code>从<code>HeadContext</code>开始逐个向后传播直到<code>TailContext</code></li>
<li><code>outbound事件</code>则是反向传播，从<code>TailContext</code>开始反向向前传播直到<code>HeadContext</code></li>
</ul>
<p><img data-src="/images/netty_01_16.png" alt="netty"></p>
<h3 id="服务端-Socket-和客户端-Socket-分别在何时向-seletor-注册感兴趣的事件？"><a href="#服务端-Socket-和客户端-Socket-分别在何时向-seletor-注册感兴趣的事件？" class="headerlink" title="服务端 Socket 和客户端 Socket 分别在何时向 seletor 注册感兴趣的事件？"></a>服务端 Socket 和客户端 Socket 分别在何时向 seletor 注册感兴趣的事件？</h3><ul>
<li>注册感兴趣的事件触发时机都是<code>ChannelActive</code><ul>
<li><img data-src="/images/netty_01_17.png" alt="netty"></li>
<li>对于服务端 socket 来说，bind 成功后会传递 <code>channelActive</code>事件</li>
<li>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</li>
<li><img data-src="/images/netty_01_18.png" alt="netty"></li>
<li>对于客户端 socket 来说，register 成功后会传递 <code>channelActive</code>事件</li>
<li>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</li>
<li><img data-src="/images/netty_01_19.png" alt="netty"></li>
</ul>
</li>
<li>通过 <code>HeadContext#read</code> 方法进行感兴趣事件的注册</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead</span><br></pre></td></tr></table></figure></blockquote>
<p><img data-src="/images/netty_01_20.png" alt="netty"></p>
<blockquote>
<p>io.netty.channel.nio.AbstractNioChannel#doBeginRead</p>
</blockquote>
<p><img data-src="/images/netty_01_21.png" alt="netty"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>2-Reactor线程运转架构</title>
    <url>/2025/02/10/netty/2.reactor-xian-cheng-yun-zhuan-jia-gou/posts/undefined/</url>
    <content><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/462717234">一文聊透Netty核心引擎Reactor的运转架构</a></li>
</ul>
<h2 id="Reactor-线程唤醒"><a href="#Reactor-线程唤醒" class="headerlink" title="Reactor 线程唤醒"></a>Reactor 线程唤醒</h2><blockquote>
<p>以下三个条件中只要满足任意一个条件，Reactor 线程就会被从 Selector 上唤醒</p>
</blockquote>
<ul>
<li>当 Selector 轮询到有 IO 活跃事件发生时。</li>
</ul>
<p>轮询策略如下：</p>
<ul>
<li><code>返回 -1：</code> switch 逻辑分支进入<code>SelectStrategy.SELECT分支</code>，表示此时<code>Reactor</code>中没有<code>异步任务</code>需要执行，<code>Reactor线程</code>可以安心的阻塞在<code>Selector</code>上等待<code>IO就绪事件</code>发生。</li>
<li><code>返回 0：</code> switch 逻辑分支进入<code>default分支</code>，表示此时<code>Reactor</code>中没有<code>IO就绪事件</code>但是有<code>异步任务</code>需要执行，流程通过<code>default分支</code>直接进入了处理<code>异步任务</code>的逻辑部分。</li>
<li><code>返回 &gt; 0：</code>switch 逻辑分支进入<code>default分支</code>，表示此时<code>Reactor</code>中既有<code>IO就绪事件</code>发生也有<code>异步任务</code>需要执行，流程通过<code>default分支</code>直接进入了处理<code>IO就绪事件</code>和执行<code>异步任务</code>逻辑部分</li>
</ul>
<p><img data-src="/images/netty/02_01.PNG" alt="netty"></p>
<ul>
<li>当 Reactor 线程需要执行的<code>定时任务</code>到达任务执行时间<code>deadline</code>时。</li>
</ul>
<p><img data-src="/images/netty/02_02.PNG" alt="netty"></p>
<ul>
<li>当有<code>异步任务</code>提交给 Reactor 时，Reactor 线程需要从<code>Selector</code>上被唤醒，这样才能及时的去执行<code>异步任务</code>。</li>
</ul>
<blockquote>
<p>io.netty.channel.nio.NioEventLoop#wakeup</p>
</blockquote>
<p><img data-src="/images/netty/02_03.PNG" alt="netty"></p>
<h2 id="Reactor-线程工作体系"><a href="#Reactor-线程工作体系" class="headerlink" title="Reactor 线程工作体系"></a>Reactor 线程工作体系</h2><p><img data-src="/images/netty/02_04.PNG" alt="netty"></p>
<ol>
<li>Reactor 线程在 Selector 上阻塞获取 IO 就绪事件。在这个模块中首先会去检查当前是否有异步任务需要执行，如果有异步需要执行，那么不管当前有没有 IO 就绪事件都不能阻塞在 Selector 上，随后会去非阻塞的轮询一下 Selector 上是否有 IO 就绪事件，如果有，正好可以和异步任务一起执行。优先处理 IO 就绪事件，在执行异步任务</li>
<li>如果当前没有异步任务需要执行，那么 Reactor 线程会接着查看是否有定时任务需要执行，如果有则在 Selector 上阻塞直到定时任务的到期时间 deadline，或者满足其他唤醒条件被唤醒。如果没有定时任务需要执行，Reactor 线程则会在 Selector 上一直阻塞直到满足唤醒条件。</li>
<li>当 Reactor 线程满足唤醒条件被唤醒后，首先会去判断当前是因为有 IO 就绪事件被唤醒还是因为有异步任务需要执行被唤醒或者是两者都有。随后 Reactor 线程就会去处理 IO 就绪事件和执行异步任务</li>
<li>最后 Reactor 线程返回循环起点不断的重复上述三个步骤</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="外部线程提交一个任务给-Reactor-线程，reactor-线程怎么从-select-阻塞中释放出来，执行任务？"><a href="#外部线程提交一个任务给-Reactor-线程，reactor-线程怎么从-select-阻塞中释放出来，执行任务？" class="headerlink" title="外部线程提交一个任务给 Reactor 线程，reactor 线程怎么从 select 阻塞中释放出来，执行任务？"></a>外部线程提交一个任务给 Reactor 线程，reactor 线程怎么从 select 阻塞中释放出来，执行任务？</h3><blockquote>
<p>通过外部线程执行 selector.wakeup（） 方法唤醒线程</p>
</blockquote>
<p>外部线程通过 <code>execute</code> 方法添加任务时会判断是否需要唤醒线程，如果需要则唤醒线程</p>
<blockquote>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable)</p>
</blockquote>
<p>只要不是 LazyRunnable 任务，都会唤醒线程</p>
<p><img data-src="/images/netty/02_05.png" alt="netty"></p>
<p>这里会调用到👇🏻这个方法，其中 <code>immediate</code> 是上面的第二个参数，这里是 true，<code>addTaskWakesUp</code> 表示是否只有 addTask 方法时才唤醒线程，这里默认为<code>false</code>，所以会继续执行 wake（） 方法</p>
<p><img data-src="/images/netty/02_06.png" alt="netty"></p>
<blockquote>
<p>io.netty.channel.nio.NioEventLoop#wakeup</p>
</blockquote>
<p>会调用到 NioEventLoop#wake 方法，nextWakeupNanos 是一个 AtomicLong 类型的值，默认是 AWAKE（-1）表示当前 reactor 线程是唤醒的状态，下面判断很简单，如果 reactor 线程当前不是唤醒的状态，那么调用  <code>selector.wakeup()</code> 进行唤醒</p>
<p><img data-src="/images/netty/02_07.png" alt="netty"></p>
<ol>
<li><h3 id="待执行的异步任务非常多，是否会影响到-reactor-线程的-IO-任务？"><a href="#待执行的异步任务非常多，是否会影响到-reactor-线程的-IO-任务？" class="headerlink" title="待执行的异步任务非常多，是否会影响到 reactor 线程的 IO 任务？"></a>待执行的异步任务非常多，是否会影响到 reactor 线程的 IO 任务？</h3></li>
</ol>
<blockquote>
<p>无论什么时候，当有<code>IO就绪事件</code>到来时，<code>Reactor</code>都需要保证<code>IO事件</code>被及时完整的处理完，而<code>ioRatio</code>主要限制的是执行<code>异步任务</code>所需用时，防止<code>Reactor线程</code>处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</p>
</blockquote>
<ul>
<li>当<code>ioRatio = 100</code>时，表示无需考虑执行时间的限制，当有<code>IO就绪事件</code>时（<code>strategy &gt; 0</code>）<code>Reactor线程</code>需要优先处理<code>IO就绪事件</code>，处理完<code>IO事件</code>后，执行所有的<code>异步任务</code>包括：普通任务，尾部任务，定时任务。无时间限制</li>
<li>当<code>ioRatio</code>设置的值不为<code>100</code>时，默认为<code>50</code>。需要先统计出执行<code>IO事件</code>的用时<code>ioTime</code>，根据<code>ioTime * (100 - ioRatio) / ioRatio</code>计算出，后面执行<code>异步任务</code>的限制时间。也就是说<code>Reactor线程</code>需要在这个限定的时间内，执行有限的异步任务，防止<code>Reactor线程</code>由于处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</li>
</ul>
<blockquote>
<p>默认情况下，执行<code>IO事件</code>用时和执行<code>异步任务</code>用时比例设置的是一比一。 <code>ioRatio</code>设置的越高，则<code>Reactor线程</code>执行异步任务的时间占比<code>越小</code></p>
</blockquote>
<ul>
<li>如果此时没有<code>IO事件</code>需要处理，Netty 只允许<code>Reactor线程</code>最多执行<code>64</code>个异步任务，然后就结束执行。转去继续轮训<code>IO就绪事件</code>。核心目的还是防止<code>Reactor线程</code>由于处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</li>
</ul>
<p><img data-src="/images/netty/02_08.png" alt="netty"></p>
<ul>
<li>由于系统调用<code>System.nanoTime()</code>需要一定的系统开销，所以每执行完<code>64</code>个<code>异步任务</code>的时候才会去检查一下<code>执行时间</code>是否到达了<code>deadline</code>。如果到达了执行截止时间<code>deadline</code>则退出停止执行<code>异步任务</code>。如果没有到达<code>deadline</code>则继续从普通任务队列中取出任务循环执行下</li>
</ul>
<p><img data-src="/images/netty/02_09.png" alt="netty"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>3-Netty接收网络连接</title>
    <url>/2025/02/12/netty/3.netty-jie-shou-wang-luo-lian-jie/posts/undefined/</url>
    <content><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/466019443">Netty是如何高效接收网络连接的</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/471122992">ByteBuffer动态自适应扩缩容机制</a></li>
</ul>
<h2 id="Main-Reactor-处理-OP-ACCEPT-事件"><a href="#Main-Reactor-处理-OP-ACCEPT-事件" class="headerlink" title="Main Reactor 处理 OP_ACCEPT 事件"></a>Main Reactor 处理 OP_ACCEPT 事件</h2><ul>
<li>Netty 将<code>OP_ACCEPT事件</code>处理的入口函数封装在<code>NioServerSocketChannel</code>里的底层操作类 Unsafe 的<code>read</code>方法中 –&gt; <code>AbstractNioMessageChannel</code></li>
</ul>
<blockquote>
<p>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</p>
</blockquote>
<ul>
<li>接收连接过程如下</li>
</ul>
<p><img data-src="/images/netty/03_01.PNG" alt="netty"></p>
<ul>
<li><strong><code>MaxMessageHandle#maxMessagePerRead</code></strong>： 用于控制每次 read loop 里最大可以循环读取的次数，默认为 16 次，可在启动配置类<code>ServerBootstrap</code>中通过<code>ChannelOption.MAX_MESSAGES_PER_READ</code>选项设置。</li>
<li>客户端<code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>，而服务端<code>NioServerSocketChannel</code>继承的是<code>AbstractNioMessageChannel</code></li>
</ul>
<blockquote>
<p>客户端<code>NioSocketChannel</code>主要处理的是服务端与客户端的通信，这里涉及到接收客户端发送来的数据，而<code>Sub Reactor线程</code>从<code>NioSocketChannel</code>中读取的正是网络通信数据单位为<code>Byte</code>。 服务端<code>NioServerSocketChannel</code>主要负责处理<code>OP_ACCEPT事件</code>，创建用于通信的客户端<code>NioSocketChannel</code>。这时候客户端与服务端还没开始通信，所以<code>Main Reactor线程</code>从<code>NioServerSocketChannel</code>的读取对象为<code>Message</code>。这里的<code>Message</code>指的就是底层的<code>SocketChannel</code>客户端连接。</p>
</blockquote>
<p><img data-src="/images/netty/03_02.PNG" alt="netty"></p>
<h2 id="接收网络数据总览"><a href="#接收网络数据总览" class="headerlink" title="接收网络数据总览"></a>接收网络数据总览</h2><p><img data-src="/images/netty/03_03.PNG" alt="netty"></p>
<ul>
<li>Netty 服务端对于一次 OP_READ 事件的处理，会在一个<code>do&#123;&#125;while()</code>循环 read loop 中分多次从客户端 NioSocketChannel 中读取网络数据。每次读取我们分配的 ByteBuffer 容量大小，初始容量为 2048</li>
</ul>
<h2 id="ChannelRead-与-ChannelReadComplete-事件的区别"><a href="#ChannelRead-与-ChannelReadComplete-事件的区别" class="headerlink" title="ChannelRead 与 ChannelReadComplete 事件的区别"></a>ChannelRead 与 ChannelReadComplete 事件的区别</h2><ul>
<li><code>ChanneRead事件</code>：一次循环读取一次数据，就触发一次<code>ChannelRead事件</code>。本次最多读取在 read loop 循环开始分配的 DirectByteBuffer 容量大小。这个容量会动态调整。</li>
<li><code>ChannelReadComplete事件</code>：当读取不到数据或者不满足<code>continueReading</code>的任意一个条件就会退出 read loop，这时就会触发<code>ChannelReadComplete事件</code>。表示本次<code>OP_READ事件</code>处理完毕。</li>
</ul>
<blockquote>
<p>这里需要特别注意下触发<code>ChannelReadComplete事件</code>并不代表 NioSocketChannel 中的数据已经读取完了，只能说明本次<code>OP_READ事件</code>处理完毕。因为有可能是客户端发送的数据太多，Netty 读了<code>16次</code>还没读完，那就只能等到下次<code>OP_READ事件</code>到来的时候在进行读取了。</p>
</blockquote>
<h2 id="AdaptiveRecvByteBufAllocator"><a href="#AdaptiveRecvByteBufAllocator" class="headerlink" title="AdaptiveRecvByteBufAllocator"></a>AdaptiveRecvByteBufAllocator</h2><p>AdaptiveRecvByteBufAllocator 主要的作用就是为接收数据的<code>ByteBuffer</code>进行扩容缩容，那么每次怎么扩容？扩容多少？怎么缩容？缩容多少呢？？</p>
<h3 id="容量索引表"><a href="#容量索引表" class="headerlink" title="容量索引表"></a>容量索引表</h3><blockquote>
<p>Netty 中定义了一个<code>int型</code>的数组<code>SIZE_TABLE</code>来存储每个扩容单位对应的容量大小。建立起扩缩容的容量索引表。每次扩容多少，缩容多少全部记录在这个容量索引表中</p>
</blockquote>
<ul>
<li>在 AdaptiveRecvByteBufAllocatorl 类初始化的时候会在<code>static&#123;&#125;</code>静态代码块中对扩缩容索引表<code>SIZE_TABLE</code>进行初始化</li>
<li>当索引容量小于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是从<code>16开始</code>按<code>16</code>递增</li>
</ul>
<p><img data-src="/images/netty/03_04.PNG" alt="netty"></p>
<ul>
<li>当索引容量大于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是按前一个索引容量的 2 倍递增</li>
</ul>
<p><img data-src="/images/netty/03_05.PNG" alt="netty"></p>
<h3 id="扩缩容逻辑"><a href="#扩缩容逻辑" class="headerlink" title="扩缩容逻辑"></a>扩缩容逻辑</h3><blockquote>
<p>AdaptiveRecvByteBufAllocator 类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>，缩容步长<code>INDEX_DECREMENT = 1</code></p>
</blockquote>
<p>假设当前<code>ByteBuffer</code>的容量索引为<code>33</code>，对应的容量为<code>2048</code></p>
<ul>
<li>扩容</li>
</ul>
<p>当对容量为<code>2048</code>的 ByteBuffer 进行扩容时，根据当前的容量索引<code>index = 33</code> 加上 扩容步长<code>INDEX_INCREMENT = 4</code>计算出扩容后的容量索引为<code>37</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>37</code>对应的容量就是本次 ByteBuffer 扩容后的容量<code>SIZE_TABLE[37] = 32768</code></p>
<ul>
<li>缩容</li>
</ul>
<p>同理对容量为<code>2048</code>的 ByteBuffer 进行缩容时，我们就需要用当前容量索引<code>index = 33</code> 减去 缩容步长<code>INDEX_DECREMENT = 1</code>计算出缩容后的容量索引<code>32</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>32</code>对应的容量就是本次 ByteBuffer 缩容后的容量<code>SIZE_TABLE[32] = 1024</code></p>
<ul>
<li>扩缩容时机<ul>
<li>每轮 read loop 结束之后，我们都会调用<code>allocHandle.readComplete()</code>来根据在 allocHandle 中统计的在本轮 read loop 中读取字节总大小，来决定在下一轮 read loop 中是否对 DirectByteBuffer 进行扩容或者缩容</li>
</ul>
</li>
</ul>
<p><img data-src="/images/netty/03_06.png" alt="netty"></p>
<ul>
<li><code>DEFAULT_INITIAL</code>： 表示 ByteBuffer 的初始化容量。默认为<code>2048</code>。对应的 index&#x3D;33</li>
<li><code>DEFAULT_MINIMUM</code>： 表示 ByteBuffer 最小的容量，默认为<code>64</code>，也就是无论 ByteBuffer 在怎么缩容，容量也不会低于<code>64</code>，对应的 index&#x3D;3</li>
<li><code>DEFAULT_MAXIMUM</code>： 表示 ByteBuffer 的最大容量，默认为<code>65536</code>，也就是无论 ByteBuffer 在怎么扩容，容量也不会超过<code>65536</code>，对应的 index&#x3D;38</li>
<li>如果本次<code>OP_READ事件</code>实际读取到的总字节数<code>actualReadBytes</code>在 SIZE_TABLE[index - INDEX_DECREMENT]与 SIZE_TABLE[index]之间的话，也就是如果本轮 read loop 结束之后总共读取的字节数在<code>[1024,2048]</code>之间。说明此时分配的<code>ByteBuffer</code>容量正好，不需要进行缩容也不需要进行扩容。 比如本次<code>actualReadBytes = 2000</code>，正好处在<code>1024</code>与<code>2048</code>之间。说明<code>2048</code>的容量正好</li>
<li>如果<code>actualReadBytes</code> 小于等于 SIZE_TABLE[index - INDEX_DECREMENT]，也就是如果本轮 read loop 结束之后总共读取的字节数小于等于<code>1024</code>。表示本次读取到的字节数比当前 ByteBuffer 容量的下一级容量还要小，说明当前 ByteBuffer 的容量分配的有些大了，设置缩容标识<code>decreaseNow = true</code>。当下次<code>OP_READ事件</code>继续满足缩容条件的时候，开始真正的进行缩容。缩容后的容量为 SIZE_TABLE[index - INDEX_DECREMENT]，但不能小于 SIZE_TABLE[minIndex]</li>
</ul>
<blockquote>
<p>注意需要满足两次缩容条件才会进行缩容，且缩容步长为 1，缩容比较谨慎</p>
</blockquote>
<ul>
<li>如果本次<code>OP_READ事件</code>处理总共读取的字节数<code>actualReadBytes</code> 大于等于 当前 ByteBuffer 容量（nextReceiveBufferSize）时，说明 ByteBuffer 分配的容量有点小了，需要进行扩容。扩容后的容量为 SIZE_TABLE[index + INDEX_INCREMENT]，但不能超过 SIZE_TABLE[maxIndex]。</li>
</ul>
<blockquote>
<p>满足一次扩容条件就进行扩容，并且扩容步长为 4， 扩容比较奔放</p>
</blockquote>
<h2 id="PooledByteBufAllocator"><a href="#PooledByteBufAllocator" class="headerlink" title="PooledByteBufAllocator"></a>PooledByteBufAllocator</h2><blockquote>
<p><code>AdaptiveRecvByteBufAllocator</code>类只是负责动态调整 ByteBuffer 的容量，而具体为 ByteBuffer 申请内存空间的是由<code>PooledByteBufAllocator</code>负责</p>
</blockquote>
<ul>
<li>当数据达到网卡时，网卡会通过 DMA 的方式将数据拷贝到内核空间中，这是<code>第一次拷贝</code>。当用户线程在用户空间发起系统 IO 调用时，CPU 会将内核空间的数据再次拷贝到用户空间。这是<code>第二次拷贝</code>。于此不同的是当我们在 JVM 中发起 IO 调用时，比如我们使用 JVM 堆内存读取<code>Socket接收缓冲区</code>中的数据时，会多一次内存拷贝，CPU 在<code>第二次拷贝</code>中将数据从内核空间拷贝到用户空间时，此时的用户空间站在 JVM 角度是<code>堆外内存</code>，所以还需要将堆外内存中的数据拷贝到<code>堆内内存</code>中。这就是<code>第三次内存拷贝</code>。同理当我们在 JVM 中发起 IO 调用向<code>Socket发送缓冲区</code>写入数据时，JVM 会将 IO 数据先<code>拷贝</code>到<code>堆外内存</code>，然后才能发起系统 IO 调用。</li>
<li>Netty 在进行 I&#x2F;O 操作时都是使用的堆外内存，采用堆外内存为 ByteBuffer 分配内存的好处：<ul>
<li>堆外内存直接受操作系统的管理，不会受 JVM 的管理，所以 JVM 垃圾回收对应用程序的性能影响就没有了</li>
<li>网络数据到达之后直接在<code>堆外内存</code>上接收，进程读取网络数据时直接在堆外内存中读取，所以就避免了<code>第三次内存拷贝</code></li>
</ul>
</li>
<li>由于堆外内存不受 JVM 的管理，所以就需要额外关注对内存的使用和释放，稍有不慎就会造成内存泄露，于是 Netty 就引入了内存池对<code>堆外内存</code>进行统一管理</li>
<li>PooledByteBufAllocator 类的这个前缀<code>Pooled</code>就是<code>内存池</code>的意思，这个类会使用 Netty 的内存池为 ByteBuffer 分配<code>堆外内存</code></li>
<li>io.netty.channel.DefaultChannelConfig#allocator -&gt;</li>
</ul>
<p><img data-src="/images/netty/03_07.png" alt="netty"></p>
<p><img data-src="/images/netty/03_08.png" alt="netty"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>4-Netty对象池</title>
    <url>/2025/02/12/netty/4.netty-dui-xiang-chi/posts/undefined/</url>
    <content><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/483115037">Recycler对象池的精妙设计与实现</a></li>
</ul>
<h2 id="对象池-Recycler-的使用"><a href="#对象池-Recycler-的使用" class="headerlink" title="对象池 Recycler 的使用"></a>对象池 Recycler 的使用</h2><p><img data-src="/images/netty/04_01.png" alt="netty"></p>
<blockquote>
<h4 id="对象池在-PooledDirectByteBuf-类中的使用"><a href="#对象池在-PooledDirectByteBuf-类中的使用" class="headerlink" title="对象池在 PooledDirectByteBuf 类中的使用"></a>对象池在 PooledDirectByteBuf 类中的使用</h4></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title class_">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="comment">//创建对象池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER = ObjectPool.newPool(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ObjectCreator</span>&lt;PooledDirectByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledDirectByteBuf <span class="title function_">newObject</span><span class="params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PooledDirectByteBuf</span>(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象在对象池中的回收句柄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PooledDirectByteBuf <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> maxCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//从对象池中获取对象</span></span><br><span class="line">        <span class="type">PooledDirectByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//回收对象</span></span><br><span class="line">        recyclerHandle.recycle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ................省略和对象池无关的代码..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="对象池在-Channel-写入缓冲队列中的使用"><a href="#对象池在-Channel-写入缓冲队列中的使用" class="headerlink" title="对象池在 Channel 写入缓冲队列中的使用"></a>对象池在 Channel 写入缓冲队列中的使用</h4></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class="keyword">new</span> <span class="title class_">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Entry <span class="title function_">newObject</span><span class="params">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(handle);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//recyclerHandle用于回收对象</span></span><br><span class="line">       <span class="keyword">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Entry</span><span class="params">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.handle = handle;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Recycler-总体设计"><a href="#Recycler-总体设计" class="headerlink" title="Recycler 总体设计"></a>Recycler 总体设计</h2><p><img data-src="/images/netty/04_02.png" alt="netty"></p>
<ul>
<li>从创建线程视角来看<ul>
<li>为了减少多线程从对象池获取对象时的并发操作，Recycle 使用了类似<code>TLAB</code>的分配方式；每个创建线程独立从<code>Stack</code>中分配对象</li>
<li><img data-src="/images/netty/04_03.png" alt="netty"></li>
<li>Stack 对象底层使用数组<code>DefaultHandle&lt;?&gt;[] elements</code>存储回收的池化对象</li>
</ul>
</li>
<li>从回收线程视角来看<ul>
<li><code>WeakOrderQueue</code> 表示回收线程存储待回收池化对象的地方（之所以这么设计还是为了无锁化的回收对象，避免多线程回收场景的同步竞争）</li>
</ul>
</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><blockquote>
<p>Stack 中包含一个用数组实现的栈结构，这个栈结构正是对象池中真正用于存储池化对象的地方，每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中</p>
</blockquote>
<ul>
<li>数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的 Stack 用来存储由该线程创建出来并回收到对象池中的对象。</li>
<li>WeakOrderQueue 链表，head 指针指向 WeakOrderQueue 链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue 链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中 WeakOrderQueue 链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的 WeakOrderQueue 节点中。</li>
<li>当创建线程获取对象时，只会从 Stack 结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。当 Stack 结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历 Stack 结构中的 WeakOrderQueue 链表，将当前 WeakOrderQueue 节点存放的待回收对象转移至数组栈中。如果 WeakOrderQueue 链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。</li>
</ul>
<h3 id="WeakOrderQueue"><a href="#WeakOrderQueue" class="headerlink" title="WeakOrderQueue"></a>WeakOrderQueue</h3><p><img data-src="/images/netty/04_04.png" alt="netty"></p>
<ul>
<li>WeakOrderQueue 的结构其实是一个链表结构。其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。</li>
<li>链表中的元素类型为 Link 类型，Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。</li>
<li>Link 类型中还包含了 readIndex 用来指示当前 elements 数组中的读取位置。writeIndex 用来指示 elements 数组的写入位置。elements 数组中的容量默认为<code>16</code>，也就是说一个 Link 节点最多可以存放 16 个待回收对象。当回收线程收集的待回收对象超过 16 个时，就会新创建一个 Link 节点插入到 Link 链表的尾部。</li>
<li>当需要将 WeakoOrderQueue 节点中所存放的待回收对象回收转移至其对应的 Stack 结构中的数组栈中时，创建线程会遍历当前 WeakOrderQueue 节点中的 Link 链表，然后从链表的 Head 节点开始，将 Head 节点中包裹的 Link 链表头结点中存放的待回收对象回收至创建线程对应的 Stack 中。一次最多转移一个 Link 大小的待回收对象（16 个）。</li>
<li>当 Link 节点中的待回收对象全部转移至创建线程对应的 Stack 中时，会立马将这个 Link 节点从当前 WeakOrderQueue 节点中的 Link 链表里删除，随后 Head 节点向后移动指向下一个 Link 节点。</li>
<li>head 指针始终指向第一个未被转移完毕的 Link 节点，创建线程从 head 节点处读取转移待回收对象，回收线程从 Tail 节点处插入待回收对象。这样转移操作和插入操作互不影响、没有同步的开销。</li>
</ul>
<h3 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h3><h4 id="对象池中的容量控制"><a href="#对象池中的容量控制" class="headerlink" title="对象池中的容量控制"></a>对象池中的容量控制</h4><p><img data-src="/images/netty/04_05.png" alt="netty"></p>
<ul>
<li><code>DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</code>：定义每个创建线程对应的 Stack 结构中的数组栈初始默认的最大容量。默认为 4096 个。可由 JVM 启动参数 <code>-D io.netty.recycler.maxCapacity</code> 指定。</li>
<li><code>DEFAULT_MAX_CAPACITY_PER_THREAD</code>：定义每个创建线程对应的 Stack 结构中的数组栈的最大容量。可由 JVM 启动参数 <code>-D io.netty.recycler.maxCapacityPerThread</code> 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为 4096 个。</li>
<li><code>INITIAL_CAPACITY </code>： 定义每个创建线程对应的 Stack 结构中的数组栈的初始容量。计算公式为<code>min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)</code>，默认为 256 个。当池化对象超过 256 个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。</li>
</ul>
<h4 id="回收线程可回收对象的容量控制"><a href="#回收线程可回收对象的容量控制" class="headerlink" title="回收线程可回收对象的容量控制"></a>回收线程可回收对象的容量控制</h4><ul>
<li><code>MAX_SHARED_CAPACITY_FACTOR</code> : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为 2。可通过 JVM 参数 <code>-D io.netty.recycler.maxSharedCapacityFactor</code> 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code> 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为 2048 个，最小回收容量为 LINK_CAPACITY 默认为 16。</li>
<li><code>MAX_DELAYED_QUEUES_PER_THREAD</code> : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU 核数 * 2。可通过 JVM 参数 <code>-D io.netty.recycler.maxDelayedQueuesPerThread</code> 指定。注意：这里是站在回收线程的角度。</li>
<li><code>LINK_CAPACITY </code>： 在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的 WeakOrderQueue 节点中的 Link 链表中的 Link 节点存储待回收对象的容量。默认为 16，可通过 JVM 参数 <code>-D io.netty.recycler.linkCapacity</code> 指定。</li>
</ul>
<h4 id="对象回收频率控制"><a href="#对象回收频率控制" class="headerlink" title="对象回收频率控制"></a>对象回收频率控制</h4><ul>
<li><code>RATIO</code>： 创建线程回收对象时的回收比例，默认是 8，表示只回收 1&#x2F;8 的对象。也就是产生 8 个对象回收一个对象到对象池中。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为 8，可由 JVM 启动参数 <code>-D io.netty.recycler.ratio</code> 指定。表示创建线程只回收 1 &#x2F; 8 的对象，也就是每创建 8 个对象最后只回收 1 个对象。</li>
<li><code>DELAYED_QUEUE_RATIO</code>：回收线程回收对象时的回收比例，默认也是 8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是 1&#x2F;8。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的 Stack 中。所以回收线程就需要将池化对象回收至其创建线程对应的 Stack 中的 WeakOrderQueue 链表中。并等待创建线程将 WeakOrderQueue 链表中的待回收对象转移至 Stack 中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是 8，可由 JVM 启动参数 <code>-D io.netty.recycler.delayedQueue.ratio</code> 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。</li>
</ul>
<h3 id="从对象池中获取对象"><a href="#从对象池中获取对象" class="headerlink" title="从对象池中获取对象"></a>从对象池中获取对象</h3><p><img data-src="/images/netty/04_06.png" alt="netty"></p>
<h3 id="从Stack中获取池化对象"><a href="#从Stack中获取池化对象" class="headerlink" title="从Stack中获取池化对象"></a>从Stack中获取池化对象</h3><p><img data-src="/images/netty/04_07.png" alt="netty"></p>
<h3 id="转移回收线程回收的对象到Stack中"><a href="#转移回收线程回收的对象到Stack中" class="headerlink" title="转移回收线程回收的对象到Stack中"></a>转移回收线程回收的对象到Stack中</h3><p><img data-src="/images/netty/04_08.png" alt="netty"></p>
<p><img data-src="/images/netty/04_09.png" alt="netty"></p>
<h3 id="从WeakOrderQueue中转移回收对象"><a href="#从WeakOrderQueue中转移回收对象" class="headerlink" title="从WeakOrderQueue中转移回收对象"></a>从WeakOrderQueue中转移回收对象</h3><p><img data-src="/images/netty/04_10.png" alt="netty"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty中的细节优化</title>
    <url>/2025/02/12/netty/netty-zhong-de-xi-jie-you-hua/posts/undefined/</url>
    <content><![CDATA[<h3 id="优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率"><a href="#优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率" class="headerlink" title="优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率"></a>优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率</h3><ul>
<li>优化代码 <code>io.netty.channel.nio.NioEventLoop#openSelector</code></li>
<li>原生的 jdk selector 实现是 <code>sun.nio.ch.SelectorImpl</code> 其中 IO 就绪事件存放容器是<code>Set</code></li>
</ul>
<p><img data-src="/images/netty/01.png" alt="netty"></p>
<ul>
<li><code>SelectedSelectionKeySet</code> 底层使用数组存储，减少了插入时的 hash 碰撞，遍历时又能利用 cpu 缓存提升效率</li>
</ul>
<p><img data-src="/images/netty/02.png" alt="netty"></p>
<h3 id="优化客户端-channel-选择-reactor-的效率"><a href="#优化客户端-channel-选择-reactor-的效率" class="headerlink" title="优化客户端 channel 选择 reactor 的效率"></a>优化客户端 channel 选择 reactor 的效率</h3><ul>
<li>从 reactor 数量是 2 的倍数时使用 &amp; 运算</li>
</ul>
<p><img data-src="/images/netty/03.png" alt="netty"></p>
<ul>
<li>从 reactor 数量不是 2 的倍数时使用取模运算</li>
</ul>
<p><img data-src="/images/netty/04.png" alt="netty"></p>
<h3 id="解决-JDK-epoll-空轮训-bug"><a href="#解决-JDK-epoll-空轮训-bug" class="headerlink" title="解决 JDK epoll 空轮训 bug"></a>解决 JDK epoll 空轮训 bug</h3><p>由于<code>JDK NIO Epoll的空轮询BUG</code>存在，这样会导致<code>Reactor线程</code>在没有任何事情可做的情况下被意外唤醒，导致 CPU 空转。</p>
<p>其实 Netty 也没有从根本上解决这个<code>JDK BUG</code>，而是选择巧妙的绕过这个<code>BUG</code></p>
<p><img data-src="/images/netty/05.png" alt="netty"></p>
<h3 id="对象池的设计"><a href="#对象池的设计" class="headerlink" title="对象池的设计"></a>对象池的设计</h3><ul>
<li>stack 是对象池中真正用来存储池化对象的地方；为了避免这种不必要的同步竞争，Netty 也采用了类似 TLAB 分配内存的方式，每个线程拥有一个独立 Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的 Stack 中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率</li>
</ul>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>panama</title>
    <url>/2025/02/19/panama/panama/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://openjdk.org/jeps/454">JEP 454: Foreign Function &amp; Memory API</a></li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><blockquote>
<p>通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。</p>
</blockquote>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><ul>
<li>JNI 涉及几个繁琐的人工制品：一个 Java API（ native 方法）、一个从 Java API 派生的 C 头文件和一个调用目标原生库的 C 实现。Java 开发人员必须跨多个工具链工作以保持平台相关的人工制品同步，而这在原生库快速演化时尤其繁重。</li>
<li>JNI 只能与用操作系统和 CPU 的调用约定编写的语言（通常是 C 和 C++）编写的库进行交互，这是 JVM 为其构建的。native 方法不能用于调用以使用不同约定的语言编写的函数。</li>
<li>JNI 无法协调 Java 类型系统和 C 类型系统。Java 代码使用对象表示聚合数据，但 C 代码使用结构表示聚合数据，因此任何传递给 native 方法的 Java 对象都必须由本机代码费力地解包。例如，考虑一个 Java 记录类 Person ：将一个 Person 对象传递给 native 方法，要求本机代码使用 JNI 的 C API 从该对象中提取字段（例如， firstName 和 lastName ）。因此，Java 开发人员有时会将他们的数据展平到单个对象中（例如，字节数组或直接字节缓冲区），但更多情况下，由于通过 JNI 传递 Java 对象速度很慢，他们使用 Unsafe API 分配堆外内存并将其地址作为 long 传递给 native 方法 - 这使得 Java 代码非常不安全！</li>
</ul>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>控制外内存的分配和释放</li>
<li>操控和访问结构化的外部内存</li>
<li>调用外部函数（ Linker 、 SymbolLookup 、 FunctionDescriptor 和 MethodHandle ）</li>
</ol>
<h3 id="Memory-segments-and-arenas"><a href="#Memory-segments-and-arenas" class="headerlink" title="Memory segments and arenas"></a>Memory segments and arenas</h3><ul>
<li>内存段是一个由一块连续的内存区域支持的抽象概念，该区域可以位于堆外或堆上。<ol>
<li>从非堆内存中从头分配的本机段（如同通过 malloc)</li>
<li>映射段，围绕一块映射的非堆内存（如通过 mmap ）</li>
<li>一个数组或缓冲区段，它被包装在一个与现有 Java 数组或字节缓冲区关联的堆上内存区域周围</li>
</ol>
</li>
<li>所有内存段都提供空间和时间边界，这些边界确保内存访问操作是安全的。简而言之，这些边界保证不使用未分配的内存，也不进行释放后使用。</li>
<li><code>global arena</code> 全局区域，它提供无限的生命周期：它始终保持活动状态，只有在JVM退出的时候才会被自动卸载</li>
<li><code>Auto arena</code> 自动 arena 提供了有限的生命周期：由自动 arena 分配的段可以被访问，直到 JVM 的垃圾回收器检测到该内存段不可访问，此时该段背后的内存区域将被释放</li>
<li><code>confined arena</code> 提供了一种有界限且确定性的生存期：从客户端打开区域到客户端关闭区域之间的这段时间它将一直存在。在受限区域中分配的内存段只能在关闭区域之前访问，在关闭区域时，支持该段的内存区域将被取消分配。在区域关闭后尝试访问内存段将失败并引发异常。!!只有一个线程可以访问</li>
<li><code>shared arena</code> 在共享区域中分配的内存段可以被多个线程访问，并且任何线程——无论是否访问该区域——都可以关闭该区域以释放这些段。关闭区域会原子地使这些段无效，尽管支持这些段的内存区域的释放可能不会立即发生，因为需要昂贵的同步操作来检测和取消对这些段的挂起并发访问操作</li>
</ul>
<h3 id="Zero-length-memory-segments"><a href="#Zero-length-memory-segments" class="headerlink" title="Zero-length memory segments"></a>Zero-length memory segments</h3><ul>
<li>FFM API 将外函数返回的指针表示为零长度的内存段。该段的地址是该指针的值，该段的大小为零。类似地，当客户端从内存段读取指针时，将返回一个零长度的内存段。</li>
<li>任何 Address 布局返回的MemorySegment都是 Zero-length memory segments</li>
<li>零长度段具有微不足道的空间边界，因此任何访问此类段的尝试都会失败，并带有 IndexOutOfBoundsException 。这是一个至关重要的安全特性：由于这些段与大小未知的内存区域相关联，因此涉及这些段的访问操作无法验证。实际上，零长度内存段封装了一个地址，在没有明确意图的情况下无法使用它。</li>
<li>可以使用 MemorySegment::reinterpret 方法将零长度内存段转换为特定大小的本机段。 此方法将新的空间和时间边界附加到零长度内存段，以便允许解除引用操作。 此方法返回的内存段不安全：零长度内存段可能由 10 字节长的内存区域支持，但客户端可能会高估该区域的大小并使用 MemorySegment::reinterpret 获取 100 字节长的段。 稍后，这可能会导致尝试在该区域边界之外解除引用内存，从而可能导致 JVM 崩溃或更糟的情况，导致静默内存损坏。</li>
</ul>
]]></content>
      <categories>
        <category>panama</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>panama</tag>
        <tag>ffi</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf</title>
    <url>/2025/02/19/protobuf/protobuf/posts/undefined/</url>
    <content><![CDATA[<h4 id="1-执行命令编译"><a href="#1-执行命令编译" class="headerlink" title="1. 执行命令编译"></a>1. 执行命令编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --java_out=./src/main/java ./proto3/User.proto</span><br></pre></td></tr></table></figure>

<h4 id="2-通过maven插件"><a href="#2-通过maven插件" class="headerlink" title="2. 通过maven插件"></a>2. 通过maven插件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断系统--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Protobuf Maven 插件</span></span><br><span class="line"><span class="comment">        作用：</span></span><br><span class="line"><span class="comment">             - 自动下载和使用 protoc 编译器</span></span><br><span class="line"><span class="comment">             - 编译 .proto 文件生成 Java 代码</span></span><br><span class="line"><span class="comment">             - 集成到 Maven 生命周期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- protoc 编译器配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- proto 文件源目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>$&#123;project.basedir&#125;/src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的 Java 代码输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/protobuf/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否清空输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>true<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-proto3"><a href="#3-proto3" class="headerlink" title="3. proto3"></a>3. proto3</h4><ul>
<li>所有字段都有默认值，比如string默认为空串</li>
<li>因为有默认值，所以所有的字段都是不为null的，需要判断是否为空，hasXXX()、getCount() &gt; 0 等等进行判断</li>
<li>使用 1-15 的字段号给最常用的字段  （频繁访问的字段放在前面，cpu缓存命中率更高）</li>
<li>不常用字段使用 16+ 的字段号  （不常访问的字段放在后面）</li>
<li>对于较小范围的数字，用 int32 而不是 int64</li>
<li>固定长度的数字用 fixed32&#x2F;fixed64</li>
<li>对于负数多的场景用 sint32&#x2F;sint64</li>
<li>字段更新规则！！<ol>
<li>添加新字段</li>
<li>删除字段(但保留字段号)</li>
<li>重命名字段(字段号不变)</li>
<li>添加repeated字段   reserved 2, 15, 9 to 11;       &#x2F;&#x2F; 保留字段号  reserved “foo”, “bar”;         &#x2F;&#x2F; 保留字段名</li>
</ol>
</li>
<li>字段不能做的更新规则！！<ol>
<li>改变已有字段的类型</li>
<li>复用已删除的字段号</li>
<li>改变已有字段的编号</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>protobuf</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 单元测试最佳实践</title>
    <url>/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/</url>
    <content><![CDATA[<blockquote>
<p>标题党，各位大佬手下留情<del>_</del></p>
</blockquote>
<p>单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)</p>
<blockquote>
<p>!! 笔者使用的是 2.6.6 版本</p>
</blockquote>
<p><img data-src="/images/spring/boot/01.png" alt="image.png"></p>
<blockquote>
<p>SpringBoot 常规单元测试</p>
</blockquote>
<p>常规的单元测试如下图所示，这样会将整个容器启动起来，需要加载各种各样的外部化配置，耗时时间长且容易失败；大部分场景下我们只是测试某个功能，只需加载部分组件即可</p>
<p><img data-src="/images/spring/boot/02.png" alt="image.png"></p>
<blockquote>
<p>SpringBoot 单元测试指定加载配置</p>
</blockquote>
<p>为了解决以上问题，我们可以指定配置进行加载，避免加载整个容器；如下图所示，只会加载基础的Spring容器以及IdGenerator，大大提升了单测的效率</p>
<p><code>推荐学习</code><a href="https://github.com/chanjarster/spring-test-examples">spring-test-examples</a></p>
<p><img data-src="/images/spring/boot/03.png" alt="image.png"></p>
<blockquote>
<p>SprongBoot 固定组件单元测试</p>
</blockquote>
<p>以上指定配置加载已经基本满足了我们的需求(加载部分组件)；但在日常开发中，要求每次单测都指定加载的配置本身就是个伪命题，一是因为本身开发可能对于需要加载的配置不太熟悉，二是因为这种重复的工作过于啰嗦；那么我们该怎么优化这个流程呢？</p>
<ol>
<li>要简化配置，第一步就是禁用所有自动加载的配置</li>
</ol>
<ul>
<li>仿造<code>SpringBootTest</code>的注解，构建一个元注解，禁用所有自动加载的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(EmptyTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(EmptyTypeExcludeFilter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestEmptyEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTestContextBootstrapper</span> <span class="keyword">extends</span> <span class="title class_">SpringBootTestContextBootstrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getProperties(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestEmptyEnvironment</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">        <span class="keyword">return</span> (annotation != <span class="literal">null</span>) ? annotation.properties() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTypeExcludeFilter</span> <span class="keyword">extends</span> <span class="title class_">AnnotationCustomizableTypeExcludeFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEmptyEnvironment annotation;</span><br><span class="line"></span><br><span class="line">    EmptyTypeExcludeFilter(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ComponentScan.Filter[] getFilters(<span class="keyword">final</span> FilterType type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> INCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.includeFilters();</span><br><span class="line">            <span class="keyword">case</span> EXCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.excludeFilters();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported type &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation.useDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getDefaultIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getComponentIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><strong>TestEmptyEnvironment</strong>: 禁用所有自动配置，只加载最基础的spring容器</li>
<li><strong>EmptyTestContextBootstrapper</strong>: 重写properties加载方法，将TestEmptyEnvironment注解中的properties属性加载到容器中</li>
<li><strong>EmptyTypeExcludeFilter</strong>: 容器过滤</li>
<li><strong>@OverrideAutoConfiguration(enabled &#x3D; false)</strong>: 禁用自动配置加载，如果是boot2.2.x之前的版本，此配置不会生效，可以使用 @ContextConfiguration(classes &#x3D; EmptyConfiguration.class) 替代，其中 EmptyConfiguration 表示空的配置</li>
</ul>
<ol start="2">
<li>要简化单测的流程，就需要将重复的工作声明化，即使用注解完成自动配置的大部分工作；具体需要如何处理呢，我们可以将常用单测注解进行声明化处理，编写单测时只需引入对应组件的注解即可</li>
</ol>
<ul>
<li><strong>service</strong> 仅对service进行单测，可声明以下注解，构建一个简单的spring容器即可，需要测试哪个service，直接Import加载即可；若此service中有其他注解，可进行mock处理，这里不再赘述mock的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TestService</span></span><br><span class="line"><span class="comment">// 若是boot2.2.x之后这里不再需要，因为元注解中已经增加了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// @RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;</span></span><br><span class="line"><span class="meta">        LabelService.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LabelService labelService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>redis</strong> 对redis进行单测，需要引入redis相关的自动配置，如下代码中的 RedisTestAutoConfiguration 类，不同项目使用的框架不同，自动装配也不相同，这里需要根据项目进行个性化设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        RedisTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRedis &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        LettuceAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRedis</span></span><br><span class="line"><span class="comment">// 优先级最高，可覆盖项目中的配置文件</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;</span></span><br><span class="line"><span class="meta">        &quot;redis.host=localhost:6379&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getRedisHost</span><span class="params">()</span> &#123;</span><br><span class="line">        assertThat(redisClient)</span><br><span class="line">        .isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>kafka</strong> kafka单测也和redis一样，进行个性化配置即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestKafka &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>其他组件也都是一样的做法，笔者暂时用到的组件如下<ul>
<li>feign</li>
<li>kafka</li>
<li>mongodb</li>
<li>redis</li>
<li>service</li>
<li>controller</li>
<li>mybatis</li>
</ul>
</li>
</ul>
<p>tips: 如果不知道组件需要加载哪些配置，可通过完整启动项目打印所有装配的配置，然后再筛选需要的即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderPrint</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>接口安全</title>
    <url>/2025/02/12/an-quan/jie-kou-an-quan/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/opus/917872422844104721">前后端安全性页面与接口设计</a></li>
<li><a href="https://www.bilibili.com/read/cv33868282/?opus_fallback=1">防刷机制</a></li>
</ul>
<h2 id="前后端安全性页面与接口设计"><a href="#前后端安全性页面与接口设计" class="headerlink" title="前后端安全性页面与接口设计"></a>前后端安全性页面与接口设计</h2><h3 id="接口安全密钥交换"><a href="#接口安全密钥交换" class="headerlink" title="接口安全密钥交换"></a>接口安全密钥交换</h3><blockquote>
<p>分为 web&#x2F;wap（轻客户端），android&#x2F;ios（受信任客户端） 两大类。</p>
</blockquote>
<ul>
<li>针对 web&#x2F;wap，首先通过 csrf 获取 RSA public key，然后通过 RSA public key，解密服务端对应你当前 session 的 AES Token，之后每次请求都是这个 AES Token 加密。首先 csrf 一定要内嵌在页面，不能放在 cookie，否则意义不大。这样 csrf 可以起到一定的保证页面是服务端渲染生成的效果csrf 需要加密，每次返回的不一样（将时间戳嵌入进去），但是其实对应的后台 csrf token 是同一个。公钥需要轮换：这是一个定时任务，就是后台保存的 wap&#x2F;web 密钥对，定时更新，上一个设置过期时间为 1 个月（我们前端 session 公钥过期时间最多是 2 周，无续期，保险点 1 个月）</li>
<li>针对 android&#x2F;ios，public key 针对每个版本会生成一个新的带到 app 里面服务端记录好，直接解密服务端对应你当前 session 的 AES Token，之后每次请求都是这个 AES Token 加密。由于 app 一般是受信任客户端，并且每个版本 public key 不一样，一般不用 csrf版本强制升级，也可以通过这个机制去实现。</li>
</ul>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul>
<li>https 是为了防止 wifi 劫持抓包直接能看到 http header 和 body</li>
<li>接口加密是为了防止机器人爬取，请求伪造，客户端模拟</li>
<li>android&#x2F;ios 通过 public key 基本能确定是哪个版本并且是我们信任的客户端，浏览器不能，所以加入 csrf token 在一定程度上确保一定是我们渲染的页面发的请求</li>
</ul>
<h3 id="安全-Header"><a href="#安全-Header" class="headerlink" title="安全 Header"></a>安全 Header</h3><ul>
<li>Strict-Transport-Security: max-age&#x3D;31536000; includeSubDomains; preload这个头部用于启用HTTP严格传输安全（HSTS），它告诉浏览器只能通过HTTPS来访问网站。max-age&#x3D;31536000 指定浏览器应该在接下来的31,536,000秒（1年）内记住只通过HTTPS访问站点。includeSubDomains 指令扩展了这个规则，使其也适用于当前域名的所有子域。preload 指令表示网站想要被包含在预加载的HSTS列表中，这些列表内置于浏览器中，即使是第一次请求也会强制使用HTTPS。</li>
<li>X-Content-Type-Options: nosniff这个头部是一个安全功能，用于防止浏览器尝试猜测（”嗅探”）资源的MIME类型，它强制浏览器遵守服务器提供的Content-Type头。nosniff选项可以防止一些基于MIME类型混淆的攻击，例如防止浏览器将非脚本文件解释为脚本文件。</li>
<li>X-Frame-Options: SAMEORIGIN这个头部可以防止页面被其他站点通过、、或嵌套，从而防止点击劫持攻击。SAMEORIGIN仅允许来自同一源的页面将当前页面作为、等嵌入。</li>
<li>Content-Security-Policy: 内容很长，这里省略这个拦截可能会导致某些三方埋点，图片等等显示失败，需要监控（即最后加上 report-uri &#x2F;api&#x2F;csp-report-endpoint?version&#x3D;5）这个上报的都是被拦截的，包括拦截的那些 js，css，jpg，长链接，视频资源等等这个 Header 变化很频繁，所以在 CDN 维护，随时修改。例如搜索引擎跳转你的网页，会嵌入 js 等，以及投放新的广告渠道商会嵌入其他东西等等&#x2F;api&#x2F;csp-report-endpoint 需要自己实现加入 version 参数，用于在你修改添加了新的白名单后，增加版本号，老的版本号的上报可以忽略（因为加这个 header 一般在 CDN 加，比如 Cloudflare，但是一般有很长缓存）</li>
</ul>
<h4 id="一个允许-google-和-facebook-所有资源的-Content-Security-Policy-示例"><a href="#一个允许-google-和-facebook-所有资源的-Content-Security-Policy-示例" class="headerlink" title="一个允许 google 和 facebook 所有资源的 Content-Security-Policy 示例"></a>一个允许 google 和 facebook 所有资源的 Content-Security-Policy 示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default-src &#x27;self&#x27; data: &#x27;unsafe-inline&#x27; blob: &#x27;unsafe-eval&#x27; *.google-analytics.com *.googletagmanager.com *.gstatic.com *.googleapis.com *.google.co *.google.com *.google.ad *.google.ae *.google.com.af *.google.com.ag *.google.al *.google.am *.google.co.ao *.google.com.ar *.google.as *.google.at *.google.com.au *.google.az *.google.ba *.google.com.bd *.google.be *.google.bf *.google.bg *.google.com.bh *.google.bi *.google.bj *.google.com.bn *.google.com.bo *.google.com.br *.google.bs *.google.bt *.google.co.bw *.google.by *.google.com.bz *.google.ca *.google.cd *.google.cf *.google.cg *.google.ch *.google.ci *.google.co.ck *.google.cl *.google.cm *.google.cn *.google.com.co *.google.co.cr *.google.com.cu *.google.cv *.google.com.cy *.google.cz *.google.de *.google.dj *.google.dk *.google.dm *.google.com.do *.google.dz *.google.com.ec *.google.ee *.google.com.eg *.google.es *.google.com.et *.google.fi *.google.com.fj *.google.fm *.google.fr *.google.ga *.google.ge *.google.gg *.google.com.gh *.google.com.gi *.google.gl *.google.gm *.google.gr *.google.com.gt *.google.gy *.google.com.hk *.google.hn *.google.hr *.google.ht *.google.hu *.google.co.id *.google.ie *.google.co.il *.google.im *.google.co.in *.google.iq *.google.is *.google.it *.google.je *.google.com.jm *.google.jo *.google.co.jp *.google.co.ke *.google.com.kh *.google.ki *.google.kg *.google.co.kr *.google.com.kw *.google.kz *.google.la *.google.com.lb *.google.li *.google.lk *.google.co.ls *.google.lt *.google.lu *.google.lv *.google.com.ly *.google.co.ma *.google.md *.google.me *.google.mg *.google.mk *.google.ml *.google.com.mm *.google.mn *.google.com.mt *.google.mu *.google.mv *.google.mw *.google.com.mx *.google.com.my *.google.co.mz *.google.com.na *.google.com.ng *.google.com.ni *.google.ne *.google.nl *.google.no *.google.com.np *.google.nr *.google.nu *.google.co.nz *.google.com.om *.google.com.pa *.google.com.pe *.google.com.pg *.google.com.ph *.google.com.pk *.google.pl *.google.pn *.google.com.pr *.google.ps *.google.pt *.google.com.py *.google.com.qa *.google.ro *.google.ru *.google.rw *.google.com.sa *.google.com.sb *.google.sc *.google.se *.google.com.sg *.google.sh *.google.si *.google.sk *.google.com.sl *.google.sn *.google.so *.google.sm *.google.sr *.google.st *.google.com.sv *.google.td *.google.tg *.google.co.th *.google.com.tj *.google.tl *.google.tm *.google.tn *.google.to *.google.com.tr *.google.tt *.google.com.tw *.google.co.tz *.google.com.ua *.google.co.ug *.google.co.uk *.google.com.uy *.google.co.uz *.google.com.vc *.google.co.ve *.google.co.vi *.google.com.vn *.google.vu *.google.ws *.google.rs *.google.co.za *.google.co.zm *.google.co.zw *.google.cat *.googleadservices.com facebook.net *.facebook.net facebook.com *.facebook.com; report-uri /api/csp-report-endpoint?version=2</span><br></pre></td></tr></table></figure>

<h3 id="一些反思"><a href="#一些反思" class="headerlink" title="一些反思"></a>一些反思</h3><ul>
<li>针对渲染的页面，内嵌 csrf token（注意不能放在 cookie，否则意义不大），至于服务器渲染，这个我们也是前后端分离，前端自己维护自己的 nodejs 服务器。前后端分离，但是最好还是有一个类似于中台的前端服务器前端自己维护，这样 SEO 更好做。</li>
<li>这些只是加固了安全性，但是并不能保证 100% 安全。但是复杂度已经很高了，目前够用了。</li>
<li>并且在这些机制的基础上，去做 <strong>2FA 或者 MFA 也更好做</strong>，有利于减少 2FA 对于用户的打扰。</li>
</ul>
<h2 id="防刷机制"><a href="#防刷机制" class="headerlink" title="防刷机制"></a>防刷机制</h2><h3 id="防刷子机制"><a href="#防刷子机制" class="headerlink" title="防刷子机制"></a>防刷子机制</h3><p>主要分为两种场景：</p>
<ol>
<li><strong>针对未登录或者未注册用户</strong>，对于注册，各种验证码等类似的接口进行防刷机制，同时尽量减少对于用户的打扰。</li>
<li><strong>针对已经登陆的用户</strong>：<ol>
<li>参与活动设置必要的门槛：比如最近交易量。</li>
<li>引入 MFA 之后，限制用户只能通过绑定的 MFA 的设备参与活动。</li>
</ol>
</li>
</ol>
<p><strong>针对 2 其实主要是从业务的角度考虑</strong>，MFA 机制不仅是安全性的保证，MFA 更是利于验证用户设备有效，从而可以使用设备做一些业务的限制。</p>
<p><strong>针对 1，可以使用以下的机制减少验证码对于用户的打扰</strong>：</p>
<ol>
<li>使用类似于 Google reCAPTCHA Enterprise（reCAPTCHA v3）或者国内可以用 hCAPTCHA Enterprise 服务，针对敏感接口，例如注册，短信 OTP 接口等等接入，每次请求会带上一个 Google Recaptcha Enterprise 的评分：<ol>
<li>reCAPTCHA v3 在用户浏览网站时连续地评估用户行为。这包括用户与页面的交互方式（如鼠标移动、滚动、点击等）、设备和浏览器的信息。它还可能分析用户在整个会话中的行为，包括访问多个页面的顺序和速度。</li>
<li>基于这些行为分析，reCAPTCHA v3 为每个用户请求分配一个分数，范围从 0.0 到 1.0。分数越接近 1.0 表示系统越认为该行为来自真实人类，分数越低则越可能是由自动化脚本或机器人产生。这里是一个分数分布的例子：</li>
</ol>
</li>
</ol>
<p><img data-src="/images/security/01.avif" alt="img"></p>
<ol start="2">
<li><p>你的后台根据这个分数（笔者这里是针对所有低于 0.8 的请求），请求响应是需要验证码才能继续。这里的验证码实现方案就很多很多了，笔者就不赘述了。</p>
</li>
<li><p>也就是，对于大部分用户，注册的时候，其实连验证码都不需要输入。对于评分比较低的用户才去让用户接受挑战（challenge），或者是输入验证码，或者是其他挑战方式。</p>
</li>
</ol>
<p>为何不建议使用 ip + 设备封禁或者限流（限流并不是禁止访问，而是跳转或者弹出验证码）？相较于上面的手段，对于用户的打扰比较多。同时 ip 和设备比较容易伪造（ip 可以通过 vpn，设备可以模拟等等），并且，现在的浏览器的发展趋势是 user-agent 趋于统一，暴露的信息越来越少：</p>
<p><a href="https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version?hl=zh-cn">https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version?hl=zh-cn</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>防刷</tag>
      </tags>
  </entry>
  <entry>
    <title>BitMap</title>
    <url>/2025/02/10/shu-ju-ku/bitmap/posts/undefined/</url>
    <content><![CDATA[<h3 id="Roaring-Bitmap"><a href="#Roaring-Bitmap" class="headerlink" title="Roaring Bitmap"></a>Roaring Bitmap</h3><blockquote>
<p>Roaring Bitmaps 是一种高效的压缩位图数据结构，它在保持快速操作性能的同时，显著减少了内存使用。这种数据结构特别适用于表示和操作大型稀疏数据集</p>
</blockquote>
<p>基本结构： </p>
<ul>
<li>Roaring Bitmap 将 32 位整数空间分割成 2^16 &#x3D; 65536 个块。</li>
<li>每个块负责管理 2^16 个连续的整数。</li>
</ul>
<p>数据表示方法： </p>
<ul>
<li>对于稀疏的块（包含少量元素），使用简单的整数数组。<ul>
<li>用于存储稀疏数据（少量元素）</li>
<li>直接存储 16 位整数值</li>
<li>当元素数量小于 4,096 时使用</li>
</ul>
</li>
<li>对于稠密的块（包含大量元素），使用传统的位图。<ul>
<li>用于存储稠密数据（大量元素）</li>
<li>使用传统的位图表示，即 8,192 字节（65,536 位）</li>
<li>当元素数量大于等于 4,096 时使用</li>
</ul>
</li>
<li>对于连续的长整数序列，使用范围编码。<ul>
<li>用于存储连续的整数序列</li>
<li>存储开始和结束值的对</li>
<li>在特定情况下可以更节省空间</li>
</ul>
</li>
</ul>
<p>自适应性： </p>
<ul>
<li>Roaring Bitmap 会根据数据的分布自动选择最合适的容器类型，并在需要时动态转换容器类型。</li>
<li>这种自适应性使得 Roaring 在各种数据分布下都能保持高效。</li>
</ul>
<p>索引结构:</p>
<ul>
<li>使用一个高层索引（通常是一个数组）来快速定位到特定的容器。这个索引存储 16 位的高位值和指向相应容器的指针</li>
</ul>
<p>操作效率： </p>
<ul>
<li>支持快速的交集、并集、差集等集合操作。</li>
<li>这些操作可以直接在压缩的表示上执行，无需完全解压。</li>
</ul>
<p>内存效率： </p>
<ul>
<li>相比传统位图，Roaring 通常可以显著减少内存使用。</li>
<li>特别是对于稀疏数据集，节省的空间可能高达数百倍。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>广泛应用于搜索引擎、数据库系统和大数据处理框架。</li>
<li>特别适合需要高效处理大量整数集合的应用。</li>
</ul>
]]></content>
      <categories>
        <category>BitMap</category>
      </categories>
      <tags>
        <tag>BitMap</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2025/02/09/wang-guan/spring-cloud-gateway/posts/undefined/</url>
    <content><![CDATA[<h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><ol>
<li>GATEWAY_ORIGINAL_REQUEST_URL_ATTR</li>
</ol>
<ul>
<li>记录原始的url请求</li>
<li>错误重试时可以用原始URI重试</li>
<li>可以记录完整的请求转换链路</li>
<li>故障分析时可以知道请求的来源</li>
<li>在路由重写时需要更新此属性</li>
</ul>
<ol start="2">
<li>GATEWAY_REQUEST_URL_ATTR</li>
</ol>
<ul>
<li>存储请求将要转发的目标URL</li>
<li>后续的过滤器和路由可以通过这个属性知道请求要被转发到哪里</li>
<li>在路由重写时需要更新此属性</li>
</ul>
<ol start="3">
<li>PRESERVE_HOST_HEADER_ATTRIBUTE</li>
</ol>
<ul>
<li>控制是否保留原始请求的 Host 头</li>
<li>true: 转发请求时会保留客户端的原始 Host header</li>
<li>false: 会使用目标服务的 Host</li>
<li>使用场景：假设自定义的过滤器修改了host属性，如果没有开启此配置，那么后续的处理可能影响此属性，这时候需要开启此配置</li>
</ul>
<h2 id="重要过滤器"><a href="#重要过滤器" class="headerlink" title="重要过滤器"></a>重要过滤器</h2><ol>
<li><p>RetryGatewayFilterFactory</p>
<blockquote>
<p>重试过滤器</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- name: Retry #重试策略:目前只对提供者下线导致的连接异常重试，需持续观察异常情况</span><br><span class="line">  args: </span><br><span class="line">    retries: <span class="number">1</span></span><br><span class="line">    series: #不对http状态来判断是否进行重试</span><br><span class="line">    exceptions: io.netty.channel.AbstractChannel$AnnotatedConnectException</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>网关</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>spring cloud gateway</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/2025/02/09/wang-luo/socket/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://zhuanlan.zhihu.com/p/455352339">聊聊Netty那些事儿之从内核角度看IO模型</a></li>
</ul>
<h3 id="Socket-数据接收到-Epoll-处理流程"><a href="#Socket-数据接收到-Epoll-处理流程" class="headerlink" title="Socket 数据接收到 Epoll 处理流程"></a>Socket 数据接收到 Epoll 处理流程</h3><pre>
<code class="mermaid">

sequenceDiagram
    participant S as Socket
    participant WQ as Wait Queue
    participant CB as Callback (ep_poll_callback)
    participant EP as eppoll_entry
    participant EI as epitem
    participant EPL as eventpoll

    S-&gt;&gt;S: 接收数据
    S-&gt;&gt;WQ: 触发等待队列
    WQ-&gt;&gt;CB: 调用回调函数
    CB-&gt;&gt;EP: container_of 找到 eppoll_entry
    EP-&gt;&gt;EI: 访问 base 指针找到 epitem
    EI-&gt;&gt;EPL: 将 epitem 加入活跃队列
</code>
</pre>


<ol>
<li><p>数据到达和初始处理： </p>
<ul>
<li>网卡接收数据，通过 DMA 将数据放入 Ring Buffer。</li>
<li>触发软中断，内核将数据包（sk_buff）放入 socket 的接收队列。</li>
</ul>
</li>
<li><p>Socket 唤醒等待队列： </p>
<ul>
<li>Socket 检测到有新数据，开始唤醒其等待队列（wait_queue）中的等待者。</li>
<li>获取其中一个 wait_queue_entry_t，这里不获取全部一是避免惊群效应，二是 epoll 场景下一般也只会有一个 wait_queue_entry_t</li>
</ul>
</li>
<li><p>回调函数触发： </p>
<ul>
<li>对于 epoll 添加的等待项，其 wait_queue_entry_t 的回调函数是 ep_poll_callback。</li>
<li>内核调用这个回调函数，传入 wait_queue_entry_t 指针作为参数。</li>
</ul>
</li>
<li><p>找到 eppoll_entry： </p>
<ul>
<li>在 ep_poll_callback 函数中，使用 container_of 宏。</li>
<li>通过 wait_queue_entry_t 指针，找到包含它的 eppoll_entry 结构。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span> =</span> container_of(wait, <span class="keyword">struct</span> eppoll_entry, wait);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 eppoll_entry 到 epitem： </p>
<ul>
<li>eppoll_entry 结构中有一个 base 指针，直接指向关联的 epitem。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> pwq-&gt;base;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取 eventpoll 结构： </p>
<ul>
<li>epitem 结构中包含指向其关联的 eventpoll 结构的指针。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 epitem 加入活跃队列： </p>
<ul>
<li>检查 epitem 是否已经在活跃队列中。</li>
<li>如果不在，则将其添加到 eventpoll 的活跃队列（rdllist）中。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒等待的进程： </p>
<ul>
<li>如果有进程正在等待 epoll 事件（通过 epoll_wait），唤醒它。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 连接</title>
    <url>/2025/02/09/wang-luo/tcp-lian-jie/posts/undefined/</url>
    <content><![CDATA[<h3 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h3><p><img data-src="/images/tcp_01_01.png" alt="img"></p>
<h3 id="TCP-连接的分组交换"><a href="#TCP-连接的分组交换" class="headerlink" title="TCP 连接的分组交换"></a>TCP 连接的分组交换</h3><p><img data-src="/images/tcp_01_02.png" alt="img"></p>
<ul>
<li>MSS（Maximum Segment Size）: 指定了 TCP 数据包中数据部分的最大长度<ul>
<li>一般约定最小是 536，因为 IPv4 规范中建议的最小 MTU 是 576，减去 20 字节的标准 IPv4 头的长度，再减去 20 字节的标准 TCP 头的长度，得到 536 字节</li>
<li>一般约定最大是 1460，因为 IPv4 规范中建议的最大 MTU 是 1500</li>
</ul>
</li>
<li>MSS 以双方约定的最小值为准</li>
<li>请求 ACK 是服务端对客户端发送过来的数据包的响应</li>
<li>应答 ACK 是客户端对服务端发送过来的数据包的响应</li>
<li>TIME_WAIT 状态<ul>
<li>主动关闭的那端经历了这个状态</li>
<li>此状态的持续时间最长是 2MSL，MSL 在 RFC 1122 的建议值是 2 分钟，在 Berkeley 修改为 30s，意味着 TIME_WAIT 状态的持续时间在 1 分钟到 4 分钟之间<ul>
<li>MSL 是任何 IP 数据报能存活的最长时间，因为每个数据报都有跳限（hop limit），最大是 255 跳</li>
</ul>
</li>
<li>此状态存在的理由<ul>
<li>可靠的实现 TCP 全双工连接的终止</li>
<li>被动终止的一方会发送最终的 FIN，因此此端必须维护状态信息，以允许此端重新发送最终的 ACK。如果此端不维护状态信息了，那么会响应一个 <strong>RST</strong>，会被对端解释为一个错误</li>
<li>允许老的重复分节在网络中消逝</li>
<li>假设某个连接关闭了，然后在相同的客户端、服务器之间建立的一个新的连接，这个连接的四元组与之前关闭的连接完全一致，后一个连接称为前一个连接的化身。TCP 必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一个连接的某个新的化身。为了做到这一点，TCP 将不给处于 TIME_WAIT 状态的连接发起新的化身。又因为 TIME_WAIT 最长存活时间为 2MSL，此时间足够旧连接的数据包消逝了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Listen"><a href="#Listen" class="headerlink" title="Listen"></a>Listen</h3><blockquote>
<p>最主要的工作就是<code>申请和初始化</code>接收队列，包括<code>全连接队列以及半连接队列</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd、backlog</span></span><br><span class="line">listen(fd, <span class="number">128</span>)</span><br></pre></td></tr></table></figure>

<h4 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h4><blockquote>
<p>全连接队列是一个链表，内核中使用链表的 head、tail，方便应用层直接根据头尾指针查找接入的连接</p>
</blockquote>
<h5 id="全连接队列的长度"><a href="#全连接队列的长度" class="headerlink" title="全连接队列的长度"></a>全连接队列的长度</h5><ul>
<li>最大长度是 listen 传入的 backlog 和 net.core.somaxconn 之间较小的值。如果需要加大长度，需要调整这两个值。</li>
<li>使用 <code>cat /proc/sys/net/core/somaxconn</code> 命令查看</li>
<li>查看某个进程的全连接队列的长度，通过使用命令 **<code>ss -nlt</code>**进行查看，其中 <strong>Send-Q</strong> 表示全连接队列长度</li>
</ul>
<p><img data-src="/images/tcp_01_03.png" alt="img"></p>
<h5 id="判断全连接队列是否溢出"><a href="#判断全连接队列是否溢出" class="headerlink" title="判断全连接队列是否溢出"></a>判断全连接队列是否溢出</h5><p><strong><code>watch &#39;netstat -s | grep overflowed&#39;</code></strong></p>
<p>如果上述命令结果显示 <strong>xx times the listen queue of a socket overflowed</strong> 则说明有全连接队列溢出了</p>
<h5 id="半连接队列的长度"><a href="#半连接队列的长度" class="headerlink" title="半连接队列的长度"></a>半连接队列的长度</h5><ul>
<li>半连接队列的长度是 <em><strong>min（backlog，somaxconn，tcp_max_syn_backlog） + 1</strong></em> 再向上去整到 <strong>2</strong> 的 <em><strong>N</strong></em> 次幂，但最小不能小于 <strong>16</strong></li>
<li><code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code> 命令查看 tcp_max_syn_backlog</li>
<li>假设某内核参数 net.core.somaxconn&#x3D;128，net.ipv4.tcp_max_syn_backlog&#x3D;8192，用户 backlog&#x3D;5，经过以下步骤计算得出为 16<ul>
<li>min(backlog, somaxconn) &#x3D; min(5, 128) &#x3D; 5</li>
<li>min(5, tcp_max_syn_backlog) &#x3D; min(5, 8192) &#x3D; 5</li>
<li>max（5， 8） &#x3D; 8  这一步是内核为了避免传入一个太小的值导致无法接收连接，所以必须要&gt;&#x3D;8</li>
<li>roundup_pow_of_two(8 + 1) &#x3D; 16</li>
</ul>
</li>
<li>假设某内核参数 net.core.somaxconn&#x3D;128，net.ipv4.tcp_max_syn_backlog&#x3D;8192，用户 backlog&#x3D;512，经过以下步骤计算得出为 256<ul>
<li>min(backlog, somaxconn) &#x3D; min(512, 128) &#x3D; 128</li>
<li>min(128, tcp_max_syn_backlog) &#x3D; min(128, 8192) &#x3D; 128</li>
<li>max(128, 8) &#x3D; 128  </li>
<li>roundup_pow_of_two(128 + 1) &#x3D; 256</li>
</ul>
</li>
</ul>
<h5 id="判断半连接队列是否溢出？"><a href="#判断半连接队列是否溢出？" class="headerlink" title="判断半连接队列是否溢出？"></a>判断半连接队列是否溢出？</h5><ol>
<li>计算办连接队列的长度</li>
<li>查看当前SYN_RECV状态的连接数量</li>
</ol>
<p><strong><code>netstat -antp | grep SYN_RECV | wc -l</code></strong></p>
<p>其实只需要保证 <strong><code>tcp_syncookies</code></strong> 这个内核参数是 <strong>1</strong> 就不会有半连接队列溢出的问题，👍🏻推荐开启此参数！！且开启此参数可以抵御 SYN flood 攻击</p>
<p><strong><code>cat /proc/sys/net/ipv4/tcp_syncookies</code></strong> 通过此命令查看对应参数</p>
<p><strong><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</code></strong> 此命令进行修改</p>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>客户端在执行 connect 函数的时候，把本地 socket 状态设置成了**<code>TCP_SYN_SENT</code>**，选了一个可用端口，接着发出 SYN 握手请求并启动重传定时器</p>
<h4 id="选择可用端口"><a href="#选择可用端口" class="headerlink" title="选择可用端口"></a>选择可用端口</h4><ol>
<li>如果调用过 bind，那么以 bind 定义的端口为准，否则需要按照以下规则寻找可用的端口</li>
<li>可用的端口范围是根据内核参数 <strong><code>net.ipv4.ip_local_port_range</code></strong>，此参数的范围就是能选择的端口范围，可以使用命令 **<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>**进行查看，下图表示能使用的范围是 32768-60999。注意这里查找端口是循环的，如果需要很多轮才查找到可用的端口，会导致 connect 系统调用的 cpu 升高<ul>
<li><img data-src="/images/tcp_01_04.png" alt="img"></li>
</ul>
</li>
<li>判断选择的端口是否在保留端口中，如果是则不能使用此端口。内核参数**<code>net.ipv4.ip_local_reserved_ports</code>** 表示保留端口，如果希望某些端口不被内核使用，将他们写到这个参数里面就可以。<strong><code>cat /proc/sys/net/ipv4/ip_local_reserved_ports</code></strong></li>
<li>判断选择的端口是否已经使用过了，内核会维护一个使用过的端口的 hash 表，如果在 hash 表中没有找到，证明此端口是可用的，后面会在此 hash 表中记录端口已经被使用</li>
<li>如果上面还是没有找到合适的端口，就会出现 <strong>Cannot assign requested address</strong> 这个错误</li>
</ol>
<h4 id="端口被使用过怎么办？"><a href="#端口被使用过怎么办？" class="headerlink" title="端口被使用过怎么办？"></a>端口被使用过怎么办？</h4><blockquote>
<p>👆🏻选择可用端口的第四步判断端口是否已经使用过了，不是简单的判断端口是否使用过了，而是如果端口被使用过了，且<strong>四元组完全一致</strong>时才无法使用此端口，如果四元组有一个不一致，那么这个端口是可以使用的。</p>
</blockquote>
<h4 id="发起-sync-请求"><a href="#发起-sync-请求" class="headerlink" title="发起 sync 请求"></a>发起 sync 请求</h4><ol>
<li>申请一个 skb，并将其设置为<code>SYN</code>包</li>
<li>添加到发送队列 <code>sk_write_queue</code> </li>
<li>调用<code>tcp_transmit_skb</code>将该包发出</li>
<li>启动一个重传定时器，超时会重发。首次超时时间是在<code>TCP_TIMEOUT_INIT</code>宏中定义的</li>
</ol>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img data-src="/images/tcp_01_05.png" alt="img"></p>
<ol>
<li>第一次握手服务端只是创建了**<code>request sock</code>**，并加入到半连接队列中，并没有创建 socket，实际创建socket是在三次握手完成时。</li>
<li>TCP 连接建立的网络耗时大约需要三次传输，再加上少许的双方 cpu 开销，总共大约比 <strong>1.5 倍 RTT</strong> 大一点点。不过从客户端角度来看，只要 ACK 包发出了，内核就认为连接建立成功可以开始发送数据了，所以如果在客户端进行打点统计 TCP 连接建立耗时只需要两次传输耗时——即一个 RTT 多一点的时间（服务端也是同理，从 SYN 包接收到开始算起，到 ACK 包接收完毕）</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核发送网络包</title>
    <url>/2025/02/09/wang-luo/linux-nei-he-fa-song-wang-luo-bao/posts/undefined/</url>
    <content><![CDATA[<h3 id="网络发送过程汇总"><a href="#网络发送过程汇总" class="headerlink" title="网络发送过程汇总"></a>网络发送过程汇总</h3><p><img data-src="/images/socket_02_10.png" alt="img"></p>
<ul>
<li>上图中网络设备子系统在发送网络包的时候，是通过while循环不断地从队列中取出skb并进行发送。这时候其实都是占用的用户进程的系统态时间(sy)，只有当<code>quota</code> 用尽或者其他进程需要cpu时才触发软中断进行发送。</li>
<li>网络设备子系统的队列和网卡驱动的 Ring Buffer 实际上是两个不同的概念<ul>
<li>网络设备子系统的队列是在内核网络栈中的软件队列，当数据包（skb）准备发送时，它首先被放入这个软件队列，这个队列主要用于流量控制、QoS（服务质量）管理等目的</li>
<li>网卡驱动的 Ring Buffer是一个硬件级别的队列，Ring Buffer 存储的不是完整的 skb，而是指向内存中数据包的描述符。</li>
<li>Ring Buffer 包含两个主要的数组，两个数组相同index下对应存储了同一个skb，只不过内核需要的是skb，网卡需要具体的物理地址，通过此设计当网卡发送完毕后，内核通过同一个index能定位到skb从而进行清理等工作。<ol>
<li>描述符数组（Descriptor Ring）主要是网卡使用</li>
<li>缓冲区信息数组（Buffer Info Array）主要是内核使用</li>
</ol>
</li>
</ul>
</li>
<li>在监控内核发送数据消耗的cpu时，应该将sy、si都考虑进来<ul>
<li>网络包发送过程中，用户进程(在内核态)完成了绝大部分的工作，甚至连调用驱动的工作都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。</li>
<li>只有一少部分情况才会触发软中断（NET_TX类型），由软中断ksoftirqd线程来发送。</li>
</ul>
</li>
<li>在服务器上查看&#x2F;proc&#x2F;softirqs，为什么NET_RX比NET_TX大的多的多？<ul>
<li>当数据发送完毕后，通过硬中断的方式来通知驱动发送完成，但是硬中断无论是数据接收，还是发送完毕，触发的软中断都是NET_RX_SOFTIRQ。</li>
<li>对于读来说，都是需要经过NET_RX软中断的，都走ksoftirqd内核线程，而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才发出NET_TX，让软中断上。</li>
</ul>
</li>
</ul>
<h3 id="发送网络数据的时候都涉及哪些内存拷贝"><a href="#发送网络数据的时候都涉及哪些内存拷贝" class="headerlink" title="发送网络数据的时候都涉及哪些内存拷贝?"></a>发送网络数据的时候都涉及哪些内存拷贝?</h3><blockquote>
<p>指待发送数据的内存拷贝</p>
</blockquote>
<ol>
<li>第一次拷贝操作是在内核申请完skb之后，这时候会将用户传递进来的buffer里的数据内容都拷贝到skb。如果要发送的数据量比较大，这个拷贝操作开销不小。</li>
<li>第二次拷贝操作是从传输层进入网络层的时候，每一个skb都会被克隆出来一个新的副本。目的是保留原始的skb，当网络发现对方没有返回ack的时候，还可以重新发送，以实现TCP中要求的可靠传输，不过这次只是浅拷贝，只拷贝skb描述符本身，所指向的数据还是复用的。</li>
<li>第三次拷贝不是必须的，只有当IP层发现skb大于MTU时才需要进行。此时会再申请额外的skb，并讲究原来的skb拷贝为多个小的skb。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核接收网络包</title>
    <url>/2025/02/09/wang-luo/linux-nei-he-jie-shou-wang-luo-bao/posts/undefined/</url>
    <content><![CDATA[<h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><h4 id="RingBuffer到底是什么"><a href="#RingBuffer到底是什么" class="headerlink" title="RingBuffer到底是什么?"></a>RingBuffer到底是什么?</h4><blockquote>
<p>是内存中的一块特殊区域，环形队列是笼统的说法，实际上包括<code>igb_rx_buffer</code> 环形队列数组、<code>e1000_adv_rx_desc</code> 环形队列数组及众多的skb</p>
</blockquote>
<p><img data-src="/images/socket_02_01.png" alt="img"></p>
<p>网卡在收到数据的时候以<code>DMA</code> 方式将包写到RingBuffer中。软中断收包的时候来这里将skb取走，并申请新的skb重新挂上去。</p>
<p>RingBuffer内存是预先分配的还是动态分配的？</p>
<p>指针数组是预先分配好的，而skb虽然也会预先分配好，但是在后面的收包过程中会不断的动态地分配申请</p>
<h4 id="RingBuffer为什么会丢包？"><a href="#RingBuffer为什么会丢包？" class="headerlink" title="RingBuffer为什么会丢包？"></a>RingBuffer为什么会丢包？</h4><ul>
<li>RingBuffer是有大小和长度限制的</li>
<li>使用 <code>ethtool -g eth0</code> 命令查看长度，Pre-set maximums 指的是最大值，Current hardware settings 表示当前设置，下图表示最大允许1024，目前设置为1024</li>
</ul>
<p><img data-src="/images/socket_02_02.png" alt="img"></p>
<ul>
<li>查看是否有溢出情况发生  <code>ethtool -S eth0</code>，如果有溢出情况发生(ifconfig中体现为overruns指标增长)，表示有包因为RingBuffer装不下而被丢弃了，解决思路有两种<ul>
<li>加大RingBuffer长度 <code>ethtool -G eth0 rx 4096 tx 4096</code> ，此种方式只是临时解决，治标不治本</li>
<li>开启多队列提升网络性能，打散队列的亲核性</li>
<li>现在主流网卡基本上都支持多队列，通过<code>ethtool -l eth0</code> 进行查看，下图表示当前网卡支持的最大队列数是2，当前开启的也是2，通过sysfs也可以看到真正生效的队列数量。</li>
<li><img data-src="/images/socket_02_03.png" alt="img"></li>
<li><img data-src="/images/socket_02_04.png" alt="img"></li>
<li>加大队列数量，可以使用 <code>ethtool -L eth0 combined 32</code> </li>
<li>如果发现某个cpu核心si特别高，可以考虑调整队列亲和的cpu核心<ul>
<li><code>cat /proc/interrupts</code>查看队列的硬件硬中断，下图显示输入队列0的中断号是25，队列1的中断号是27，通过这个中断号对应的<code>smp_affinity</code>可以查看到亲和的cpu核是哪个。下图显示的2在二进制中代表第二位是1，所以表示第2个cpu核心——CPU2</li>
<li><img data-src="/images/socket_02_05.png" alt="img"></li>
<li><img data-src="/images/socket_02_06.png" alt="img"></li>
<li>每个队列都会有独立的、不同的中断号。所以不同的队列在将数据收取到自己的RingBuffer后，可以分别向不同的CPU发起硬中断通知。而在硬中断的处理中，发起软中断是基于当前核心的，这意味着<strong>哪个核响应的硬中断，那么该硬中断发起的软中断任务就必然由这个核来处理</strong>。</li>
<li>通过设置每个队列中断号上的<code>smp_affinity</code>，将各个队列的硬中断打散到不同的cpu上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络相关的硬中断、软中断都是什么"><a href="#网络相关的硬中断、软中断都是什么" class="headerlink" title="网络相关的硬中断、软中断都是什么?"></a>网络相关的硬中断、软中断都是什么?</h3><p> 在网卡将数据放到<code>RingBuffer</code> 之后，接着就发起<code>硬中断</code>，通知cpu进行处理。不过在硬中断的上下文里做的工作很少，将传过来的<code>poll_list</code> 添加到每个cpu变量<code>softnet_data</code> 的 <code>poll_list</code> 里面，接着触发<code>软中断</code> <code>NET_RX_SOFTIRQ</code>。在软中断中对softnet_data的设备列表poll_list进行遍历，执行网卡驱动提供的poll来收取网络包。处理完成后会送到协议栈的ip_rcv、udp_rcv、tcp_rcv_v4等函数中</p>
<p>poll_list 是个双向链表，存储待处理NAPI实例的链表。</p>
<p>一个网卡驱动程序通常会注册一个NAPI结构(struct napi_struct)，这个结构基本约等于一个接收队列，目的是为了减少硬中断的次数。在高并发网络中，频繁的接收到网络包导致频繁触发硬中断，浪费了CPU性能，通过NAPI一个队列中接收到网络包后将此队列信息传递给软中断，软中断处理程序在处理的时候先停止触发硬中断，专注接收包的处理，处理完成后再打开硬中断触发，大大减少了硬中断的触发。</p>
<h3 id="ksoftirqd内核线程是用来干嘛的"><a href="#ksoftirqd内核线程是用来干嘛的" class="headerlink" title="ksoftirqd内核线程是用来干嘛的?"></a>ksoftirqd内核线程是用来干嘛的?</h3><ul>
<li>机器上有几核，内核就会创建几个ksoftirqd线程出来</li>
<li>内核线程ksoftirqd包含了所有的软中断处理逻辑，软中断信息可以通过 <code>cat /proc/softirqs</code> 命令进行查看</li>
</ul>
<p><img data-src="/images/socket_02_07.png" alt="img"></p>
<h3 id="tcpdump是如何工作的？"><a href="#tcpdump是如何工作的？" class="headerlink" title="tcpdump是如何工作的？"></a>tcpdump是如何工作的？</h3><blockquote>
<p>tcpdump工作在设备层，是通过虚拟协议的方式工作的。通过调用packet_create将抓包函数以协议的形式挂到ptype_all上。这个函数会将包送到协议栈函数(ip_rcv、arp_rcv)之前，将包先送到ptype_all抓包点。</p>
</blockquote>
<ul>
<li>iptable&#x2F;netfilter 主要是在IP、ARP等层实现的。如果配置过于复杂的规则，则会消耗过多的cpu，加大网络延迟</li>
<li>tcpdump工作在设备层，将包送到ip层以前就能处理，而netfilter工作在IP、ARP等层，从下图来看，netfilter工作在tcpdump之后，所以iptable封禁规则不影响tcpdump抓包；但是发包过程恰恰相反，发包的时候netfilter先进行工作，在协议层就被过滤掉了，所以tcpdump什么都看不到。</li>
</ul>
<p><img data-src="/images/socket_02_08.png" alt="img"></p>
<h3 id="网络接收过程中的CPU开销如何查看？"><a href="#网络接收过程中的CPU开销如何查看？" class="headerlink" title="网络接收过程中的CPU开销如何查看？"></a>网络接收过程中的CPU开销如何查看？</h3><blockquote>
<p>在网络包的接收过程中，主要工作集中在硬中断和软中断上，二者的消耗可以通过top命令进行查看</p>
</blockquote>
<ul>
<li>输入top命令后，再输入1即可查看。其中hi是CPU处理硬中断的开销，si是处理软中断的开销，都是以百分比的形式展现的。</li>
</ul>
<p><img data-src="/images/socket_02_09.png" alt="img"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>抓包相关</title>
    <url>/2025/02/09/wang-luo/zhua-bao-xiang-guan/posts/undefined/</url>
    <content><![CDATA[<ul>
<li>查看路由表信息<ul>
<li>可以显示数据包的路由规则，告诉我们去往不同目标IP时会使用哪个网卡，方便指定网卡抓包</li>
<li><code>netstat -nr</code> 所有系统均可使用，n表示以数字形式显示地址和端口，r表示route</li>
<li><code>ip route</code> linux下使用，替代 netstat -r</li>
<li><code>ss</code>linux下使用，替代 netstat</li>
</ul>
</li>
<li>确认号(ack)计算规则<ul>
<li>普通数据包：ack &#x3D; 对方seq + len</li>
<li>SYN&#x2F;FIN包：ack &#x3D; 对方seq + len + 1</li>
<li>“我已经收到到这个位置的数据了”  “你下次就从这个位置继续发”</li>
</ul>
</li>
<li>seq <ul>
<li>不是包的唯一标识，而是数据流的位置标记</li>
<li>表示”我之后的数据会从这个位置开始发”</li>
<li>下一个包的seq等于对端确认的ack，seq、ack本质上都是流的序号，ack表示对端确认到了这个位置，自然我端需要从此为止发送数据</li>
</ul>
</li>
<li>某些场景下挥手时 FIN+ACK可能合并为一个包<ul>
<li>延迟确认的场景下，FIN+ACK可能合并为一个包</li>
</ul>
</li>
<li>LSO<ul>
<li>传输层不负责拆包处理，而是将数据直接传递给网卡，交给网卡负责分段</li>
<li>传统网络是应用层把数据交给TCP层，TCP层根据MSS大小进行分段（cpu负责）</li>
<li>启用LSO之后，TCP层直接把数据块传给网卡， 让网卡负责分段工作</li>
<li>优点在于节省了cpu资源，缺点在数据发送方抓包的时候可能看到一个分段前，超过MSS的大包</li>
</ul>
</li>
<li>数据包分段<ul>
<li>传输层分段(TCP分段)<ul>
<li>tcp会根据mss进行分段，一般mss的长度是MTU-40，同时会将IP层的flags打上DF标记避免ip分片</li>
<li>tcp层分段的好处是支持超时重传和快速重传等机制保证可靠性</li>
<li>有时候TCP头不止20字节，所以会侵占一些MSS的空间，比如用作 TCP Options，这样传输层真正用来承载的字节数 &#x3D; MTU(1500) - 20(ip header) - 20(tcp header) - length(Tcp Options)</li>
<li>TCP连接必须进行三次握手，在前两个握手包中双方互相声明自己的MSS，双方适配得到共识的MTU，这样就不会出现客户端发送的MTU大于接收方的情况</li>
</ul>
</li>
<li>网络层分段(UDP)<ul>
<li>ip层分片，丢失一个分片包就需要整个包重传</li>
<li>使用udp协议若不在应用层做好分段处理，就可能由于分片丢包重传导致性能地下</li>
<li>Udp 没有MSS的概念，全部数据移交给网络层</li>
</ul>
</li>
<li>接收方如何重组分段包<ul>
<li>将ID相同的分片按照off值（偏移量）进行重组</li>
<li>接收方通过Flags下面的的 <code>More Fragments = 0</code> 判断是不是最后一个分片，如果是最后一个分片了，可以开始重组分片了</li>
</ul>
</li>
</ul>
</li>
<li>Windos Scale<ul>
<li>TCP协议中只给接收窗口(win)预留了16个比特，意味着最大只能表示 65535 字节</li>
<li>随着网络带宽越来越大，预留的16个比特已经不够用了，RFC 1323 提供了一个创意，在三次握手时双方都把一个叫 <code>Windows Scale</code> 的值告知对方，对方收到后会把这个值当做2的指数，算出来的值再作为接收窗口的系数</li>
<li>假设 Windos Scale &#x3D; 3，win &#x3D; 10，那么实际的接收窗口 &#x3D; 10 * 2^3 &#x3D; 80</li>
<li>！！如果在三次握手之后才开始抓包，就无法获取到Windos Scale，只能显示出没有系数的大小，这是不准确的</li>
</ul>
</li>
<li>TTL(Time to Live)<ul>
<li>TTL 初始值一般为64</li>
<li>RFC 1812 一个网络包的TTL每减去1就意味着它经过一次路由</li>
<li>TTL一般可以用来验证网络拓扑，比如当前收到的包具体是哪个服务器发出的</li>
</ul>
</li>
</ul>
<h3 id="TCP-流量控制与窗口机制"><a href="#TCP-流量控制与窗口机制" class="headerlink" title="TCP 流量控制与窗口机制"></a>TCP 流量控制与窗口机制</h3><ol>
<li><h4 id="TCP头部Win字段"><a href="#TCP头部Win字段" class="headerlink" title="TCP头部Win字段"></a>TCP头部Win字段</h4></li>
</ol>
<ul>
<li>Win字段表示发送方的接收窗口大小(rwnd)</li>
<li>告知对方自己还能接收多少数据</li>
<li>动态变化：Win &#x3D; 接收缓冲区大小 - 已接收但未处理的数据量</li>
</ul>
<h4 id="2-流量控制机制"><a href="#2-流量控制机制" class="headerlink" title="2.  流量控制机制"></a>2.  流量控制机制</h4><h5 id="2-1-接收窗口-rwnd"><a href="#2-1-接收窗口-rwnd" class="headerlink" title="2.1   接收窗口(rwnd)"></a>2.1   接收窗口(rwnd)</h5><ul>
<li>通过TCP头部Win字段告知对方</li>
<li>反映接收方的处理能力</li>
<li>防止接收方缓冲区溢出</li>
<li>由应用程序处理速度决定</li>
</ul>
<h5 id="2-2-拥塞窗口-cwnd"><a href="#2-2-拥塞窗口-cwnd" class="headerlink" title="2.2  拥塞窗口(cwnd)"></a>2.2  拥塞窗口(cwnd)</h5><p><img data-src="/images/socket_02_11.jpeg" alt="img"></p>
<p><img data-src="/images/socket_02_12.png" alt="img"></p>
<ul>
<li>发送方内部维护，不需要告知对方</li>
<li>反映网络的承载能力</li>
<li>防止网络拥塞</li>
<li>由网络状况动态调整</li>
<li>拥塞窗口可以通过估算在途字节数进行计算，在途字节数 &#x3D; seq + len - ack，简单来说就是发送方这边发送过去的字节数减去对端ack的字节数得到在途字节数，那么拥塞窗口怎么确定最后一个数据包呢，找到第一个发生重传的数据包，根据此数据包进行过滤，得到最后一个发送的数据包以及ack包，就能计算在途字节数了，当然这种方式只是估算，需要采样几次，去最低的拥塞点作为拥塞窗口</li>
</ul>
<h5 id="2-3-实际发送控制"><a href="#2-3-实际发送控制" class="headerlink" title="2.3 实际发送控制"></a>2.3 实际发送控制</h5><blockquote>
<p>发送窗口大小 &#x3D; min(对方通告的win, 本地的cwnd)</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
        <tag>tcp</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>raft</title>
    <url>/2025/02/09/fen-bu-shi/suan-fa/raft/posts/undefined/</url>
    <content><![CDATA[<h2 id="Raft-的核心目标和基本工作原理"><a href="#Raft-的核心目标和基本工作原理" class="headerlink" title="Raft 的核心目标和基本工作原理"></a>Raft 的核心目标和基本工作原理</h2><p>核心目标：</p>
<ul>
<li>在分布式系统中达成共识，实现强一致性。</li>
<li>在保证一致性的基础上进行可靠的数据复制。</li>
</ul>
<p>基本工作原理：</p>
<ul>
<li>领导者选举：使用随机化的选举超时机制。</li>
<li>日志复制：采用 WAL（Write-Ahead Logging）方式。</li>
<li>安全性保证：确保只有包含全部已提交日志的节点才能成为领导者。</li>
<li>成员管理：支持动态的成员变更。</li>
</ul>
<p>关键特性：</p>
<ul>
<li>将问题分解为相对独立的子问题：领导者选举、日志复制和安全性。</li>
<li>使用 term（任期）作为逻辑时钟，管理整个集群的时序。</li>
<li>要求多数节点确认以提交日志，保证数据安全性。</li>
</ul>
<h2 id="Term-的概念和作用"><a href="#Term-的概念和作用" class="headerlink" title="Term 的概念和作用"></a>Term 的概念和作用</h2><p>定义：</p>
<ul>
<li>Term 是 Raft 中的逻辑时钟概念，表示领导者的任期。</li>
<li>每个 term 由一次选举开始，可能有一个领导者，也可能没有（选举失败）。</li>
</ul>
<p>作用：</p>
<ul>
<li>标识集群的逻辑时间，用于检测过时的信息。</li>
<li>在选举中确保新领导者包含所有已提交的日志。</li>
<li>在网络分区恢复后，帮助识别和废除旧的领导者。</li>
<li>在所有 Raft 的决策过程中起关键作用，如日志复制、提交判断等。</li>
</ul>
<p>更新机制：</p>
<ul>
<li>节点在开始新选举时增加自己的 term。</li>
<li>节点在收到包含更高 term 的消息时更新自己的 term。</li>
</ul>
<h2 id="领导者选举过程"><a href="#领导者选举过程" class="headerlink" title="领导者选举过程"></a>领导者选举过程</h2><p>触发条件：</p>
<ul>
<li>Follower 在选举超时时间内没有收到来自 Leader 的心跳。</li>
</ul>
<p>选举步骤：</p>
<ul>
<li>Follower 转变为 Candidate，增加当前 term，投票给自己。</li>
<li>发送 RequestVote RPC 给其他节点，包含自己的 term 和最后一条日志的 index 和 term。</li>
<li>其他节点根据以下规则决定是否投票： <ul>
<li>如果接收到的 term 大于自己的 term，则更新自己的 term 并投票。</li>
<li>如果 term 相同，比较日志的新旧程度（先比较最后一条日志的 term，再比较 index）。</li>
<li>如果接收到的 term 小于自己的 term，拒绝投票并返回自己的 term。</li>
</ul>
</li>
<li>如果 Candidate 收到多数选票，则成为新的 Leader。</li>
<li>如果在等待过程中收到更高 term 的消息，则转为 Follower。</li>
</ul>
<p>防止选票分裂：</p>
<ul>
<li>使用随机化的选举超时时间，减少多个节点同时发起选举的可能性。</li>
</ul>
<p>预选票机制（优化）：</p>
<ul>
<li>在正式选举前进行预选票阶段，不增加 term。</li>
<li>有助于防止网络分区后的不必要 term 增加。</li>
</ul>
<h2 id="日志一致性保证"><a href="#日志一致性保证" class="headerlink" title="日志一致性保证"></a>日志一致性保证</h2><p>Log Matching Property: </p>
<ul>
<li>如果两个日志在相同索引位置的日志条目具有相同的 term，则这两个日志在该索引之前的所有条目都相同。</li>
</ul>
<p>实现机制：</p>
<ul>
<li>Leader 在 AppendEntries RPC 中包含 prevLogIndex 和 prevLogTerm。</li>
<li>Follower 在接收新日志前，检查自己在 prevLogIndex 位置的日志条目的 term 是否与 prevLogTerm 匹配。</li>
<li>如果匹配，则接受新的日志条目；如果不匹配，则拒绝并返回冲突信息。</li>
<li>Leader 收到拒绝后，递减 nextIndex 并重试，直到找到匹配点。</li>
</ul>
<p>这种机制通过递归性质保证了所有之前的日志也是一致的。</p>
<h2 id="commitIndex-和-lastApplied"><a href="#commitIndex-和-lastApplied" class="headerlink" title="commitIndex 和 lastApplied"></a>commitIndex 和 lastApplied</h2><p>commitIndex: </p>
<ul>
<li>主要在 Leader 上维护。</li>
<li>表示最后一个已知被提交（即，被多数节点复制）的日志条目的索引。</li>
<li>更新规则：Leader 找出 matchIndex 中超过半数节点都大于等于的最大值，且对应日志的 term 等于当前 term。</li>
</ul>
<p>lastApplied: </p>
<ul>
<li>在所有节点上维护。</li>
<li>表示最后一个被应用到状态机的日志条目的索引。</li>
<li>更新规则：成功将日志应用到状态机后更新。</li>
</ul>
<p>关系：lastApplied ≤ commitIndex</p>
<p>Follower 更新 commitIndex：通过 Leader 的 AppendEntries RPC 中的 leaderCommit 字段更新。</p>
<h2 id="网络分区（脑裂）的处理"><a href="#网络分区（脑裂）的处理" class="headerlink" title="网络分区（脑裂）的处理"></a>网络分区（脑裂）的处理</h2><p>防止脑裂的核心机制：</p>
<ul>
<li>要求多数节点的同意才能选举 Leader 和提交日志。</li>
</ul>
<p>具体表现：</p>
<ul>
<li>在网络分区情况下，只有包含多数节点的分区能选出新 Leader。</li>
<li>少数派分区可能会不断尝试选举，但无法获得多数选票，因此不会成功。</li>
<li>当网络分区恢复时，较高 term 的 Leader 会使其他节点回归到 Follower 状态。</li>
</ul>
<p>优化：使用预选票机制减少不必要的 term 增加。</p>
<h2 id="成员变更过程"><a href="#成员变更过程" class="headerlink" title="成员变更过程"></a>成员变更过程</h2><p>两阶段过程：</p>
<p>第一阶段（联合共识）：</p>
<ul>
<li>Leader 创建包含新旧配置的特殊日志条目（C_old+C_new）。</li>
<li>复制这个日志到集群中的多数节点（包括新旧配置中的节点）。</li>
<li>在这个阶段，所有决策（日志提交、选举）需要同时满足新旧配置的多数要求。</li>
</ul>
<p>第二阶段（新配置）：</p>
<ul>
<li>当第一阶段的日志被提交，且新节点已经充分同步后，Leader 创建只包含新配置的日志条目（C_new）。</li>
<li>当这个新配置日志被提交后，集群完全切换到新配置。</li>
</ul>
<p>设计原因：</p>
<ul>
<li>确保在配置变更过程中不会出现决策冲突。</li>
<li>允许新节点在参与集群决策之前有时间同步日志。</li>
<li>保证在任何时候都有一个明确的、一致的集群配置。</li>
</ul>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>快照机制：</p>
<ul>
<li>定期创建包含完整状态机状态的快照。</li>
<li>创建快照后，可以安全地丢弃该点之前的所有日志。</li>
<li>快照包含：最后应用的日志的 index 和 term，最新的集群配置。</li>
</ul>
<p>用途：</p>
<ul>
<li>减少存储空间使用。</li>
<li>加速重启过程。</li>
<li>帮助落后太多的节点快速赶上（通过直接发送快照）。</li>
</ul>
<p>针对特定应用的优化：</p>
<ul>
<li>对于 KV 存储，可以只保留每个 key 的最新值。</li>
</ul>
<h2 id="读操作优化"><a href="#读操作优化" class="headerlink" title="读操作优化"></a>读操作优化</h2><p>挑战：确保读取的是最新数据。</p>
<p>优化策略：</p>
<ul>
<li>Leader 读取： <ul>
<li>Leader 在响应读请求前确认自己仍是当前 Leader（通过与多数节点通信）。</li>
<li>使用租约机制减少确认开销。</li>
</ul>
</li>
<li>Follower 读取（非强一致性）： <ul>
<li>直接从 Follower 读取，用于对一致性要求不高的场景。</li>
<li>可能读到稍旧的数据，但减轻了 Leader 的负担。</li>
</ul>
</li>
<li>读索引（Read Index）： <ul>
<li>Leader 记录当前的 commitIndex，确认 leadership，然后等待 applyIndex 赶上该 commitIndex。</li>
</ul>
</li>
<li>租约读（Lease Read）： <ul>
<li>Leader 维护一个租约，在租约内不与 Followers 通信即可响应读请求。</li>
</ul>
</li>
</ul>
<h2 id="Raft-vs-Paxos"><a href="#Raft-vs-Paxos" class="headerlink" title="Raft vs Paxos"></a>Raft vs Paxos</h2><p>设计理念：</p>
<ul>
<li>Raft 设计目标是易于理解和实现。</li>
<li>Paxos 更加理论化和通用。</li>
</ul>
<p>结构：</p>
<ul>
<li>Raft 将问题分解为领导选举、日志复制等子问题。</li>
<li>Paxos 是一个更单一的协议。</li>
</ul>
<p>领导机制：</p>
<ul>
<li>Raft 有明确的领导者选举过程。</li>
<li>Paxos 中领导角色不那么明确。</li>
</ul>
<p>日志特性：</p>
<ul>
<li>Raft 保证日志是连续的。</li>
<li>Paxos 允许日志中有”空洞”。</li>
</ul>
<p>实现复杂度：</p>
<ul>
<li>Raft 通常更容易实现和调试。</li>
<li>Paxos 的正确实现往往更复杂。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>算法</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>ES</title>
    <url>/2025/02/10/shu-ju-ku/es/es/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="/files/ES%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96.xlsx">ES参数优化</a></li>
</ul>
<h3 id="PUT、POST"><a href="#PUT、POST" class="headerlink" title="PUT、POST"></a>PUT、POST</h3><ul>
<li><code>PUT</code>操作主要是用来创建一个确定的新的文档<ul>
<li><code>PUT /index/_doc/1</code> 会创建一个 id&#x3D;1 的新文档，若是文档已存在，那么会进行删除，同时新增一条</li>
<li><code>PUT /index/_create/2</code> 会创建一个 id&#x3D;2 的新文档，若文档已存在，返回 http 409 错误</li>
</ul>
</li>
<li>POST 操作主要是用来创建一个不确定的新文档或者部分更新文档<ul>
<li><code>POST /index/_doc</code> 创建新文档，自动生成 ID</li>
<li><code>POST /index/_update/1</code> 部分更新现有文档</li>
</ul>
</li>
<li>最佳实践<ul>
<li>新增指定 ID 文档 &amp; 允许覆盖  <code>PUT /index/_doc/1</code></li>
<li>新增指定 ID 文档 &amp; 文档存在则报错 <code>PUT /index/_create/2</code></li>
<li>新增文档不指定 ID <code>POST /index/_doc</code></li>
<li>部分更新现有文档 <code>POST /index/_update/1</code></li>
</ul>
</li>
</ul>
<h3 id="index、create、update-API"><a href="#index、create、update-API" class="headerlink" title="index、create、update API"></a>index、create、update API</h3><h4 id="Index-API（索引-API）"><a href="#Index-API（索引-API）" class="headerlink" title="Index API（索引 API）"></a>Index API（索引 API）</h4><ul>
<li>作用：添加或替换文档。</li>
<li>类比：把一本书放在书架上。如果那个位置已经有书，就替换它。</li>
<li>示例：<code>PUT /library/book/1 &#123;&quot;title&quot;: &quot;Elasticsearch Guide&quot;&#125;</code></li>
<li>特点：不关心之前是否存在这本书。</li>
</ul>
<h4 id="Create-API（创建-API）"><a href="#Create-API（创建-API）" class="headerlink" title="Create API（创建 API）"></a>Create API（创建 API）</h4><ul>
<li>作用：仅添加新文档，如果文档已存在则失败。</li>
<li>类比：只有当书架上没有这本书时，才能放上去。</li>
<li>示例：<code>PUT /library/book/1?op_type=create &#123;&quot;title&quot;: &quot;New Book&quot;&#125;</code></li>
<li>特点：确保只添加新文档，不会覆盖现有文档。</li>
</ul>
<h4 id="Update-API（更新-API）"><a href="#Update-API（更新-API）" class="headerlink" title="Update API（更新 API）"></a>Update API（更新 API）</h4><ul>
<li>作用：修改现有文档的部分内容。</li>
<li>类比：修改书架上已有书的某些信息，比如更新作者名。</li>
<li>示例：<code>POST /library/book/1/_update &#123;&quot;doc&quot;: &#123;&quot;author&quot;: &quot;John Doe&quot;&#125;&#125;</code></li>
<li>特点：只能修改已存在的文档，且只更新指定的字段。</li>
</ul>
<ol>
<li>Index：不在乎文档是否已存在，总是添加或替换。（当你有新数据，但不确定它是否已存在时）</li>
<li>Create：只在文档不存在时才能成功。（当你只想添加新数据，绝不覆盖现有数据时）</li>
<li>Update：只能修改已存在的文档。（当你要修改现有数据的部分内容时）</li>
<li>Index 和 Create 通常使用 PUT 方法，Update 使用 POST 方法</li>
<li>Update 需要使用 “doc” 字段来指定要更新的内容</li>
</ol>
<h3 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h3><p><img data-src="/images/db/es/01.PNG" alt="img"></p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="from-size"><a href="#from-size" class="headerlink" title="from + size"></a>from + size</h4><blockquote>
<p>from、size 超过 10000 时会报错，不适合深度分页，因为需要在每个分片上拉取 （from + size）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 简单的分页操作</span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: <span class="number">0</span>, # 指定开始位置</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">10</span>, # 指定获取文档个数</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h4><blockquote>
<p>使用 search after API 可以避免产生深分页的问题，不过 <strong>search after 不支持跳转到指定页数，只能一页页地往下翻</strong></p>
</blockquote>
<ol>
<li>在 sort 中指定需要排序的字段，并且保证其值的唯一性（可以使用文档的 ID）。</li>
<li>在下一次查询时，带上返回结果中最后一个文档的 sort 值进行访问</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 第一次调用 search after</span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123; <span class="string">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 返回结果</span><br><span class="line"><span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">      <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;sort&quot;</span> : [<span class="number">20.9</span>, <span class="string">&quot;6&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82462&quot;</span>,</span><br><span class="line">      <span class="string">&quot;price&quot;</span> : <span class="number">19.9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;sort&quot;</span> : [<span class="number">19.9</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 第二次调用 search after</span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;search_after&quot;</span>:[<span class="number">19.9</span>, <span class="string">&quot;1&quot;</span>], # 设置为上次返回结果中最后一个文档的 sort 值</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Scroll-API"><a href="#Scroll-API" class="headerlink" title="Scroll API"></a>Scroll API</h4><blockquote>
<p>对结果集进行遍历的时候，例如做全量数据导出时，可以使用 scroll API。<strong>scroll API 会创建数据快照，后续的访问将会基于这个快照来进行，所以无法检索新写入的数据</strong></p>
</blockquote>
<ol>
<li>ES 7.10 中引入了 Point In Time 后，scroll API 就不建议被使用了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 第一次使用 scroll API，指定快照10m结束，超过10m</span><br><span class="line">POST books/_search?scroll=10m</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;, </span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_scroll_id&quot;</span> : <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF9......==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ......</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 进行翻页</span><br><span class="line">POST /_search/scroll                                                    </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scroll_id&quot;</span> : <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF9......==&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Point-in-time"><a href="#Point-in-time" class="headerlink" title="Point in time"></a>Point in time</h4><blockquote>
<p>Point In Time（PIT）是 ES 7.10 中引入的新特性，<strong>PIT 是一个轻量级的数据状态视图，用户可以利用这个视图反复查询某个索引，仿佛这个索引的数据集停留在某个时间点上</strong>。也就是说，在创建 PIT 之后更新的数据是无法被检索到的</p>
</blockquote>
<ol>
<li>使用 PIT 前需要显式使用 _pit API 获取一个 PID ID</li>
<li>PIT 可以允许用户在同一个固定数据集合上运行不同的查询，例如多个请求可以使用同一个 PIT 视图而互不影响</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 使用 pit API 获取一个 PID ID</span><br><span class="line">POST /books/_pit?keep_alive=20m</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>PIT 可以结合 search after 进行查询，能有效保证数据的一致性</li>
<li>Pit + search after 允许更改查询或排序字段，因为根据 search_after 一定定位到了某条数据，无论更改查询条件还是排序条件，只需要从新的查询条件的结果过滤出 search_after 后面的数据就能得到结果了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 第一次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。</span><br><span class="line"># 不再需要在 sort 中指定唯一的排序值了</span><br><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123; <span class="string">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="string">&quot;pit&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:  <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>, # 添加 PIT id</span><br><span class="line">    <span class="string">&quot;keep_alive&quot;</span>: <span class="string">&quot;5m&quot;</span> # 视图的有效时长</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; # 按价格倒序排序</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pit_id&quot;</span> : <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sort&quot;</span> : [<span class="number">20.9</span>, <span class="number">8589934593</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82462&quot;</span></span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">19.9</span></span><br><span class="line">        &#125;,</span><br><span class="line">        # 第一个是我们用作排序的 price 的值</span><br><span class="line">        # 第二个值是一个隐含的排序值。所有的 PIT 请求都会自动加入一个隐式的用于排序的字段称为：_shard_doc，当然这个排序值可以显式指定。</span><br><span class="line">        # 这个隐含的字段官方也称它为：tiebreaker（决胜字段），其代表的是文档的唯一值，保证了分页不会丢失或者分页结果的数据不会重复，其作用就好像原 search after 的 sort 字段中要指定的唯一值一样</span><br><span class="line">        <span class="string">&quot;sort&quot;</span> : [<span class="number">19.9</span>, <span class="number">8589934592</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。</span><br><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;pit&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:  <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>, # 添加 PIT id</span><br><span class="line">    <span class="string">&quot;keep_alive&quot;</span>: <span class="string">&quot;5m&quot;</span> # 视图的有效时长</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;search_after&quot;</span>: [<span class="number">19.9</span>, <span class="number">8589934592</span>], # 上次结果中最后一个文档的 sort 值</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>rocksdb</title>
    <url>/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/</url>
    <content><![CDATA[<h4 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h4><p><img data-src="/images/db/rocksdb/image1.png" alt="image1.png"></p>
<h4 id="数据读取流程"><a href="#数据读取流程" class="headerlink" title="数据读取流程"></a>数据读取流程</h4><p><img data-src="/images/db/rocksdb/image2.png" alt="image2.png"></p>
<h4 id="db-相关属性"><a href="#db-相关属性" class="headerlink" title="db 相关属性"></a>db 相关属性</h4><table>
<thead>
<tr>
<th>类别</th>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>总体统计</td>
<td>rocksdb.stats</td>
<td>提供详细的数据库统计信息，包括压缩、读写操作、块缓存等数据</td>
</tr>
<tr>
<td>数据库大小</td>
<td>rocksdb.total-sst-files-size</td>
<td>所有 SST 文件的总大小</td>
</tr>
<tr>
<td></td>
<td>rocksdb.estimate-table-readers-mem</td>
<td>估计表读取器使用的内存</td>
</tr>
<tr>
<td></td>
<td>rocksdb.estimate-live-data-size</td>
<td>估计的活跃数据大小</td>
</tr>
<tr>
<td>内存使用</td>
<td>rocksdb.cur-size-all-mem-tables</td>
<td>所有 MemTable 的当前大小</td>
</tr>
<tr>
<td></td>
<td>rocksdb.block-cache-usage</td>
<td>块缓存的使用量</td>
</tr>
<tr>
<td>压缩</td>
<td>rocksdb.background-errors</td>
<td>后台工作（如压缩）中的错误数</td>
</tr>
<tr>
<td></td>
<td>rocksdb.num-running-compactions</td>
<td>当前运行的压缩任务数</td>
</tr>
<tr>
<td>写入</td>
<td>rocksdb.num-immutable-mem-table</td>
<td>不可变 MemTable 的数量</td>
</tr>
<tr>
<td></td>
<td>rocksdb.mem-table-flush-pending</td>
<td>是否有待处理的 MemTable 刷新</td>
</tr>
<tr>
<td></td>
<td>rocksdb.is-write-stopped</td>
<td>写入是否已停止</td>
</tr>
<tr>
<td></td>
<td>rocksdb.actual-delayed-write-rate</td>
<td>实际的延迟写入速率</td>
</tr>
<tr>
<td>读取</td>
<td>rocksdb.estimate-num-keys</td>
<td>估计的键数量</td>
</tr>
<tr>
<td>文件</td>
<td>rocksdb.num-files-at-level<N></td>
<td>第 N 层的文件数量（如 rocksdb.num-files-at-level0）</td>
</tr>
<tr>
<td></td>
<td>rocksdb.live-sst-files-size</td>
<td>活跃 SST 文件的大小</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>使用方法示例：<code>String value = db.getProperty(&quot;rocksdb.stats&quot;);</code></li>
<li>某些属性可能会影响性能，应谨慎使用。</li>
<li>属性值可能会频繁变化，建议定期获取以监控趋势。</li>
<li>在生产环境中使用时，可能需要限制获取这些属性的频率。</li>
</ol>
<h4 id="事务操作使用场景"><a href="#事务操作使用场景" class="headerlink" title="事务操作使用场景"></a>事务操作使用场景</h4><ul>
<li>为单个 key 提供并发控制<ol>
<li>事务开始时获取逻辑锁</li>
<li>提交时检查冲突</li>
<li>避免显式锁定，提高并发性</li>
<li>减少死锁风险</li>
<li>计数器更新</li>
<li>用户状态修改</li>
</ol>
</li>
<li>确保多个 key 的一致性更新<ol>
<li>将多个 key 操作组合为单一事务</li>
<li>全部成功或全部失败</li>
<li>维护相关数据的一致性</li>
<li>简化复杂操作的实现</li>
<li>用户注册（创建账户 + 初始化设置）</li>
<li>订单处理（更新库存 + 记录订单）</li>
</ol>
</li>
</ul>
<h4 id="RocksDB-默认冲突检测机制"><a href="#RocksDB-默认冲突检测机制" class="headerlink" title="RocksDB 默认冲突检测机制"></a>RocksDB 默认冲突检测机制</h4><h5 id="事务间冲突检测"><a href="#事务间冲突检测" class="headerlink" title="事务间冲突检测"></a>事务间冲突检测</h5><ol>
<li>触发时机：事务提交时</li>
<li>检测对象：活跃事务之间的写集</li>
<li>检测方式：<ol>
<li>每个事务的 put 操作都会记录在写集中</li>
<li>提交时检查本事务的写集是否与其他活跃事务的写集冲突</li>
<li>结果：如果发现冲突，后提交的事务通常会失败</li>
</ol>
</li>
</ol>
<h5 id="非事务性写入检测"><a href="#非事务性写入检测" class="headerlink" title="非事务性写入检测"></a>非事务性写入检测</h5><ol>
<li>触发时机：执行非事务性写入时（如 txnDb.put()）</li>
<li>检测对象：所有活跃事务的锁和写意图</li>
<li>检测方式：<ol>
<li>检查目标键是否被任何活跃事务锁定</li>
<li>检查是否有活跃事务对该键有写意图</li>
<li>结果：如果存在冲突，非事务性写入会失败并抛出异常</li>
</ol>
</li>
</ol>
<h5 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h5><ol>
<li>写意图（Write Intents）：事务执行写操作时登记，用于冲突检测</li>
<li>锁定机制：事务的 put 操作会为相应的键设置锁</li>
<li>快照隔离：事务开始时获取数据快照，影响可见的数据版本</li>
<li>乐观并发控制（默认）：大多数冲突检测在提交时进行</li>
<li>悲观锁定（可配置）：启用后，冲突检测在写操作执行时就会进行</li>
</ol>
<h4 id="RocksDB-读取策略"><a href="#RocksDB-读取策略" class="headerlink" title="RocksDB 读取策略"></a>RocksDB 读取策略</h4><h5 id="读已提交-默认"><a href="#读已提交-默认" class="headerlink" title="读已提交(默认)"></a>读已提交(默认)</h5><p>内部事务对于外部事务提交的立马可见</p>
<h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readOptions.setSnapshot(snapshot);</span><br></pre></td></tr></table></figure>
<p>快照读类比于读已提交，对于外部事务只能看到当前快照创建时提交的数据，对于当前事务，所有写入都是可见的</p>
<h4 id="RocksDB-事务版本号管理"><a href="#RocksDB-事务版本号管理" class="headerlink" title="RocksDB 事务版本号管理"></a>RocksDB 事务版本号管理</h4><ul>
<li>对于冲突检测来说，使用事务开始时的快照序列号作为基准，比较操作键的当前序列号与快照序列号</li>
<li>对于提交来说，获取新的全局序列号作为起始点，将事务内部的临时序列号映射到连续的全局序列号，最终序列号 &#x3D; 新全局序列号 + 临时序列号偏移</li>
<li>所以会出现某个事务过程中，外部事务修改了键，内部事务再使用getForUpdate就会报错，因为比较实用的是快照的序列号</li>
<li>getForUpdate还有个好处就是能检测外部非事务性操作，因为本质上使用的是序列号比较，所以能检测，但是默认的写写冲突是无法检测的，因为默认是读已提交，rocksdb认为这是合理的，内部事务会覆盖外部事物的值</li>
</ul>
<table>
<thead>
<tr>
<th>方面</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>全局序列号</td>
<td>- 全局递增的序列号作为版本标识<br>- 每次非事务写入或事务提交时分配</td>
</tr>
<tr>
<td>事务开始</td>
<td>- 创建数据库快照<br>- 记录当前最大序列号作为事务”基线”</td>
</tr>
<tr>
<td>读操作</td>
<td>- 使用事务开始时的快照序列号<br>- 只读取序列号≤快照序列号的数据</td>
</tr>
<tr>
<td>写操作</td>
<td>- 不立即分配全局序列号<br>- 事务内部使用临时本地序列号</td>
</tr>
<tr>
<td>事务提交</td>
<td>- 获取新的全局序列号<br>- 将事务内写操作映射到连续的全局序列号<br>- 用新序列号更新数据库</td>
</tr>
<tr>
<td>回滚处理</td>
<td>- 丢弃事务内的所有本地序列号<br>- 不影响全局序列号</td>
</tr>
<tr>
<td>冲突检测</td>
<td>- 读写冲突：比较快照序列号与当前数据序列号<br>- 写写冲突：提交时检查数据是否被其他事务修改</td>
</tr>
<tr>
<td>OptimisticTransactionDB</td>
<td>- 延迟冲突检测到提交阶段<br>- 提交时比较数据当前序列号与事务开始序列号</td>
</tr>
<tr>
<td>TransactionDB</td>
<td>- 可能在操作过程中进行冲突检测<br>- 使用锁机制预防冲突</td>
</tr>
<tr>
<td>隔离级别影响</td>
<td>- 读已提交：每次读操作使用最新快照<br>- 可重复读：整个事务使用开始时的快照<br>- 快照隔离：类似可重复读，但有额外写冲突检测</td>
</tr>
<tr>
<td>注意事项</td>
<td>- 版本号管理是实现 MVCC 的基础<br>- 有助于理解和处理事务冲突和并发问题</td>
</tr>
</tbody></table>
<h4 id="getForUpdate总结"><a href="#getForUpdate总结" class="headerlink" title="getForUpdate总结"></a>getForUpdate总结</h4><ol>
<li>用来解决读写冲突，这里的冲突可以是事务与其他事务之间，也可以是事务与非事务操作之间</li>
<li>我认为是使用序列号进行检测的，当前快照的序列号与键的序列号之间的比较判断是否冲突</li>
<li>对于OptimisticTransactionDB和TransactionDB检测的时机不一样，前者属于乐观型的，在commit才会检测，后者会立即检测</li>
</ol>
]]></content>
      <categories>
        <category>rocksdb</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>rocksdb</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2025/02/10/shu-ju-ku/mysql/mysql/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><a href="https://relph1119.github.io/mysql-learning-notes/#/">《MySQL 是怎样运行的：从根儿上理解 MySQL》</a></li>
</ul>
<h2 id="初识-MySQL"><a href="#初识-MySQL" class="headerlink" title="初识 MySQL"></a>初识 MySQL</h2><h3 id="启动服务器程序"><a href="#启动服务器程序" class="headerlink" title="启动服务器程序"></a>启动服务器程序</h3><ul>
<li><strong>mysqld</strong> 表示 mysql 服务器程序，运行这个可执行文件想可以直接启动一个 mysql 服务器进程，但这个可执行文件并不常用</li>
<li><strong>mysqld_safe</strong> 一个启动脚本，会间接调用 mysqld 并持续监控服务器的运行状态。当服务器进程出现错误时，还可以帮助重启服务器程序，另外，使用 mysqld_safe 启动 MYSQL 服务器程序时，它会将服务器程序的出错信息和其他诊断信息输出到错误日志，方便后期查找发生错误的原因（出错日志默认写到一个以 .err 为扩展名的文件中，该文件位于 mysql 的数据目录中）</li>
<li><strong>mysqld.server</strong> 也是一个启动脚本，会间接的调用 mysqld_safe。在执行 mysql.server 时，在后面添加 start 参数就可以启动服务器程序了。需要注意的是，mysqld.server 文件其实是一个链接文件，它对应的时机文件是 ..&#x2F;support-files&#x2F;mysql.server</li>
<li><strong>mysqld_multi</strong> 在一台计算机上运行多个服务器实例</li>
</ul>
<pre>
<code class="mermaid">

flowchart LR
  A[mysqld.server]
  B[mysql_safe]
  C[mysqld]

  A--&gt;|启动|B--&gt;|监控并启动|C
</code>
</pre>

<h3 id="启动客户端程序"><a href="#启动客户端程序" class="headerlink" title="启动客户端程序"></a>启动客户端程序</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><ul>
<li>mysql -h127.0.0.1 -uroot -P3307 -p</li>
</ul>
<h4 id="UNIX-套接字"><a href="#UNIX-套接字" class="headerlink" title="UNIX 套接字"></a>UNIX 套接字</h4><blockquote>
<p>服务端进程与客户端进程运行在一台机器上，使用 UNIX 域套接字进行进程间通信。默认 mysql 服务端启动的套接字文件是 &#x2F;tmp&#x2F;mysql.sock</p>
</blockquote>
<ul>
<li>mysql -S &#x2F;tmp&#x2F;mysql.sock</li>
<li>mysql –socket &#x2F;tmp&#x2F;mysql.sock</li>
</ul>
<h3 id="启动多个-mysql-服务端进程"><a href="#启动多个-mysql-服务端进程" class="headerlink" title="启动多个 mysql 服务端进程"></a>启动多个 mysql 服务端进程</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 端口</span><br><span class="line">port=<span class="number">3307</span></span><br><span class="line"># 监听的套接字文件</span><br><span class="line">socket=/tmp/mysql.sock2</span><br><span class="line"># 数据文件地址</span><br><span class="line">datadir=/opt/homebrew/var/mysql3307</span><br><span class="line"># 指定进程文件，好处是可以快速根据此文件定位到进程是否启动 cat /opt/homebrew/logs/mysql/mysqld3307.pid</span><br><span class="line">pid-file=/opt/homebrew/logs/mysql/mysqld3307.pid</span><br><span class="line"># 日志文件</span><br><span class="line"><span class="built_in">log</span>-error=/opt/homebrew/logs/mysql/mysqld3307.<span class="built_in">log</span></span><br><span class="line"><span class="meta"># mysqlx 端口</span></span><br><span class="line">mysqlx_port=<span class="number">33070</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化-mysql-数据目录"><a href="#初始化-mysql-数据目录" class="headerlink" title="初始化 mysql 数据目录"></a>初始化 mysql 数据目录</h4><ul>
<li><code>--initialize</code>： 这个选项告诉 MySQL 创建一个新的数据目录结构，包括必要的系统表。它会生成一个随机的临时 root 密码</li>
<li><code>--user=mysql</code>： 指定哪个系统用户将拥有这些新创建的文件。通常，这应该是运行 MySQL 服务器的用户</li>
<li><code>--datadir=/opt/homebrew/var/mysql3307</code>： 这指定新数据目录的位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --datadir=/opt/homebrew/var/mysql3307</span><br></pre></td></tr></table></figure>

<h4 id="启动服务端程序"><a href="#启动服务端程序" class="headerlink" title="启动服务端程序"></a>启动服务端程序</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=/opt/homebrew/etc/my_3307.cnf</span><br></pre></td></tr></table></figure>

<h4 id="客户端连接服务端"><a href="#客户端连接服务端" class="headerlink" title="客户端连接服务端"></a>客户端连接服务端</h4><ul>
<li>mysql -S &#x2F;tmp&#x2F;mysql.sock2 -uroot -p</li>
<li>mysql -h127.0.0.1 -uroot -P3307 -p</li>
</ul>
<h3 id="服务端处理客户端请求"><a href="#服务端处理客户端请求" class="headerlink" title="服务端处理客户端请求"></a>服务端处理客户端请求</h3><p><img data-src="/images/db/MySQL/01.png" alt="img"></p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><blockquote>
<p>客户端进程可以采用我们上面介绍的<code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code>这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。<code>MySQL</code>服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量。</p>
</blockquote>
<ul>
<li>如何限制？</li>
<li>mysql 服务器给每一个客户端都分配了一个线程，这个线程和客户端是深度绑定的，即和客户端的 socket 是深度绑定的，会通过 read 方法阻塞式的获取客户端请求</li>
</ul>
<h4 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h4><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><blockquote>
<p><code>MySQL</code>服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果<code>缓存</code>起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端 A 刚刚查询了一个语句，而客户端 B 之后发送了同样的查询请求，那么客户端 B 的这次查询就可以直接使用查询缓存中的数据</p>
</blockquote>
<ul>
<li>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中</li>
<li>如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存</li>
<li>MySQL 的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除</li>
<li>虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除</li>
</ul>
<h5 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h5><blockquote>
<p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以<code>MySQL</code>服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到<code>MySQL</code>服务器内部使用的一些数据结构上来</p>
</blockquote>
<h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><blockquote>
<p>语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的<code>MySQL</code>语句执行起来效率可能并不是很高，<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划</p>
</blockquote>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><blockquote>
<p>截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，<code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块里。我们知道<code>表</code>是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是<code>存储引擎</code>负责的事情。为了实现不同的功能，<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同</p>
</blockquote>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARCHIVE</td>
<td>用于数据存档（行被插入后不能再修改）</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td>CSV</td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td>FEDERATED</td>
<td>用来访问远程表</td>
</tr>
<tr>
<td>InnoDB</td>
<td>具备外键支持功能的事务存储引擎</td>
</tr>
<tr>
<td>MEMORY</td>
<td>置于内存的表</td>
</tr>
<tr>
<td>MERGE</td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td>MyISAM</td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td>NDB</td>
<td>MySQL集群专用存储引擎</td>
</tr>
</tbody></table>
<h5 id="InnoDB是MySQL默认的存储引擎"><a href="#InnoDB是MySQL默认的存储引擎" class="headerlink" title="InnoDB是MySQL默认的存储引擎"></a><code>InnoDB</code>是<code>MySQL</code>默认的存储引擎</h5><h5 id="查看当前服务程序支持的存储引擎"><a href="#查看当前服务程序支持的存储引擎" class="headerlink" title="查看当前服务程序支持的存储引擎"></a>查看当前服务程序支持的存储引擎</h5><blockquote>
<p><code>Support</code>列表示该存储引擎是否可用，<code>DEFAULT</code>值代表是当前服务器程序的默认存储引擎。<code>Comment</code>列是对存储引擎的一个描述。<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表该存储引擎是否支持分布式事务。<code>Savepoints</code>代表该列是否支持部分事务回滚</p>
</blockquote>
<p><img data-src="/images/db/MySQL/02.png" alt="img"></p>
<h5 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h5><ul>
<li>创建表时指定存储引擎</li>
</ul>
<blockquote>
<p>创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎<code>InnoDB</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表的存储引擎</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看表的存储引擎</li>
</ul>
<p><img data-src="/images/db/MySQL/03.png" alt="img"></p>
<h2 id="启动选项和系统变量"><a href="#启动选项和系统变量" class="headerlink" title="启动选项和系统变量"></a>启动选项和系统变量</h2><h3 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h3><blockquote>
<p>每个 MySQL 程序都有许多不同的选项。大多数程序提供了一个<code>--help</code>选项，可以查看该程序支持的全部启动选项以及它们的默认值。在命令行中设置启动选项只对当次启动生效！！</p>
</blockquote>
<ul>
<li><code>mysql --help</code></li>
</ul>
<p><img data-src="/images/db/MySQL/04.png" alt="img"></p>
<ul>
<li><code>mysqld_safe --help</code></li>
<li><code>mysqld --verbose --help</code></li>
</ul>
<p><img data-src="/images/db/MySQL/05.png" alt="img"></p>
<h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p>在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的很烦呀！于是设计<code>MySQL</code>的大佬们提出一种<code>配置文件</code>（也称为<code>选项文件</code>）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，所以我们推荐使用配置文件的方式来设置启动选项。</p>
</blockquote>
<h4 id="类-Unix-操作系统中的配置文件"><a href="#类-Unix-操作系统中的配置文件" class="headerlink" title="类 Unix 操作系统中的配置文件"></a>类 Unix 操作系统中的配置文件</h4><blockquote>
<p>在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件</p>
</blockquote>
<ul>
<li>这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在<code>~/.my.cnf</code>这个路径下创建一个配置文件</li>
<li>在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准（比如&#x2F;etc&#x2F;my.cnf 与～&#x2F;。my.cnf 都配置了相同的启动选项，以～&#x2F;。my.cnf 为准）</li>
</ul>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;my.cnf</td>
<td>homebrew安装的目录对应 &#x2F;opt&#x2F;homebrew&#x2F;etc</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;mysql&#x2F;my.cnf</td>
<td></td>
</tr>
<tr>
<td>SYSCONFDIR&#x2F;my.cnf</td>
<td></td>
</tr>
<tr>
<td>$MYSQL_HOME&#x2F;my.cnf</td>
<td>特定于服务器的选项（仅限服务器）</td>
</tr>
<tr>
<td>defaults-extra-file</td>
<td>命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td>~&#x2F;.my.cnf</td>
<td>用户特定选项</td>
</tr>
<tr>
<td>~&#x2F;.mylogin.cnf</td>
<td>用户特定的登录路径选项（仅限客户端）</td>
</tr>
</tbody></table>
<h4 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h4><blockquote>
<p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line">(具体的启动选项...)</span><br></pre></td></tr></table></figure>

<p>像这个配置文件里就定义了许多个组，组名分别是<code>server</code>、<code>mysqld</code>、<code>mysqld_safe</code>、<code>client</code>、<code>mysql</code>、<code>mysqladmin</code>。每个组下面可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">option1            <span class="comment">#这是option1，该选项不需要选项值</span></span><br><span class="line">option2 = value2      <span class="comment">#这是option2，该选项需要选项值</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加<code>--</code>前缀，并且每行只指定一个选项，而且<code>=</code>周围可以有空白字符（命令行中选项名、<code>=</code>、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用<code>#</code>来添加注释，从<code>#</code>出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。</p>
<p>配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如，<code>[mysqld]</code>和<code>[mysql]</code>组分别应用于<code>mysqld</code>服务器程序和<code>mysql</code>客户端程序。不过有两个选项组比较特别：</p>
<ul>
<li><code>[server]</code>组下面的启动选项将作用于所有的服务器程序。</li>
<li><code>[client]</code>组下面的启动选项将作用于所有的客户端程序。</li>
</ul>
<table>
<thead>
<tr>
<th>启动命令</th>
<th>类别</th>
<th>能读取的组</th>
</tr>
</thead>
<tbody><tr>
<td>mysqld</td>
<td>启动服务器</td>
<td>[mysqld]、[server]</td>
</tr>
<tr>
<td>mysqld_safe</td>
<td>启动服务器</td>
<td>[mysqld]、[server]、[mysqld_safe]</td>
</tr>
<tr>
<td>mysql.server</td>
<td>启动服务器</td>
<td>[mysqld]、[server]、[mysql.server]</td>
</tr>
<tr>
<td>mysql</td>
<td>启动客户端</td>
<td>[mysql]、[client]</td>
</tr>
<tr>
<td>mysqladmin</td>
<td>启动客户端</td>
<td>[mysqladmin]、[client]</td>
</tr>
<tr>
<td>mysqldump</td>
<td>启动客户端</td>
<td>[mysqldump]、[client]</td>
</tr>
</tbody></table>
<p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项</p>
<h4 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h4><ol>
<li>在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准，配置文件的读取顺序参考 <a href="https://rq3nt70g815.feishu.cn/wiki/HBT2wcn8Ti4ONakGlG0c7jc6n7e#MAsXdQbjFoh6iVxH2x3cRpACnlc">二、启动选项和系统变量</a></li>
<li>同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，比如<code>~/.my.cnf</code>，在这些组里出现了同样的配置项，比如这样，将以最后一个出现的组中的启动选项为准，👇🏻例子以<code>[mysqld]</code>组中的配置项为准</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=InnoDB</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准</li>
</ol>
<h4 id="defaults-file-的使用"><a href="#defaults-file-的使用" class="headerlink" title="defaults-file 的使用"></a>defaults-file 的使用</h4><blockquote>
<p>如果我们不想让<code>MySQL</code>到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定<code>defaults-file</code>选项，比如这样（以<code>UNIX</code>系统为例）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=/tmp/myconfig.txt</span><br></pre></td></tr></table></figure>

<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><code>MySQL</code>服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL</code>系统变量，比如允许同时连入的客户端数量用系统变量<code>max_connections</code>表示，表的默认存储引擎用系统变量<code>default_storage_engine</code>表示，查询缓存的大小用系统变量<code>query_cache_size</code>表示，<code>MySQL</code>服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它</p>
<h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;default_storage_engine&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES like <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h4><h5 id="通过启动选项设置"><a href="#通过启动选项设置" class="headerlink" title="通过启动选项设置"></a>通过启动选项设置</h5><blockquote>
<p>大部分的<code>系统变量</code>都可以通过启动服务器时传送启动选项的方式来进行设置</p>
</blockquote>
<ul>
<li>通过命令行添加启动选项</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM --max-connections=10</span><br></pre></td></tr></table></figure>

<ul>
<li>通过配置文件添加启动选项</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=MyISAM</span><br><span class="line">max-connections=10</span><br></pre></td></tr></table></figure>

<ul>
<li>对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是对应的系统变量之间必须使用下划线<code>_</code>连接起来</li>
</ul>
<h5 id="服务器程序运行过程中设置"><a href="#服务器程序运行过程中设置" class="headerlink" title="服务器程序运行过程中设置"></a>服务器程序运行过程中设置</h5><blockquote>
<p><code>系统变量</code>比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中，进行动态修改而无需停止并重启服务器。</p>
</blockquote>
<ul>
<li><p>作用范围</p>
<ul>
<li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li>
<li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li>
</ul>
</li>
<li><p>通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的</p>
</li>
<li><p>设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code></p>
</li>
<li><p>通过客户端程序设置系统变量的语法</p>
<ul>
<li><pre><code class="language-Bash">SET [GLOBAL|SESSION] 系统变量名 = 值;
SET [@@(GLOBAL|SESSION).]var_name = XXX;

# 全局设置
语句一：SET GLOBAL default_storage_engine = MyISAM;
语句二：SET @@GLOBAL.default_storage_engine = MyISAM;

# 针对本客户端设置，选择下面三条语句中的任意一条来进行设置
语句一：SET SESSION default_storage_engine = MyISAM;
语句二：SET @@SESSION.default_storage_engine = MyISAM;
语句三：SET default_storage_engine = MyISAM;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `SHOW VARIABLES`语句默认查看的是`SESSION`作用范围的系统变量，也可以通过下面方式查看不同作用范围的系统变量</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围</p>
<ul>
<li>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接</li>
<li>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值</li>
</ul>
</li>
<li><p>有些系统变量是只读的，并不能设置值</p>
<ul>
<li>比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看</li>
</ul>
</li>
</ul>
<h3 id="启动选项与系统变量的区别"><a href="#启动选项与系统变量的区别" class="headerlink" title="启动选项与系统变量的区别"></a>启动选项与系统变量的区别</h3><blockquote>
<p><code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量</p>
</blockquote>
<ul>
<li>大部分的系统变量都可以被当作启动选项传入</li>
<li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>等</li>
<li>有些启动选项也不是系统变量，比如<code>defaults-file</code></li>
</ul>
<h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>为了让我们更好的了解服务器程序的运行情况，<code>MySQL</code>服务器程序中维护了很多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录等。</p>
<p>由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与<code>系统变量</code>类似，<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<p>如果我们不写明作用范围，默认的作用范围是<code>SESSION</code></p>
<p><img data-src="/images/db/MySQL/06.png" alt="img"></p>
<h2 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h2><h3 id="一些重要的字符集"><a href="#一些重要的字符集" class="headerlink" title="一些重要的字符集"></a>一些重要的字符集</h3><ul>
<li><code>ASCII</code>字符集</li>
</ul>
<p>共收录 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才 128 个字符，所以可以使用 1 个字节来进行编码，我们看一些字符的编码方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;L&#x27;</span> -&gt;  01001100（十六进制：0x4C，十进制：76）</span><br><span class="line"><span class="string">&#x27;M&#x27;</span> -&gt;  01001101（十六进制：0x4D，十进制：77）</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ISO 8859-1</code>字符集</li>
</ul>
<p>共收录 256 个字符，是在<code>ASCII</code>字符集的基础上又扩充了 128 个西欧常用字符（包括德法两国的字母），也可以使用 1 个字节来进行编码。这个字符集也有一个别名<code>latin1</code></p>
<ul>
<li><code>GB2312</code>字符集</li>
</ul>
<p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字 6763 个，其他文字符号 682 个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p>
<ul>
<li><p>如果该字符在<code>ASCII</code>字符集中，则采用 1 字节编码</p>
</li>
<li><p>否则采用 2 字节编码</p>
</li>
<li><p><code>GBK</code>字符集</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GBK`字符集只是在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容`GB2312</span><br></pre></td></tr></table></figure>

<ul>
<li><code>utf8</code>字符集</li>
</ul>
<p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用 1～4 个字节。其实准确的说，utf8 只是 Unicode 字符集的一种编码方案，Unicode 字符集可以采用 utf8、utf16、utf32 这几种编码方案，utf8 使用 1～4 个字节编码一个字符，utf16 使用 2 个或 4 个字节编码一个字符，utf32 使用 4 个字节编码一个字符。MySQL 中并不区分字符集和编码方案的概念，所以把 utf8、utf16、utf32 都当作一种字符集对待。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;L&#x27;</span> -&gt;  01001100（十六进制：0x4C）</span><br><span class="line"><span class="string">&#x27;啊&#x27;</span> -&gt;  111001011001010110001010（十六进制：0xE5958A）</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-中支持的字符集和排序规则"><a href="#MySQL-中支持的字符集和排序规则" class="headerlink" title="MySQL 中支持的字符集和排序规则"></a>MySQL 中支持的字符集和排序规则</h3><h4 id="MySQL-中的-utf8-和-utf8mb4"><a href="#MySQL-中的-utf8-和-utf8mb4" class="headerlink" title="MySQL 中的 utf8 和 utf8mb4"></a>MySQL 中的 utf8 和 utf8mb4</h4><p><code>utf8</code>字符集表示一个字符需要使用 1～4 个字节，但是我们常用的一些字符使用 1～3 个字节就可以表示了。而在<code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计<code>MySQL</code>的大佬偷偷的定义了两个概念：</p>
<ul>
<li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用 1～3 个字节表示字符。在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用 1～3 个字节来表示一个字符。</li>
<li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用 1～4 个字节表示字符。存储一些 emoji 表情什么的。</li>
</ul>
<h4 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h4><p><code>MySQL</code>支持好多好多种字符集，查看当前<code>MySQL</code>中支持的字符集可以用下面这个语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CHARACTER SET和CHARSET是同义词</span></span><br><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字符集名称</th>
<th>Maxlen</th>
</tr>
</thead>
<tbody><tr>
<td>ascii</td>
<td>1</td>
</tr>
<tr>
<td>latin1</td>
<td>1</td>
</tr>
<tr>
<td>gb2312</td>
<td>2</td>
</tr>
<tr>
<td>gbk</td>
<td>2</td>
</tr>
<tr>
<td>utf8</td>
<td>3</td>
</tr>
<tr>
<td>utf8mb4</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h4><p>查看<code>MySQL</code>中支持的比较规则的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<ul>
<li>比较规则名称以与其关联的字符集的名称开头</li>
<li>后边紧跟着该比较规则主要作用于哪种语言，比如<code>utf8_polish_ci</code>表示以波兰语的规则比较，<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则</li>
<li>名称后缀意味着该比较规则是否区分语言中的重音、大小写什么的，具体可以用的值如下</li>
</ul>
<table>
<thead>
<tr>
<th>后缀</th>
<th>英文释义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_ai</td>
<td>accent insensitive</td>
<td>不区分重音</td>
</tr>
<tr>
<td>_as</td>
<td>accent sensitive</td>
<td>区分重音</td>
</tr>
<tr>
<td>_ci</td>
<td>case insensitive</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>_cs</td>
<td>case sensitive</td>
<td>区分大小写</td>
</tr>
<tr>
<td>_bin</td>
<td>binary</td>
<td>以二进制方式比较</td>
</tr>
</tbody></table>
<h4 id="各级别的字符集和比较规则"><a href="#各级别的字符集和比较规则" class="headerlink" title="各级别的字符集和比较规则"></a>各级别的字符集和比较规则</h4><h5 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h5><blockquote>
<p><code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则</p>
</blockquote>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_server</td>
<td>服务器级别的字符集</td>
</tr>
<tr>
<td>collation_server</td>
<td>服务器级别的比较规则</td>
</tr>
</tbody></table>
<p><img data-src="/images/db/MySQL/07.png" alt="img"></p>
<blockquote>
<p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用<code>SET</code>语句修改这两个变量的值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure>

<h5 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h5><blockquote>
<p>在创建和修改数据库的时候可以指定该数据库的字符集和比较规则</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure>

<p><em>character_set_database</em> 和 <em>collation_database</em> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_database</td>
<td>当前数据库的字符集</td>
</tr>
<tr>
<td>collation_database</td>
<td>当前数据库的比较规则</td>
</tr>
</tbody></table>
<h5 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h5><blockquote>
<p>也可以在创建和修改表的时候指定表的字符集和比较规则</p>
</blockquote>
<ul>
<li>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure>

<h5 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h5><blockquote>
<p>对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则</p>
</blockquote>
<ul>
<li>如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure>

<h5 id="各级别字符集和比较规则小结"><a href="#各级别字符集和比较规则小结" class="headerlink" title="各级别字符集和比较规则小结"></a>各级别字符集和比较规则小结</h5><ul>
<li>如果创建或修改列时，没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则</li>
<li>如果创建或修改表时，没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则</li>
<li>如果创建或修改数据库时，没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则</li>
</ul>
<h3 id="客户端和服务端通信中的字符集"><a href="#客户端和服务端通信中的字符集" class="headerlink" title="客户端和服务端通信中的字符集"></a>客户端和服务端通信中的字符集</h3><h4 id="MySQL-中字符集的转换"><a href="#MySQL-中字符集的转换" class="headerlink" title="MySQL 中字符集的转换"></a>MySQL 中字符集的转换</h4><p>从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到 3 个系统变量</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_client</td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td>character_set_connection</td>
<td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td>
</tr>
<tr>
<td>character_set_results</td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody></table>
<p><img data-src="/images/db/MySQL/08.png" alt="img"></p>
<ul>
<li>服务器认为客户端发送过来的请求是用<code>character_set_client</code>编码的</li>
</ul>
<blockquote>
<p>假设你的客户端采用的字符集和 <em>character_set_client</em> 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_client</code>的值设置为<code>ascii</code>的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了</p>
</blockquote>
<ul>
<li>服务器将把得到的结果集使用<code>character_set_results</code>编码后发送给客户端</li>
</ul>
<blockquote>
<p>假设你的客户端采用的字符集和 <em>character_set_results</em> 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_results</code>的值设置为<code>ascii</code>的话，可能会产生乱码</p>
</blockquote>
<ul>
<li>通常都把 <em>character_set_client</em> 、<em>character_set_connection</em><strong>、<em>character_set_results</em></strong> 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，<code>MySQL</code>提供了一条非常简便的语句</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET NAMES 字符集名;</span><br></pre></td></tr></table></figure>

<ul>
<li>想在启动客户端的时候就把<code>character_set_client</code>、<code>character_set_connection</code>、<code>character_set_results</code>这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB-记录结构"><a href="#InnoDB-记录结构" class="headerlink" title="InnoDB 记录结构"></a>InnoDB 记录结构</h2><h3 id="InnoDB-页简介"><a href="#InnoDB-页简介" class="headerlink" title="InnoDB 页简介"></a>InnoDB 页简介</h3><p><code>InnoDB</code>是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB</code>存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，<code>InnoDB</code>采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 <em>16</em> KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。</p>
<h3 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h3><blockquote>
<p>记录在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code></p>
</blockquote>
<h4 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure>

<h4 id="COMPACT-行格式"><a href="#COMPACT-行格式" class="headerlink" title="COMPACT 行格式"></a>COMPACT 行格式</h4><p><img data-src="/images/db/MySQL/09.png" alt="img"></p>
<h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ul>
<li><p>变长字段长度列表</p>
<ul>
<li><p>各变长字段数据占用的字节数按照列的顺序逆序存放</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么需要逆序存放呢？</span><br><span class="line">因为对于数据页中的数据是通过单链表进行连接的，每条记录中头信息中包含next_record字段，此字段指向的是下一条记录的头信息和真实数据之间的位置上，这样向左读取就是记录头信息，向右读取就是真实数据，所以按顺序存放的字段和逆序存放的变长字段列表和NULL值列表就对上了，这样每个字段的值以及它的长度和NULL标识在内存中更近，这样的话可能会提高高速缓存的命中率</span><br></pre></td></tr></table></figure>
</li>
<li><p>变长字段长度列表中只存储值为 非 NULL 的列内容占用的长度，值为 <em>NULL</em> 的列的长度是不储存的</p>
</li>
<li><p>假设某个字符集中表示一个字符最多需要使用的字节数为<code>W</code>，对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<code>M</code>个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是<code>M×W</code>，<code>L</code> 表示实际存储占用的字节数</p>
<ul>
<li><code>M×W &lt;= 255</code>，那么使用 1 个字节来表示真正字符串占用的字节数</li>
<li><code>M×W &gt; 255 &amp;&amp; L &lt;= 127</code> 用 1 个字节来表示真正字符串占用的字节数</li>
<li><code>M×W &gt; 255 &amp;&amp; L &gt; 127</code>用 2 个字节来表示真正字符串占用的字节数</li>
<li>[疑问]为什么需要按👆🏻这种做法呢？？</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，</span><br><span class="line">该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？</span><br><span class="line">设计InnoDB的大佬使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，</span><br><span class="line">那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），</span><br><span class="line">如果该字节的第一个位为1，那该字节就是半个字段长度。对于一些占用字节数非常多的字段，</span><br><span class="line">比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，</span><br><span class="line">InnoDB会把一部分数据存放到所谓的溢出页中，</span><br><span class="line">在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。</span><br></pre></td></tr></table></figure>

<ul>
<li>NULL 值列表<ul>
<li>统计表中允许存储<code>NULL</code>的列，比如表中有三个列可以为空，那么 NULL 值列表就有 3 个二进制位存储当前这条数据对应字段是否为空</li>
<li>如果表中没有允许存储 <em>NULL</em> 的列，则 <em>NULL 值列表</em> 也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li>
<li><code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设A表中包含字段c1,c2,c3,c4  其中c2,c3,c4字段可以为空 那么能得到下面的结果</span><br><span class="line">1. NULL值列表只需要3个二进制位表示，只需要一个字段，00000C4C3C2 其中后面三位可以为1或者0</span><br><span class="line">2. 某条记录所有字段均不为空，那么NULL值列表中一个字节上对应所有的二进制位均为0</span><br><span class="line">3. 某条记录C3字段为空，对应的NULL值列表的二进制位是 00000010</span><br></pre></td></tr></table></figure>

<ul>
<li><p>记录头信息 </p>
<ul>
<li><p>用于描述记录的<code>记录头信息</code>，它是由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思</p>
</li>
<li><p><img data-src="/images/db/MySQL/10.png" alt="img"></p>
</li>
<li><table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数。就是该记录是page directory 中的一个slot，代表这个组内共有多少条记录数(包含自己这条记录)</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在本页的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
</li>
<li><p><code>delete_mask</code> 标记着当前记录是否被删除，占用 1 个二进制位，值为<code>0</code>的时候代表记录并没有被删除，为<code>1</code>的时候代表记录被删除掉了 </p>
<p>- </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>min_rec_mask</code> B+树的每层非叶子节点中的最小记录都会添加该标记</p>
</li>
<li><p><code>heap_no</code> 表示当前记录在本<code>页</code>中的位置，位置是从 2 开始，因为 0 和 1 被伪记录占据了，0 表示最小记录，1 表示最大记录，这两条伪记录不在页的 User Records 部分，被单独放在<a href="https://rq3nt70g815.feishu.cn/wiki/LCejwPlwqiofWbkDn86cotzPnfd#TyLUdGtCVoepiyx43A1c6zgXnNd"> Infimum + Supermum</a> 的部分</p>
</li>
<li><p><img data-src="/images/db/MySQL/11.png" alt="img"></p>
</li>
<li><p><code>next_record</code> 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。<code>下一条记录</code>指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 <em>Infimum 记录（也就是最小记录）</em> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <em>Supremum 记录（也就是最大记录）</em> ，为了更形象的表示一下这个<code>next_record</code>起到的作用，我们用箭头来替代一下<code>next_record</code>中的地址偏移量：</p>
<ul>
<li><img data-src="/images/db/MySQL/12.png" alt="img"></li>
<li><img data-src="/images/db/MySQL/13.png" alt="img"></li>
<li>第 2 条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为<code>1</code></li>
<li>第 2 条记录的<code>next_record</code>值变为了 0，意味着该记录没有下一条记录了</li>
<li>第 1 条记录的<code>next_record</code>指向了第 3 条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ul>
<li>隐藏列</li>
</ul>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id(DB_ROW_ID)</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id(DB_TRX_ID)</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer(DB_ROLL_PTR)</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，</span><br><span class="line">则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，</span><br><span class="line">则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CHAR（M） 列的存储格式</p>
<ul>
<li><p>当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表</p>
</li>
<li><p>采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表</p>
</li>
<li><p>变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求</p>
</li>
<li><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">比方说对于使用utf8字符集的<span class="type">CHAR</span>(<span class="number">10</span>)的列来说，该列存储的数据字节长度的范围是<span class="number">10</span>～<span class="number">30</span>个字节。</span><br><span class="line">即使我们向该列中存储一个空字符串也会占用<span class="number">10</span>个字节，这是怕将来更新该列的值的字节长度</span><br><span class="line">大于原有值的字节长度而小于<span class="number">10</span>个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，</span><br><span class="line">导致原有的记录空间成为所谓的碎片。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><h5 id="VARCHAR（M）最多能存储的数据"><a href="#VARCHAR（M）最多能存储的数据" class="headerlink" title="VARCHAR（M）最多能存储的数据"></a>VARCHAR（M）最多能存储的数据</h5><ul>
<li>一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节！</li>
<li>VARCHAR 类型需要占用 3 部分数据<ul>
<li>真实数据</li>
<li>真实数据占用字节的长度</li>
<li>NULL 值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li>
</ul>
</li>
<li>当 M 为 ascii 字符集时，一个字符表示一个字节，这样 VARCHAR（65535） 可用吗？不可用<ul>
<li>没有 NOT NULL，意味着 NULL 值标识需要占一个字节，长度需要占用两个字节，所以最多只能存储 65532 个字节的数据</li>
<li>有 NOT NULL，意味着额外只需要长度占用两个节点，所以最多存储 65533 个字节</li>
</ul>
</li>
<li>当 M 使用的不是<code>ascii</code>字符集，那<code>M</code>的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为<code>NULL</code>的情况下，<code>gbk</code>字符集表示一个字符最多需要<code>2</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>32766</code>（也就是：65532&#x2F;2），也就是说最多能存储<code>32766</code>个字符；<code>utf8</code>字符集表示一个字符最多需要<code>3</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>21844</code>，就是说最多能存储<code>21844</code>（也就是：65532&#x2F;3）个字符</li>
</ul>
<h5 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h5><ul>
<li><code>MySQL</code>是以<code>页</code>为基本单位来管理存储空间的，我们的记录都会被分配到某个<code>页</code>中存储。而一个页的大小一般是<code>16KB</code>，也就是<code>16384</code>字节</li>
<li>一个<code>VARCHAR(M)</code>类型的列就最多可以存储<code>65532</code>个字节，这样就可能造成一个页存放不了一条记录的尴尬情况</li>
<li>在<code>Compact</code>和<code>Reduntant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用 20 个字节存储指向这些页的地址（当然这 20 个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页</li>
</ul>
<p><img data-src="/images/db/MySQL/14.png" alt="img"></p>
<h5 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h5><ul>
<li><code>MySQL</code>中规定一个页中至少存放两行记录</li>
<li>每个页除了存放记录以外，也需要存储一些额外的信息，额外信息加起来需要<code>136</code>个字节的空间</li>
<li>每个记录需要的额外信息是<code>27</code>字节 （以下表示的都是表中只有一个列）<ul>
<li>2 个字节用于存储真实数据的长度</li>
<li>1 个字节用于存储列是否是 NULL 值</li>
<li>5 个字节大小的头信息</li>
<li>6 个字节的<code>row_id</code>列</li>
<li>6 个字节的<code>transaction_id</code>列</li>
<li>7 个字节的<code>roll_pointer</code>列</li>
</ul>
</li>
<li>在表中只有一个列的情况下，如果一个列中存储的数据不大于<code>8098</code>个字节，那就不会发生<code>行溢出</code>，否则就会发生<code>行溢出</code></li>
</ul>
<h4 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a><code>Dynamic</code>和<code>Compressed</code>行格式</h4><ul>
<li><code>MySQL</code>版本是<code>5.7</code>，它的默认行格式就是<code>Dynamic</code></li>
<li>和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</li>
</ul>
<p><img data-src="/images/db/MySQL/15.png" alt="img"></p>
<ul>
<li><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</li>
</ul>
<h2 id="InnoDB-数据页"><a href="#InnoDB-数据页" class="headerlink" title="InnoDB 数据页"></a>InnoDB 数据页</h2><p><img data-src="/images/db/MySQL/16.png" alt="img"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录，innoDB设计的最小记录和最大记录，最小记录和最大记录的heap_no分别是0和1</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><blockquote>
<p>在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有<code>User Records</code>这个部分，每当我们插入一条记录，都会从<code>Free Space</code>部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p>
</blockquote>
<p><img data-src="/images/db/MySQL/17.png" alt="img"></p>
<p><a href="https://rq3nt70g815.feishu.cn/wiki/Da7KwAdwOi3Ji3kYjU2clxF5n9f#SyksdUNdEoV959xpiTAcZLsAnOg">数据在页中按照主键值从小打到顺序串联成一个单链表</a></p>
<h3 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h3><ol>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。<ol>
<li><img data-src="/images/db/MySQL/18.png" alt="img"></li>
<li>innoDB 对于每个分组中的条数有以下规定<ul>
<li>于最小记录所在的分组只能有 <em>1</em> 条记录</li>
<li>最大记录所在的分组拥有的记录条数只能在 <em>1～8</em> 条之间</li>
<li>剩下的分组中记录的条数范围只能在是 <em>4～8</em> 条之间</li>
</ul>
</li>
<li>Page Derectory 构建步骤<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。</li>
<li>在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
</li>
<li><img data-src="/images/db/MySQL/19.png" alt="img"></li>
<li>如何从 Page Derectory 中查找记录<ul>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。（由于 slot 存储的是该组中最大的记录，所以可以找到上一个 slot，上一个 slot 的指向的 next record 就是当前 slot 中最小的记录）</li>
<li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Page-Header-数据页头部"><a href="#Page-Header-数据页头部" class="headerlink" title="Page Header 数据页头部"></a>Page Header 数据页头部</h3><table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2字节</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）可能是删除记录产生的空闲空间，也可能是页面末尾的未使用空间</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2字节</td>
<td>最后插入记录的位置。指向的是最后插入记录的起始位置，而不是记录的结束位置，所以不等于 free space。此字段是不考虑记录删除的，所以与PAGE_FREE相差巨大</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2字节</td>
<td>记录插入的方向。假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2字节</td>
<td>一个方向连续插入的记录数量。假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2字节</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10字节</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<h3 id="File-Header-文件头部"><a href="#File-Header-文件头部" class="headerlink" title="File Header 文件头部"></a>File Header 文件头部</h3><blockquote>
<p><code>File Header</code>针对各种类型的页都通用，也就是说不同类型的页都会以<code>File Header</code>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4字节</td>
<td>页的校验和（checksum值） 代表当前页面的校验和（checksum）。什么是个校验和？就是对于一个很长很长的字节串来说，通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4字节</td>
<td>页号 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4字节</td>
<td>上一个页的页号，双向链表</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8字节</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<ul>
<li><code>FIL_PAGE_TYPE</code></li>
</ul>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>BLOB页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的数据页</td>
</tr>
</tbody></table>
<ul>
<li><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code></li>
</ul>
<blockquote>
<p><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性。</p>
</blockquote>
<p><img data-src="/images/db/MySQL/20.png" alt="img"></p>
<h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><blockquote>
<p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况）。因为可能断电导致内存中的页只有一部分刷新到了磁盘，所以需要通过这个来判断一个页是否完整。这个部分由 8 个字节组成</p>
</blockquote>
<ul>
<li>前 4 个字节代表页的校验和</li>
</ul>
<p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前面，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trialer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p>
<ul>
<li>后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）</li>
</ul>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><ul>
<li><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95">快速查询的秘籍-B+树索引</a></li>
</ul>
<p><img data-src="/images/db/MySQL/21.png" alt="img"></p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><blockquote>
<p>在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引</p>
</blockquote>
<ol>
<li>页内的记录是按照主键的大小顺序排成一个单向链表</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表</li>
<li><code>B+</code>树的叶子节点存储的是完整的用户记录</li>
</ol>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p><img data-src="/images/db/MySQL/22.png" alt="img"></p>
<ul>
<li>页内的记录是按照二级索引对应的列的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的二级索引对应的列大小顺序排成一个双向链表</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的二级索引对应的列大小顺序排成一个双向链表</li>
<li><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>二级索引对应的列+主键</code>这两个列的值</li>
<li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>二级索引对应的列``+页号</code>的搭配</li>
<li>如果我们想根据<code>二级索引对应的列</code>的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程也被称为<code>回表</code></li>
<li>二级索引的内节点的目录项记录的内容由三部分构成，这样才能保证同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><img data-src="/images/db/MySQL/23.png" alt="img"></p>
<ul>
<li>先把各个记录和页按照<code>c2</code>列进行排序。</li>
<li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li>
</ul>
<h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><h4 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h4><ul>
<li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li>
<li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li>
<li>一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</li>
</ul>
<h4 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h4><blockquote>
<p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是什么效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以<code>InnoDB</code>的一个数据页至少可以存放两条记录</p>
</blockquote>
<h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><h4 id="空间上的代价"><a href="#空间上的代价" class="headerlink" title="空间上的代价"></a>空间上的代价</h4><blockquote>
<p>每建立一个索引都要为它建立一棵<code>B+</code>树，每一棵<code>B+</code>树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的<code>B+</code>树由许多数据页组成，那可是很大的一片存储空间呢</p>
</blockquote>
<h4 id="时间上的代价"><a href="#时间上的代价" class="headerlink" title="时间上的代价"></a>时间上的代价</h4><blockquote>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个<code>B+</code>树索引。<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收什么的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的<code>B+</code>树都要进行相关的维护操作，这还能不给性能拖后腿么?</p>
</blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。</p>
<h3 id="B-树索引的适用条件"><a href="#B-树索引的适用条件" class="headerlink" title="B+树索引的适用条件"></a>B+树索引的适用条件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span> auto_increment,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/db/MySQL/24.png" alt="img"></p>
<ul>
<li>先按照<code>name</code>列的值进行排序。</li>
<li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li>
<li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li>
</ul>
<h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><blockquote>
<p>搜索条件中的列和索引列一致的话</p>
</blockquote>
<p>比如👇🏻这个搜索sql，搜索条件与索引列完全一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">=</span> <span class="string">&#x27;15123983239&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h4><blockquote>
<p>搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行</p>
</blockquote>
<h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><h4 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h4><blockquote>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&lt;</span> <span class="string">&#x27;2000-12-31&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">&gt;</span> <span class="string">&#x27;15100000000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、等等排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。</p>
<h5 id="使用联合索引进行排序注意事项"><a href="#使用联合索引进行排序注意事项" class="headerlink" title="使用联合索引进行排序注意事项"></a>使用联合索引进行排序注意事项</h5><ul>
<li><code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出</li>
<li><code>ORDER BY name</code>、<code>ORDER BY name, birthday</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h5 id="不可以使用索引进行排序的几种情况"><a href="#不可以使用索引进行排序的几种情况" class="headerlink" title="不可以使用索引进行排序的几种情况"></a>不可以使用索引进行排序的几种情况</h5><ol>
<li>ASC、DESC混用</li>
</ol>
<blockquote>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序，如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。</p>
</blockquote>
<ol>
<li>WHERE子句中出现非排序使用到的索引列</li>
<li>排序列包含非同一个索引的条件</li>
<li>排序列使用了复杂的表达式，比如函数等</li>
</ol>
<h4 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h4><blockquote>
<p>没有索引的话，这个分组过程全部需要在内存里实现</p>
</blockquote>
<h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>一般来说二级索引查询的数据在磁盘中的存储是相连的，集中分布在一个或几个数据页中，所以是顺序IO，但是回表的时候对应的ID可能分配在不同的页上，这时候读取就是随机IO，顺序IO相比于随机IO性能高的多，所以需要回表的记录越多，使用二级索引的性能就越低</p>
<ul>
<li>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code></li>
<li>需要回表的记录越多，使用二级索引的性能就越低</li>
<li>回表数据量过大可能导致不使用二级索引，而是遍历聚簇索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number;</span><br></pre></td></tr></table></figure>

<p>比如👆🏻这个例子中，由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>但是如果增加了limit子句，需要回表的数据</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka-consumer</title>
    <url>/2025/02/09/xiao-xi-dui-lie/kafka/consumer/posts/undefined/</url>
    <content><![CDATA[<h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">默认值</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>bootstrap.servers</strong></td>
<td align="left"></td>
<td align="left">Kafka broker 地址</td>
<td align="left"><code>*properties*.put(ProducerConfig.*BOOTSTRAP_SERVERS_CONFIG*, *brokerList*);</code></td>
</tr>
<tr>
<td align="left"><strong>key.deserializer</strong></td>
<td align="left"></td>
<td align="left">Key 反序列化 实现 Deserializer 接口</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*KEY_DESERIALIZER_CLASS_CONFIG*, StringDeserializer.class.getName());</code></td>
</tr>
<tr>
<td align="left"><strong>value.deserializer</strong></td>
<td align="left"></td>
<td align="left">Value 反序列化实现 Deserializer 接口</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*VALUE_DESERIALIZER_CLASS_CONFIG*, StringDeserializer.class.getName());</code></td>
</tr>
<tr>
<td align="left"><strong>group.id</strong></td>
<td align="left"></td>
<td align="left">消费组 ID</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*GROUP_ID_CONFIG*, *groupId*);</code></td>
</tr>
<tr>
<td align="left"><strong>enable.auto.commit</strong></td>
<td align="left">true</td>
<td align="left">是否开启自动提交默认为 true</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*ENABLE_AUTO_COMMIT_CONFIG*, false);</code></td>
</tr>
<tr>
<td align="left"><strong>auto.commit.interval.ms</strong></td>
<td align="left">5000</td>
<td align="left">自动提交间隔时间，只有在 enable.auto.commit 设置为 true 时生效，默认是 5s! ! offset 提交时间点&#x3D;max（单次 poll 时间， auto.commit.interval.ms）</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*AUTO_COMMIT_INTERVAL_MS_CONFIG*, 5000);</code></td>
</tr>
<tr>
<td align="left"><strong>auto.offset.reset</strong></td>
<td align="left">latest</td>
<td align="left">从最早的消息开始消费 默认是 latest，此参数表示当前消费组在没有 offset 的情况下，从哪里开始消费这里的没有 offset 指的是消费组第一次消费或者_consumer_offsets 主题中没有当前消费组的 offset! ! 建议设置为 earliest，否则扩分区时，新增加的消费者可能丢失新分区产生的数据；设置为 earliest 时业务上需要做好幂等处理</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*AUTO_OFFSET_RESET_CONFIG*, &quot;earliest&quot;);</code></td>
</tr>
<tr>
<td align="left"><strong>max.poll.records</strong></td>
<td align="left">500</td>
<td align="left">一次拉取请求中拉取的最大消息数量 默认是 500 条! ! 建议调整此参数，业务处理时间超过 max.poll.interval.ms 会导致 rebalance，所以这里的单次拉取的数据量需要考虑处理时间；max.poll.records &lt; max.poll.interval.ms &#x2F; 单条消息处理时间</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*MAX_POLL_RECORDS_CONFIG*, 500);</code></td>
</tr>
<tr>
<td align="left"><strong>max.poll.interval.ms</strong></td>
<td align="left">5 * 60 * 1000</td>
<td align="left">拉取消息线程最长空闲时间，默认是 5 分钟，若超过这个间隔还没有发起 poll 请求，消费者会认为消费者挂掉了，然后触发 rebalance因为 poll 方法还涉及业务处理，所以如果业务处理时间过长，那么需要适当增大此值，或者减少单次拉取的消息数量! ! 如果业务处理时间较长，一定要增加此配置，否则会导致 rebalance</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*MAX_POLL_INTERVAL_MS_CONFIG*, 5 * 60 * 1000);</code></td>
</tr>
<tr>
<td align="left"><strong>heartbeat.interval.ms</strong></td>
<td align="left">3 * 1000</td>
<td align="left">配置消费者的最大心跳间隔时间，默认是 3s心跳间隔时间是指消费者发送心跳给 broker 的时间间隔必须比 session.timeout.ms 小，一般是 session.timeout.ms 的 1&#x2F;3</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*HEARTBEAT_INTERVAL_MS_CONFIG*, 3 * 1000);</code></td>
</tr>
<tr>
<td align="left"><strong>session.timeout.ms</strong></td>
<td align="left">10 * 1000</td>
<td align="left">配置消费者与 broker 的会话超时时间，默认是 10s超过此时间 broker 没有收到消费者的心跳，那么 broker 会认为消费者挂掉了，然后触发 rebalance! ! 此参数不能配置过大！！</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">fetch.max.bytes</td>
<td align="left">50 * 1024 * 1024</td>
<td align="left">一次请求从 kafka 中拉取的最大数据量，默认是 50M，此参数不是绝对的最大值，如果一条消息的大小比此参数还大，那么一次请求也会拉取这条消息</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*FETCH_MAX_BYTES_CONFIG*, ConsumerConfig.*DEFAULT_FETCH_MAX_BYTES*);</code></td>
</tr>
<tr>
<td align="left">max.partition.fetch.bytes</td>
<td align="left">1 * 1024 * 1024</td>
<td align="left">一次请求从 kafka 中拉取单个分区的最大数据量，默认是 1M</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*MAX_PARTITION_FETCH_BYTES_CONFIG*, ConsumerConfig.*DEFAULT_MAX_PARTITION_FETCH_BYTES*);</code></td>
</tr>
<tr>
<td align="left">connections.max.idle.ms</td>
<td align="left">9 * 60 * 1000</td>
<td align="left">指定多久之后关闭闲置的连接，默认是 9 分钟</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*CONNECTIONS_MAX_IDLE_MS_CONFIG*, 9 * 60 * 1000);</code></td>
</tr>
<tr>
<td align="left">receive.buffer.bytes</td>
<td align="left">64 * 1024</td>
<td align="left">设置 socket 接收消息缓冲区（SO_RCVBUF）的大小，默认是 64KB，如果设置为 -1，那么使用操作系统的默认值，如果 Consumer 与 Kafka 处于不同的数据中心，那么可以适当增大此值</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*RECEIVE_BUFFER_CONFIG*, 64 * 1024);</code></td>
</tr>
<tr>
<td align="left">send.buffer.bytes</td>
<td align="left">128 * 1024</td>
<td align="left">设置 socket 发送消息缓冲区（SO_SNDBUF）的大小，默认是 128KB，如果设置为 -1，那么使用操作系统的默认值，如果 Consumer 与 Kafka 处于不同的数据中心，那么可以适当增大此值</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*SEND_BUFFER_CONFIG*, 128 * 1024);</code></td>
</tr>
<tr>
<td align="left">request.timeout.ms</td>
<td align="left">30 * 1000</td>
<td align="left">配置 consumer 等待请求响应的最大时间，默认是 30s</td>
<td align="left"><code>*properties*.put(ConsumerConfig.*REQUEST_TIMEOUT_MS_CONFIG*, 30 * 1000);</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交，默认是自动提交，间隔是5s</span></span><br><span class="line">    <span class="comment">// properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);</span></span><br><span class="line">    <span class="comment">// properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 5000);</span></span><br><span class="line">    <span class="comment">// 调整为手动提交</span></span><br><span class="line">    properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 自动提交间隔时间，只有在enable.auto.commit设置为true时生效，默认是5s</span></span><br><span class="line">    properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最早的消息开始消费 默认是latest，此参数表示当前消费组在没有offset的情况下，从哪里开始消费</span></span><br><span class="line">    <span class="comment">// 这里的没有offset指的是消费组第一次消费或者_consumer_offsets主题中没有当前消费组的offset</span></span><br><span class="line">    properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次请求从kafka中拉取的最大数据量，默认是50M，此参数不是绝对的最大值，如果一条消息的大小比此参数还大，那么一次请求也会拉取这条消息</span></span><br><span class="line">    properties.put(ConsumerConfig.FETCH_MAX_BYTES_CONFIG, ConsumerConfig.DEFAULT_FETCH_MAX_BYTES);</span><br><span class="line">    <span class="comment">// 一次请求从kafka中拉取单个分区的最大数据量，默认是1M</span></span><br><span class="line">    properties.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, ConsumerConfig.DEFAULT_MAX_PARTITION_FETCH_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次拉取请求中拉取的最大消息数量 默认是500条</span></span><br><span class="line">    properties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定多久之后关闭闲置的连接，默认是9分钟</span></span><br><span class="line">    properties.put(ConsumerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG, <span class="number">9</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket接收消息缓冲区(SO_RCVBUF)的大小，默认是64KB，如果设置为-1，那么使用操作系统的默认值，如果Consumer与Kafka处于不同的数据中心，那么可以适当增大此值</span></span><br><span class="line">    properties.put(ConsumerConfig.RECEIVE_BUFFER_CONFIG, <span class="number">64</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 设置socket发送消息缓冲区(SO_SNDBUF)的大小，默认是128KB，如果设置为-1，那么使用操作系统的默认值，如果Consumer与Kafka处于不同的数据中心，那么可以适当增大此值</span></span><br><span class="line">    properties.put(ConsumerConfig.SEND_BUFFER_CONFIG, <span class="number">128</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置consumer等待请求响应的最大时间，默认是30s</span></span><br><span class="line">    properties.put(ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo-wl 配置消费者的事务隔离级别</span></span><br><span class="line">    <span class="comment">// properties.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, &quot;read_committed&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !! 配置消费者的最大心跳间隔时间，默认是3s</span></span><br><span class="line">    <span class="comment">// 心跳间隔时间是指消费者发送心跳给broker的时间间隔</span></span><br><span class="line">    <span class="comment">// 必须比session.timeout.ms小，一般是session.timeout.ms的1/3</span></span><br><span class="line">    properties.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// !! 配置消费者与broker的会话超时时间，默认是10s</span></span><br><span class="line">    <span class="comment">// 超过此时间broker没有收到消费者的心跳，那么broker会认为消费者挂掉了，然后触发rebalance</span></span><br><span class="line">    properties.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !! 拉取消息线程最长空闲时间，默认是5分钟，若超过这个间隔还没有发起poll请求，消费者会认为消费者挂掉了，然后触发rebalance</span></span><br><span class="line">    <span class="comment">// 因为poll方法还涉及业务处理，所以如果业务处理时间过长，那么需要适当增大此值，或者减少单次拉取的消息数量</span></span><br><span class="line">    properties.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-rebalance"><a href="#Kafka-rebalance" class="headerlink" title="Kafka-rebalance"></a>Kafka-rebalance</h2><ul>
<li><a href="https://redpanda.com/guides/kafka-performance/kafka-rebalancing">kafka-rebalancing</a></li>
<li>发生再平衡的场景<ul>
<li>消费者加入或离开</li>
<li>消费者遇到暂时故障或网络中断</li>
<li>消费者闲置时间过长</li>
<li>扩大了主题分区</li>
</ul>
</li>
<li>再平衡的副作用<ul>
<li>延迟增加</li>
<li>吞吐量降低</li>
<li>资源使用量增加</li>
<li>潜在的数据重复和丢失</li>
<li>复杂性增加</li>
</ul>
</li>
<li>减少再平衡的措施<ul>
<li>增加会话超时时间 session.timeout.ms，此参数不能设置太高，不然导致消费者长时间不活动进而导致消息堆积；heartbeat.interval.ms 此参数</li>
<li>​       需要小于 session.timeout.ms，一般是 1&#x2F;3</li>
<li>减少每个主题的分区，每个主题的分区过多会增加重新平衡的频率</li>
<li>增加轮训间隔时间，max.poll.interval.ms 配置规定了消费者被视为非活动并从组中移除前的最长空闲时间，增加此时间助于避免消费者组的频繁更改</li>
</ul>
</li>
<li>增量合作再平衡<ul>
<li>Kafka 2.4 中引入了增量合作再平衡协议，以最大程度地减少 Kafka 再平衡造成的中断。在传统的再平衡中，组中的所有消费者在重新平衡过程中停止使用数据，通常称为“停止世界效应”。这会导致数据处理延迟和中断。</li>
<li>增量合作再平衡协议将再平衡拆分为更小的子任务，消费者在这些子任务完成后继续使用数据。因此，重新平衡发生得更快，对数据处理的中断更少。</li>
<li>该协议还为再平衡过程提供了更精细的控制。例如，它允许使用者根据其当前负载和容量协商他们将使用的特定分区集。这可以防止单个使用者的过载，并确保以更平衡的方式分配分区。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>中间件</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka-producer</title>
    <url>/2025/02/09/xiao-xi-dui-lie/kafka/producer/posts/undefined/</url>
    <content><![CDATA[<h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">默认值</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>bootstrap.servers</strong></td>
<td align="left"></td>
<td align="left">Kafka broker 地址</td>
<td align="left"><code>*properties*.put(ProducerConfig.*BOOTSTRAP_SERVERS_CONFIG*, *brokerList*);</code></td>
</tr>
<tr>
<td align="left"><strong>key.serializer</strong></td>
<td align="left"></td>
<td align="left">Key 序列化器实现 Serializer 接口</td>
<td align="left"><code>*properties*.put(ProducerConfig.*KEY_SERIALIZER_CLASS_CONFIG*, StringSerializer.class.getName());</code></td>
</tr>
<tr>
<td align="left"><strong>value.serializer</strong></td>
<td align="left"></td>
<td align="left">Value 序列化器实现 Serializer 接口</td>
<td align="left"><code>*properties*.put(ProducerConfig.*VALUE_SERIALIZER_CLASS_CONFIG*, StringSerializer.class.getName());</code></td>
</tr>
<tr>
<td align="left"><strong>acks</strong></td>
<td align="left">1</td>
<td align="left">指定分区中必须有多少个副本收到消息，生产者才认为消息写入成功，默认 1acks&#x3D;1 生产者发送消息到分区 leader，leader 将消息写入本地日志后即返回成功acks&#x3D;0 生产者发送消息到分区 leader，不等待 leader 写入本地日志，直接返回成功acks&#x3D;all&#x2F;acks&#x3D;-1 生产者发送消息到分区 leader，leader 将消息写入本地日志后，等待 ISR 中所有副本都写入成功后才返回成功 acks&#x3D;all 等价于 acks&#x3D;-1 并不一定最可靠，因为 ISR 中的副本可能会因为各种原因不可用，导致 ISR 副本只有 leader 节点一个，如果需要获得更高的可靠性，需要配置 min.insync.replicas 参数（broker 参数，建议配置大于 1 &amp; 小于副本数量），此参数表示 ISR 中至少有多少个副本是可用的</td>
<td align="left"><code>*properties*.put(ProducerConfig.*ACKS_CONFIG*, &quot;all&quot;);</code></td>
</tr>
<tr>
<td align="left"><strong>retries</strong></td>
<td align="left"></td>
<td align="left">配置重试次数，重试次数只限制于可重试的异常，不可重试的异常此参数无意义</td>
<td align="left"><code>*properties*.put(ProducerConfig.*RETRIES_CONFIG*, 10);</code></td>
</tr>
<tr>
<td align="left"><strong>retry.backoff.ms</strong></td>
<td align="left"></td>
<td align="left">重试的时间间隔</td>
<td align="left"><code>*properties*.put(ProducerConfig.*RETRY_BACKOFF_MS_CONFIG*, 100);</code></td>
</tr>
<tr>
<td align="left"><strong>max.in.flight.requests.per.connection</strong></td>
<td align="left">5</td>
<td align="left">配置单个连接最大缓存请求数量，发送的请求 ProducerBatch 会缓存到 InFlightRequests 中，此参数限制 InFlightRequests 的大小，默认 5，即每个连接最多只能缓存 5 个未响应的请求</td>
<td align="left"><code>*properties*.put(ProducerConfig.*MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION*, 5);</code></td>
</tr>
<tr>
<td align="left">request.timeout.ms</td>
<td align="left">30 * 1000</td>
<td align="left">Producer 等待请求响应的最长时间，默认 30s，如果在 30s 内没有收到响应，那么会重发消息这个参数需要比 broker 端的参数 replica.lag.time.max.ms（Follower 副本能够落后 Leader 副本的最长时间间隔，默认值是 10 秒）大，否则可能会出现消息丢失</td>
<td align="left"><code>*properties*.put(ProducerConfig.*REQUEST_TIMEOUT_MS_CONFIG*, 30 * 1000);</code></td>
</tr>
<tr>
<td align="left">linger.ms</td>
<td align="left">0</td>
<td align="left">指定生产者发送 ProducerBatch 之前等待更多消息加入到 ProducerBatch 的时间，默认 0，即立即发送，这个参数与 TCP 的 Nagle 算法类似</td>
<td align="left"><code>*properties*.put(ProducerConfig.*LINGER_MS_CONFIG*, 0);</code></td>
</tr>
<tr>
<td align="left">send.buffer.bytes</td>
<td align="left">128 * 1024</td>
<td align="left">设置 socket 发送缓冲区大小，默认 128k，如果设置为 -1，那么使用操作系统默认的大小</td>
<td align="left"><code>*properties*.put(ProducerConfig.*SEND_BUFFER_CONFIG*, 128 * 1024);</code></td>
</tr>
<tr>
<td align="left">interceptor.classes</td>
<td align="left"></td>
<td align="left">消息发送拦截器消息发送到 broker 之前拦截，可修改消息内容实现 ProducerInterceptor 接口</td>
<td align="left"><code>*properties*.put(ProducerConfig.*INTERCEPTOR_CLASSES_CONFIG*, ProducerInterceptorPrefix.class.getName());</code></td>
</tr>
<tr>
<td align="left">buffer.memory</td>
<td align="left">32 * 1024 * 1024</td>
<td align="left">缓存消息大小生产者主线程会将消息缓存到 RecordAccumulator 中，然后由 Sender 线程发送到 Kafka，这里的参数是 RecordAccumulator 的缓存大小，默认 32M</td>
<td align="left"><code>// 缓存消息大小，生产者主线程会将消息缓存到RecordAccumulator中，然后由Sender线程发送到Kafka，这里的参数是RecordAccumulator的缓存大小，默认32M *properties*.put(ProducerConfig.*BUFFER_MEMORY_CONFIG*, 32 * 1024 * 1024L);</code></td>
</tr>
<tr>
<td align="left">max.block.ms</td>
<td align="left">60 * 1000</td>
<td align="left">RecordAccumulator 缓存空间不足时，最大阻塞时间，默认 60s</td>
<td align="left"><code>// RecordAccumulator缓存空间不足时，最大阻塞时间，默认60s *properties*.put(ProducerConfig.*MAX_BLOCK_MS_CONFIG*, 60 * 1000);</code></td>
</tr>
<tr>
<td align="left">batch.size</td>
<td align="left">16 * 1024</td>
<td align="left">单次发送消息大小，kafka 会将消息组装为 ProducerBatch，此参数影响 ProducerBatch 的大小，如果消息小于此参数，则会通过 BufferPool 进行复用，默认 16k</td>
<td align="left"><code>*properties*.put(ProducerConfig.*BATCH_SIZE_CONFIG*, 16 * 1024);</code></td>
</tr>
<tr>
<td align="left">max.request.size</td>
<td align="left">1024 * 1024</td>
<td align="left">客户端能发送消息的最大值，默认 1M，不建议修改这个值，因为涉及到 broker 端的参数客户端能发送消息的最大值，默认 1M，不建议修改这个值，因为涉及到 broker 端的参数</td>
<td align="left"><code>*properties*.put(ProducerConfig.*MAX_REQUEST_SIZE_CONFIG*, 1024 * 1024);</code></td>
</tr>
<tr>
<td align="left">compression.type</td>
<td align="left">none</td>
<td align="left">消息压缩方式，默认是 none，支持 none、gzip、snappy、lz4，如果需要提升吞吐量，可以开启消息压缩</td>
<td align="left"><code>*properties*.put(ProducerConfig.*COMPRESSION_TYPE_CONFIG*, &quot;none&quot;);</code></td>
</tr>
<tr>
<td align="left">connections.max.idle.ms</td>
<td align="left">9 * 60 * 1000</td>
<td align="left">关闭闲置的连接，默认 9 分钟，如果生产者在 9 分钟内没有发送消息，那么生产者会关闭连接，如果生产者在 9 分钟内发送消息，那么生产者会重置闲置时间</td>
<td align="left"><code>*properties*.put(ProducerConfig.*CONNECTIONS_MAX_IDLE_MS_CONFIG*, 9 * 60 * 1000);</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">    properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送拦截器</span></span><br><span class="line">    properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, ProducerInterceptorPrefix.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者发送配置</span></span><br><span class="line">    <span class="comment">// 缓存消息大小，生产者主线程会将消息缓存到RecordAccumulator中，然后由Sender线程发送到Kafka，这里的参数是RecordAccumulator的缓存大小，默认32M</span></span><br><span class="line">    properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024L</span>);</span><br><span class="line">    <span class="comment">// RecordAccumulator缓存空间不足时，最大阻塞时间，默认60s</span></span><br><span class="line">    properties.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 单次发送消息大小，kafka会将消息组装为ProducerBatch，此参数影响ProducerBatch的大小，如果消息小于此参数，则会通过pBufferPool进行复用，默认16k</span></span><br><span class="line">    properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 配置单个连接最大缓存请求数量，发送的请求ProducerBatch会缓存到InFlightRequests中，此参数限制InFlightRequests的大小，默认5，即每个连接最多只能缓存5个未响应的请求</span></span><br><span class="line">    properties.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要的生产者参数</span></span><br><span class="line">    <span class="comment">// 指定分区中必须有多少个副本收到消息，生产者才认为消息写入成功，默认1</span></span><br><span class="line">    <span class="comment">// acks=1 生产者发送消息到分区leader，leader将消息写入本地日志后即返回成功</span></span><br><span class="line">    <span class="comment">// acks=0 生产者发送消息到分区leader，不等待leader写入本地日志，直接返回成功</span></span><br><span class="line">    <span class="comment">// acks=all/acks=-1 生产者发送消息到分区leader，leader将消息写入本地日志后，等待ISR中所有副本都写入成功后才返回成功</span></span><br><span class="line">    <span class="comment">// acks=all 等价于 acks=-1 并不一定最可靠，因为ISR中的副本可能会因为各种原因不可用，导致ISR副本只有leader节点一个，如果需要获得更高的可靠性，需要配置 min.insync.replicas 参数，此参数表示ISR中至少有多少个副本是可用的</span></span><br><span class="line">    properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端能发送消息的最大值，默认1M，不建议修改这个值，因为涉及到broker端的参数</span></span><br><span class="line">    <span class="comment">// 此参数表示单次网络请求的大小，这次请求中可能包含很多个ProducerBatch</span></span><br><span class="line">    properties.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 指定生产者发送ProducerBatch之前等待更多消息加入到ProducerBatch的时间，默认0，即立即发送，这个参数与TCP的Nagle算法类似</span></span><br><span class="line">    properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置socket发送缓冲区大小，默认128k，如果设置为-1，那么使用操作系统默认的大小</span></span><br><span class="line">    properties.put(ProducerConfig.SEND_BUFFER_CONFIG, <span class="number">128</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// Producer等待氢气响应的最长时间，默认30s，如果在30s内没有收到响应，那么会重发消息</span></span><br><span class="line">    <span class="comment">// 这个参数需要比broker端的参数replica.lag.time.max.ms（Follower 副本能够落后 Leader 副本的最长时间间隔，默认值是 10 秒）大，否则可能会出现消息丢失</span></span><br><span class="line">    properties.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置重试次数，重试次数只限制于可重试的异常，不可重试的异常此参数无意义</span></span><br><span class="line">    properties.put(ProducerConfig.RETRIES_CONFIG, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 重试的时间间隔</span></span><br><span class="line">    properties.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 某些场景下消息的顺序是非常重要的，如果retry重试次数设置大于0 &amp; max.in.flight.requests.per.connection &gt; 1，那么可能会导致消息乱序</span></span><br><span class="line">    <span class="comment">// 比如第一批次消息发送失败，第二批次消息发送成功，第一批次消息重试发送成功，那么第一批次消息就会出现在第二批次消息之后</span></span><br><span class="line">    <span class="comment">// 建议如果需要保证消息的顺序，那么将max.in.flight.requests.per.connection设置为1，而不是设置重试次数为0，不过这样会导致吞吐量下降</span></span><br><span class="line">    <span class="comment">// ? todo-wl 如果重试次数=0，max.in.flight.requests.per.connection&gt;1，怎么保证消息是有序的？</span></span><br><span class="line">    <span class="comment">// -&gt; 因为单次网络包可能包含多个ProducerBatch，kafka在处理的时候会将多个ProducerBatch合并为一个请求，同时对于同一个分区的消息，kafka会保证消息的顺序，所以能保证消息是有序的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息压缩方式，默认是none，支持none、gzip、snappy、lz4，如果需要提升吞吐量，可以开启消息压缩</span></span><br><span class="line">    properties.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, <span class="string">&quot;none&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭闲置的连接，默认9分钟，如果生产者在9分钟内没有发送消息，那么生产者会关闭连接，如果生产者在9分钟内发送消息，那么生产者会重置闲置时间</span></span><br><span class="line">    properties.put(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG, <span class="number">9</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等性配置</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 开启幂等性</span></span><br><span class="line">    properties.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 幂等的原理是消费者会被分配一个pid，pid是一个递增的序列号，生产者每发送一条消息就会将&lt;PID,分区&gt;对应的序列号+1</span></span><br><span class="line">    <span class="comment">// 当发送消息时，会将seq发送到broker，broker内存中保存&lt;PID,分区&gt;对应的序列号，如果seq大于broker中的序列号+1，那么broker会将消息写入日志，然后更新序列号</span></span><br><span class="line">    <span class="comment">// 如果seq小于broker中的序列号+1，那么broker会直接返回成功，不会写入日志</span></span><br><span class="line">    <span class="comment">// 如果seq大于broker中的序列号+1，那么broker会返回错误</span></span><br><span class="line">    <span class="comment">// !! Kafka幂等只保证单个生产者会话(session)中单个分区内的幂等性，不保证多个分区之间的幂等性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有配置以下配置，只需要配置上面的配置即可</span></span><br><span class="line">    <span class="comment">// retry重试次数必须大于0</span></span><br><span class="line">    properties.put(ProducerConfig.RETRIES_CONFIG, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// acks 必须是 all</span></span><br><span class="line">    properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">    <span class="comment">// max.in.flight.requests.per.connection 不能大于5</span></span><br><span class="line">    properties.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务配置</span></span><br><span class="line"><span class="comment">// 幂等性不能跨分区，如果需要跨分区的幂等性，那么需要使用事务</span></span><br><span class="line"><span class="comment">// 事务可以保证对多个分区写入操作的原子性</span></span><br><span class="line"><span class="comment">// kafka中的事务可以使应用程序将消费消息、生产消息、提交消费位移当做原子操作来处理，同时成功或失败</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 必须提供唯一的transactional.id，如果transactional.id相同，那么会认为是同一个事务</span></span><br><span class="line">    <span class="comment">// 显示设置</span></span><br><span class="line">    properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">&quot;transactional-id&quot;</span>);</span><br><span class="line">    <span class="comment">// ！！事务要求生产者开启幂等性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h2><ul>
<li><strong>retries</strong> &gt; 0 &amp; <strong>max.in.flight.requests.per.connection</strong> &#x3D; 1</li>
</ul>
<p>​      推荐使用此方式，一定程度上能保证消息不丢失，但是会导致吞吐量下降；</p>
<ul>
<li><strong>retries</strong> &#x3D; 0 &amp; <strong>max.in.flight.requests.per.connection</strong> &gt; 1</li>
</ul>
<p>NetworkClient:</p>
<p><img data-src="/images/message/kafka/01.png" alt="img"></p>
<p>​      </p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>中间件</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>pulsar-使用</title>
    <url>/2025/02/09/xiao-xi-dui-lie/pulsar/shi-yong/posts/undefined/</url>
    <content><![CDATA[<h2 id="创建使用"><a href="#创建使用" class="headerlink" title="创建使用"></a>创建使用</h2><ul>
<li>docker 单机创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">    -p 6650:6650 \</span><br><span class="line">    -p 8650:8080 \</span><br><span class="line">    -v /Users/wulei/devTools/pulsar/data:/pulsar/data \</span><br><span class="line">    --name pulsar-standalone \</span><br><span class="line">    apachepulsar/pulsar:latest \</span><br><span class="line">    bin/pulsar standalone</span><br></pre></td></tr></table></figure>

<ul>
<li>可视化 pulsar-manager</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull apachepulsar/pulsar-manager:v0.3.0</span><br><span class="line">docker run -d -it \</span><br><span class="line">    -p 9527:9527 -p 7750:7750 \</span><br><span class="line">    -e SPRING_CONFIGURATION_FILE=/pulsar-manager/pulsar-manager/application.properties \</span><br><span class="line">    --<span class="built_in">link</span> pulsar-standalone \</span><br><span class="line">    --name pulsar-manager\</span><br><span class="line">    apachepulsar/pulsar-manager:v0.3.0</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 pulsar-manager admin 用户，用户名： admin 密码： apachepulsar</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CSRF_TOKEN=$(curl http://localhost:7750/pulsar-manager/csrf-token)</span><br><span class="line">curl \</span><br><span class="line">   -H <span class="string">&#x27;X-XSRF-TOKEN: $CSRF_TOKEN&#x27;</span> \</span><br><span class="line">   -H <span class="string">&#x27;Cookie: XSRF-TOKEN=$CSRF_TOKEN;&#x27;</span> \</span><br><span class="line">   -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">   -X PUT http://localhost:7750/pulsar-manager/users/superuser \</span><br><span class="line">   -d <span class="string">&#x27;&#123;&quot;name&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;apachepulsar&quot;, &quot;description&quot;: &quot;test&quot;, &quot;email&quot;: &quot;username@test.org&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Pulsar-manager 连接 pulsar 集群，注意使用容器名称+容器内部端口进行连接</li>
</ul>
<p><img data-src="/images/message/pulsar/01.PNG" alt="img"></p>
<ul>
<li>创建租户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/pulsar-admin tenants create lei-learn</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 namespace</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/pulsar-admin namespaces create lei-learn/dev</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 topic</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/pulsar-admin topics create persistent://lei-learn/dev/string</span><br><span class="line"><span class="comment"># 创建5个分区的topic</span></span><br><span class="line">/bin/pulsar-admin topics create-partitioned-topic -p 5 persistent://lei-learn/dev/string</span><br></pre></td></tr></table></figure>

<ul>
<li>显示某个 namespace 下的 topic</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/pulsar-admin topics list lei-learn/dev/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>中间件</tag>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-kafka</title>
    <url>/2025/02/09/xiao-xi-dui-lie/kafka/spring-kakfa/posts/undefined/</url>
    <content><![CDATA[<blockquote>
<p> Spring kafka 版本 2.8.4</p>
</blockquote>
<h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><ul>
<li><a href="https://docs.spring.io/spring-kafka/docs/2.8.11/reference/html/#message-listener-container">spring-kafka(2.8.11)</a></li>
<li><a href="https://www.baeldung.com/?s=spring+kafka">baeldung-spring-kafka</a></li>
</ul>
<h2 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h2><h3 id="Kafka-自动提交-offset"><a href="#Kafka-自动提交-offset" class="headerlink" title="Kafka 自动提交 offset"></a>Kafka 自动提交 offset</h3><ul>
<li>enable.auto.commit&#x3D;true</li>
<li>auto-commit-interval 自动提交的时间间隔</li>
</ul>
<p>​      比如 1s，那么自动提交的时间点 deadline 就是当前时间 +1s，但是自动提交 offset 的线程也是 poll 线程，所以提交 offset 的时间不一定是固定的 1s，会有下面几种情况</p>
<pre><code>  A.  业务处理时间 &gt;= auto-commit-interval  提交 offset 的时间点就是每次 poll 的时候，由于业务处理时间已经大于自定提交间隔，那么每次 poll 的时候当前时间一定大于 deadline，

  所以一定会进行一次 offset 提交（异步提交），这里提交的 offset 区间就是单次拉取消息的数量大小 max.poll.records

  B.  业务处理时间 &lt;&lt; auto-commit-interval  提叫 offset 的时间点可能在第 n 次 poll 的时候（假设 m=业务处理时间，要求  $$n * m$$  &gt; auto-commit-interval），这时候会进行一次一次 offset 提交（异提   交），这里提交的 offset 区间= $$n * $$max.poll.records 
</code></pre>
<ul>
<li>自动提交流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maybeAutoCommitOffsetsAsync</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (autoCommitEnabled) &#123;</span><br><span class="line">        nextAutoCommitTimer.update(now);</span><br><span class="line">        <span class="keyword">if</span> (nextAutoCommitTimer.isExpired()) &#123;</span><br><span class="line">            nextAutoCommitTimer.reset(autoCommitIntervalMs);</span><br><span class="line">            doAutoCommitOffsetsAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/message/kafka/02.png" alt="img"></p>
<h3 id="SpringKafka-提交-offset-流程"><a href="#SpringKafka-提交-offset-流程" class="headerlink" title="SpringKafka 提交 offset 流程"></a>SpringKafka 提交 offset 流程</h3><ul>
<li>前置条件： <strong>enable-auto-commit</strong> &#x3D; false</li>
<li>ackMode &#x3D; <em>RECORD</em></li>
</ul>
<p>​      业务消息处理完成之后，即 doInvokeOnMessage 方法之后，会对发送每条消息的 offset 给 broker</p>
<p><img data-src="/images/message/kafka/03.PNG" alt="img"></p>
<ul>
<li>ackMode !&#x3D; <em>RECORD</em></li>
</ul>
<p><img data-src="/images/message/kafka/04.png" alt="img"></p>
<ul>
<li>AckMode 解析</li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>RECORD</em></td>
<td align="left">自动提交每条消息处理完后提交 offset监听模式不支持批量，只支持单条消息业务处理完成后向 broker 提交 offset</td>
</tr>
<tr>
<td align="left"><em>BATCH</em></td>
<td align="left">自动提交默认的类型一批消息处理完成后再提交 offset消息处理完成后会记录在 acks 中，再次 poll 的时候会将 akcs 转换为 offset 并提交到 broker</td>
</tr>
<tr>
<td align="left"><em>TIME</em></td>
<td align="left">自动提交经过 ackTime 之后提交 offset消息处理完成后会记录在 acks 中</td>
</tr>
<tr>
<td align="left"><em>COUNT</em></td>
<td align="left">自动提交消息消费数量超过此配置后提交消息处理完成后会记录在 acks 中</td>
</tr>
<tr>
<td align="left"><em>COUNT_TIME</em></td>
<td align="left">自动提交满足 COUNT 或 <em>TIME</em> 时提交 offset</td>
</tr>
<tr>
<td align="left"><em>MANUAL</em></td>
<td align="left">手动提交业务处理后调用 acknowledgment.acknowledge（） 提交 offset（指的是内存中维护的 offset）真正向 broker 提交 offset 还是在下一次 poll（）方法执行时</td>
</tr>
<tr>
<td align="left"><em>MANUAL_IMMEDIATE</em></td>
<td align="left">手动提交业务处理后调用 acknowledgment.acknowledge（） 提交 offset提交 offset 指向 broker 提交 offset，而不是维护内存中的数据</td>
</tr>
</tbody></table>
<h3 id="向-Broker-提交-offset-流程"><a href="#向-Broker-提交-offset-流程" class="headerlink" title="向 Broker 提交 offset 流程"></a>向 Broker 提交 offset 流程</h3><ul>
<li>同步提交 syncCommits&#x3D;true（<strong>默认</strong>）</li>
<li>异步提交 syncCommits&#x3D;false</li>
</ul>
<p><img data-src="/images/message/kafka/05.png" alt="img"></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://rq3nt70g815.feishu.cn/wiki/RO2qwqD4YiF4W8kQXmPcos02n8f">异常处理</a></h2><h3 id="默认的异常处理器-DefaultErrorHandler"><a href="#默认的异常处理器-DefaultErrorHandler" class="headerlink" title="默认的异常处理器 DefaultErrorHandler"></a>默认的异常处理器 DefaultErrorHandler</h3><ul>
<li>此处理会重试 n 次，n 次重试都失败后会跳过当前失败的消息，offset 推进一位，所以会导致失败消息丢失！</li>
<li>默认重试 9 次，每次重试之前没有间隔</li>
</ul>
<p><img data-src="/images/message/kafka/06.png" alt="img"></p>
<ul>
<li>业务处理失败 &amp; 重试次数 &lt; 9，抛出异常；会重新 poll 消息进行消费；</li>
</ul>
<p>假设拉取的整批消息中第 n 条消息消费失败（n &gt; 1），那么在消费失败时会先提交 offset，保证前面已经消费的 offset 正常提交</p>
<p><img data-src="/images/message/kafka/07.png" alt="img"></p>
<ul>
<li>定义重试次数 &amp; 重试间隔</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FixedBackOff</span> <span class="variable">fixedBackOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">DefaultErrorHandler</span> <span class="variable">defaultErrorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorHandler</span>(fixedBackOff);</span><br><span class="line">kafkaMessageListenerContainer.setCommonErrorHandler(defaultErrorHandler);</span><br></pre></td></tr></table></figure>

<ul>
<li>批量消费时，遇到异常需要抛出 BatchListenerFailedException，否则会重试整个批次，重试次数过后会越过整个批次的 offset</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3 指的是失败最小消息的index，重试会从这里开始</span></span><br><span class="line"><span class="type">BatchListenerFailedException</span> <span class="variable">batchListenerFailedException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BatchListenerFailedException</span>(<span class="string">&quot;批次消费失败&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">throw</span> batchListenerFailedException;</span><br></pre></td></tr></table></figure>

<h3 id="优雅的异常处理"><a href="#优雅的异常处理" class="headerlink" title="优雅的异常处理"></a>优雅的异常处理</h3><p>默认的异常处理器重试失败仅仅打印日志，对于系统来说消息就丢失了。</p>
<p>所以需要重写 ConsumerRecordRecoverer 接口，将失败的消息发送到死信队列中，便于后续人工或程序进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义重试次数 &amp; 重试间隔</span></span><br><span class="line"><span class="type">FixedBackOff</span> <span class="variable">fixedBackOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">2000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 自定义消息recover，针对不同类型的消息，转发到不同的topic中</span></span><br><span class="line"><span class="type">DeadLetterPublishingRecoverer</span> <span class="variable">recoverer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLetterPublishingRecoverer</span>(kafkaTemplate, (record, exception) -&gt; &#123;</span><br><span class="line">    log.error(<span class="string">&quot;消息消费失败, topic: &#123;&#125;, partition: &#123;&#125;, offset: &#123;&#125;, data: &#123;&#125;&quot;</span>, record.topic(), record.partition(), record.offset(), record.value());</span><br><span class="line">    <span class="keyword">if</span> (exception.getCause() <span class="keyword">instanceof</span> ArithmeticException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic() + <span class="string">&quot;.arithmetic.failures&quot;</span>, record.partition());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic() + <span class="string">&quot;.other.failures&quot;</span>, record.partition());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">DefaultErrorHandler</span> <span class="variable">defaultErrorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorHandler</span>(recoverer, fixedBackOff);</span><br></pre></td></tr></table></figure>

<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><ul>
<li>当前 spring kafka 版本为 2.8.4，这个版本下因为 DefaultErrorHandler  的原因，无论是自动提交还是手动提交，都会 seek 到失败的消息，再进行重试，所以不会出现消费异常时直接提交 offset 的情况；同时此异常处理器对于某条消息处理失败后，不会跳过这条消息是尝试下一条消息消费，所以理论上不会出现消息丢失的情况，只是消费失败仅仅打印日志不友好，需要参考 2。优雅的异常处理 进行处理</li>
<li>在某些早版本的 spring kafka（比如 2.2.4）中，消费失败会直接提交 offset；或者当前这条消息消费失败，下一条消息消费成功后会提交下一条消息的 offset，导致消息丢失；遇到这种情况，以下操作是相对✅的<ul>
<li>autoCommit &#x3D; false</li>
<li>ackMode &#x3D; 手动&#x2F;手动立即</li>
<li>设置错误处理器 SeekToCurrentErrorHandler 更新本地内存拉取 offset 的值为消费失败的 record 的 offset 值，下次 poll 周期就会去重新拉取未提交的 offset。重试 DeadLetterPublishRecover 多次消费失败： 入死信队列，可设置 Topic 名称，默认到 [target_topic]。DLT</li>
</ul>
</li>
</ul>
<p><img data-src="/images/message/kafka/08.png" alt="img"></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>中间件</tag>
        <tag>kafka</tag>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
