<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"taeyang0126.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css"><meta name="description" content="本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起   Native Memory Tracking  开启Native Memory Tracking 主要是用来通过在 JVM 向系统申请内存的时候进行埋点实现的。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是"><meta property="og:type" content="website"><meta property="og:title" content="JVM内存解析 - 1.Native Memory Tracking"><meta property="og:url" content="https://taeyang0126.github.io/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-Native%20Memory%20Tracking.html"><meta property="og:site_name" content="WL&#39;s blog"><meta property="og:description" content="本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起   Native Memory Tracking  开启Native Memory Tracking 主要是用来通过在 JVM 向系统申请内存的时候进行埋点实现的。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-02-23T01:46:30.000Z"><meta property="article:modified_time" content="2025-02-23T01:46:30.000Z"><meta property="article:author" content="WU LEI"><meta property="article:tag" content="JVM"><meta property="article:tag" content="内存"><meta property="article:tag" content="NMT"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://taeyang0126.github.io/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-Native%20Memory%20Tracking"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://taeyang0126.github.io/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-Native%20Memory%20Tracking.html","path":"_posts/jvm/内存解析/JVM内存解析-Native Memory Tracking.html","title":"JVM内存解析 - 1.Native Memory Tracking"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>JVM内存解析 - 1.Native Memory Tracking | WL's blog</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="WL's blog" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">WL's blog</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-folder-open fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF"><span class="nav-number">1.</span> <span class="nav-text">开启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-%E4%BF%A1%E6%81%AF%E6%AF%8F%E9%83%A8%E5%88%86%E5%90%AB%E4%B9%89"><span class="nav-number">3.</span> <span class="nav-text">summary 信息每部分含义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%A0%86%E5%86%85%E5%AD%98-Java-Heap"><span class="nav-number">3.1.</span> <span class="nav-text">Java堆内存(Java Heap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4-Class"><span class="nav-number">3.2.</span> <span class="nav-text">元空间(Class)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%B3%E7%AC%A6%E5%8F%B7-Symbol-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">3.3.</span> <span class="nav-text">C++ 字符串即符号(Symbol)占用空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98-Thread"><span class="nav-number">3.4.</span> <span class="nav-text">线程占用内存(Thread)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E8%BA%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8AJIT%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4-Code"><span class="nav-number">3.5.</span> <span class="nav-text">JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arena-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4-Arena-Chunk"><span class="nav-number">3.6.</span> <span class="nav-text">Arena 数据结构占用空间(Arena Chunk)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-Tracing-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-number">3.7.</span> <span class="nav-text">JVM Tracing 占用内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99-JVM-%E6%97%A5%E5%BF%97%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98-Logging"><span class="nav-number">3.8.</span> <span class="nav-text">写 JVM 日志占用的内存(Logging)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-%E5%8F%82%E6%95%B0%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98-Arguments"><span class="nav-number">3.9.</span> <span class="nav-text">JVM 参数占用内存(Arguments)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-%E5%AE%89%E5%85%A8%E7%82%B9%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98-Safepoint"><span class="nav-number">3.10.</span> <span class="nav-text">JVM 安全点占用内存(Safepoint)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6-Synchronization"><span class="nav-number">3.11.</span> <span class="nav-text">Java 同步机制(Synchronization)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-TI-%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98-Serviceability"><span class="nav-number">3.12.</span> <span class="nav-text">JVM TI 相关内存(Serviceability)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98-String-Deduplication"><span class="nav-number">3.13.</span> <span class="nav-text">Java 字符串去重占用内存(String Deduplication)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-GC%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%B0%E5%BD%95%E4%BF%A1%E6%81%AF%E5%8D%A0%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4-GC"><span class="nav-number">3.14.</span> <span class="nav-text">JVM GC需要的数据结构与记录信息占用的空间(GC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%86%85%E9%83%A8%E4%B8%8E%E5%85%B6%E4%BB%96%E5%8D%A0%E7%94%A8"><span class="nav-number">3.15.</span> <span class="nav-text">JVM内部与其他占用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%90%AF-Native-Memory-Tracking-%E6%9C%AC%E8%BA%AB%E6%B6%88%E8%80%97%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">3.16.</span> <span class="nav-text">开启 Native Memory Tracking 本身消耗的内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Native-Memory-Tracking-%E7%9A%84-summary-%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8C%81%E7%BB%AD%E7%9B%91%E6%8E%A7"><span class="nav-number">4.</span> <span class="nav-text">Native Memory Tracking 的 summary 信息的持续监控</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="WU LEI" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">WU LEI</p><div class="site-description" itemprop="description">Code & Life</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/taeyang0126" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;taeyang0126" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:17674030991@163.com" title="E-Mail → mailto:17674030991@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="links-of-recent-posts motion-element"><div class="links-of-recent-posts-title"><i class="fa fa-history fa-fw"></i> 最近文章</div><ul class="links-of-recent-posts-list"><li class="links-of-recent-posts-item"><a href="/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/" title="2025&#x2F;02&#x2F;24&#x2F;jfr&#x2F;6.jvm-yu-jfr-shi-jian-allocation-requiring-gc&#x2F;posts&#x2F;undefined&#x2F;">JVM与JFR事件-Java Virtual Machine/GC/Detailed/Allocation Requiring GC</a></li><li class="links-of-recent-posts-item"><a href="/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/" title="2025&#x2F;02&#x2F;23&#x2F;java&#x2F;rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi&#x2F;posts&#x2F;undefined&#x2F;">java在容器中运行的脚本解析</a></li><li class="links-of-recent-posts-item"><a href="/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/" title="2025&#x2F;02&#x2F;23&#x2F;jvm&#x2F;nei-cun-jie-xi&#x2F;jvm-nei-cun-jie-xi-native-memory-tracking&#x2F;posts&#x2F;undefined&#x2F;">JVM内存解析 - 1.Native Memory Tracking</a></li><li class="links-of-recent-posts-item"><a href="/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/" title="2025&#x2F;02&#x2F;22&#x2F;jfr&#x2F;5.jvm-yu-jfr-shi-jian-object-allocation-sample&#x2F;posts&#x2F;undefined&#x2F;">JVM与JFR事件-Java Application/Object Allocation Sample</a></li><li class="links-of-recent-posts-item"><a href="/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/" title="2025&#x2F;02&#x2F;22&#x2F;gong-ju&#x2F;hua-tu-gong-ju&#x2F;posts&#x2F;undefined&#x2F;">画图工具</a></li></ul></div></div></div></div></aside></div><div class="main-inner page posts-expand"><div class="post-block" lang="zh-CN"><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM内存解析 - 1.Native Memory Tracking</h1><div class="post-meta-container"><ul class="breadcrumb"><li><a href="/_posts/">_POSTS</a></li><li><a href="/_posts/jvm/">JVM</a></li><li><a href="/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/">内存解析</a></li><li>JVM内存解析-NATIVE MEMORY TRACKING</li></ul></div></header><div class="post-body"><blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</p></blockquote><ul><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7225871227743043644">Native Memory Tracking</a></li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>Native Memory Tracking 主要是用来通过在 <code>JVM 向系统申请内存的时候进行埋点实现的</code>。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是有不小消耗的，这个 Native Memory Tracking 默认是不开启的，并且<code>无法动态开启</code>（因为这是埋点采集统计的，如果可以动态开启那么没开启的时候的内存分配没有记录无法知晓，所以无法动态开启），目前只能通过在启动 JVM 的时候通过启动参数开启。即通过 <code>-XX:NativeMemoryTracking</code> 开启:</p><ul><li><code>-XX:NativeMemoryTracking=off</code>:这是默认值，即关闭 Native Memory Tracking</li><li><code>-XX:NativeMemoryTracking=summary</code>: 开启 Native Memory Tracking，但是仅仅按照各个 JVM 子系统去统计内存占用情况</li><li><code>-XX:NativeMemoryTracking=detail</code>: 开启 Native Memory Tracking，从每次 JVM 中申请内存的不同调用路径的维度去统计内存占用情况。注意，开启 detail 比开启 summary 的消耗要大不少，因为 detail 每次都要解析 CallSite 分辨调用位置。我们一般用不到这么详细的内容，除非是 JVM 开发。</li></ul><p>开启之后，我们可以通过 jcmd 命令去查看 Native Memory Tracking 的信息，即<code>jcmd &lt;pid&gt; VM.native_memory</code>：</p><ul><li><code>jcmd &lt;pid&gt; VM.native_memory</code>或者<code>jcmd &lt;pid&gt; VM.native_memory summary</code>：两者是等价的，即查看 Native Memory Tracking 的 summary 信息。默认单位是 KB，可以指定单位为其他，例如 jcmd<pid>VM.native_memory summary scale&#x3D;MB</pid></li><li><code>jcmd &lt;pid&gt; VM.native_memory detail</code>：查看 Native Memory Tracking 的 detail 信息，包括 summary 信息，以及按照虚拟内存映射分组的内存使用信息，还有按照不同 CallSite 调用分组的内存使用情况。默认单位是 KB，可以指定单位为其他，例如 jcmd<pid>VM.native_memory detail scale&#x3D;MB</pid></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>我们只关心并且查看 Native Memory Tracking 的 summary 信息即可，detail 信息一般是供 JVM 开发人员使用的，我们不用太关心</p></blockquote><p>一般地，只有遇到问题的时候，我们才会考虑开启 Native Memory Tracking，并且在定位出问题后，我们想把它关闭，可以通过 <code>jcmd &lt;pid&gt; VM.native_memory shutdown</code> 进行关闭并清理掉之前 Native Memory tracking 使用的埋点以及占用的内存。如前面所述，我们无法动态开启 Native Memory tracking，所以只要动态关闭了，这个进程就无法再开启了。</p><p>jcmd 本身提供了简单的对比功能，例如：</p><ol><li>使用 <code>jcmd &lt;pid&gt; VM.native_memory baseline</code> 记录当前内存占用信息</li><li>之后过一段时间 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 会输出当前 Native Memory Tracking 的 summary 信息，如果与第一步 baseline 的有差异，会在对应位将差异输出</li></ol><p>但是这个工具本身比较粗糙，我们有时候并不知道何时调用 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 合适，因为我们不确定什么时候会有我们想看到的内存使用过大的问题。所以我们一般做成一种持续监控的方式</p><h3 id="summary-信息每部分含义"><a href="#summary-信息每部分含义" class="headerlink" title="summary 信息每部分含义"></a>summary 信息每部分含义</h3><p>以下是一个 Native Memory Tracking 的示例输出：</p><ol><li>压测 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-petclinic.git">spring-petclinic</a> 项目</li><li>jdk21</li><li>vm options</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">(Omitting categories weighting less than 1KB)</span><br><span class="line"></span><br><span class="line">Total: reserved=1751414KB, committed=470662KB</span><br><span class="line">       malloc: 104634KB #545587</span><br><span class="line">       mmap:   reserved=1646780KB, committed=366028KB</span><br><span class="line"></span><br><span class="line">-                 Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">                            (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">                            (classes #21948)</span><br><span class="line">                            (  instance classes #20377, array classes #1571)</span><br><span class="line">                            (malloc=1935KB #58688) (peak=1999KB #58351) </span><br><span class="line">                            (mmap: reserved=1048576KB, committed=15232KB, at peak) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=131072KB, committed=91072KB)</span><br><span class="line">                            (    used=90300KB)</span><br><span class="line">                            (    waste=772KB =0.85%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=14704KB)</span><br><span class="line">                            (    waste=528KB =3.46%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">                            (threads #58)</span><br><span class="line">                            (stack: reserved=117420KB, committed=117420KB, peak=117420KB)</span><br><span class="line">                            (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">                            (arena=67KB #114) (peak=3010KB #121)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">                            (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">                            (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=33KB #1)</span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">                            (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">                            (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br><span class="line"> </span><br><span class="line">-                 GCCardSet (reserved=70KB, committed=70KB)</span><br><span class="line">                            (malloc=70KB #778) (peak=483KB #1344) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=230KB, committed=230KB)</span><br><span class="line">                            (malloc=100KB #711) (peak=142KB #1118) </span><br><span class="line">                            (arena=130KB #2) (peak=10244KB #9)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">                            (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=108KB, committed=108KB)</span><br><span class="line">                            (malloc=108KB #18) (peak=130KB #20) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">                            (malloc=33100KB #285200) (peak=33111KB #284967) </span><br><span class="line">                            (arena=6017KB #1) (at peak)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                            (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                            (tracking overhead=8525KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">                            (malloc=199KB #306) (peak=16383KB #630) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">                            (malloc=21522KB #12431) (at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=32KB #1)</span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=0KB, committed=0KB)</span><br><span class="line">                            (malloc=0KB #2) (peak=6KB #4) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=276KB, committed=276KB)</span><br><span class="line">                            (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-           Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                            (malloc=3462KB #66139) (peak=3479KB #66484) </span><br><span class="line"> </span><br><span class="line">-            Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                            (malloc=2837KB #33552) (peak=2850KB #33877) </span><br><span class="line"> </span><br><span class="line">-                 Metaspace (reserved=131503KB, committed=91503KB)</span><br><span class="line">                            (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">                            (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br><span class="line"> </span><br><span class="line">-      String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #8) (at peak) </span><br><span class="line"> </span><br><span class="line">-           Object Monitors (reserved=24KB, committed=24KB)</span><br><span class="line">                            (malloc=24KB #116) (peak=162KB #798) </span><br><span class="line"> </span><br><span class="line">-                   Unknown (reserved=0KB, committed=0KB)</span><br><span class="line">                            (mmap: reserved=0KB, committed=0KB, peak=32KB) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Java堆内存-Java-Heap"><a href="#Java堆内存-Java-Heap" class="headerlink" title="Java堆内存(Java Heap)"></a>Java堆内存(Java Heap)</h4><blockquote><p>所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 堆内存占用，reserve 了 262144KB=256M，当前 commit 了 82944KB(81M) 用于实际使用</span><br><span class="line">// 发现 申请的内存大小正好等于=-Xmx256m，预留内存空间（不实际分配物理内存），只是为了让操作系统选择地址，预留大小。commit才是实际使用的物理内存</span><br><span class="line">Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">    // 堆内存都是通过 mmap 系统调用方式分配的，peak=最大使用量</span><br><span class="line">    (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br></pre></td></tr></table></figure><h4 id="元空间-Class"><a href="#元空间-Class" class="headerlink" title="元空间(Class)"></a>元空间(Class)</h4><blockquote><p>JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。对应的 Java 反射类 Class 还是在堆内存空间中</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Class 是类元空间总占用，reserve 了 1050511KB(1025M)，当前 commit 了 17167KB(16MB) 用于实际使用</span><br><span class="line">// 总共 reserved 1050511KB = mmap reserved 1048576KB(1024) + malloc 1935KB(1.8)</span><br><span class="line">// 总共 committed 17167KB = mmap committed 15232KB + malloc 1999KB</span><br><span class="line"> Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">        (classes #21948) //一共加载了 21948 个类</span><br><span class="line">        (  instance classes #20377, array classes #1571)    //其中 20377 个实体类，1571 个数组类</span><br><span class="line">        (malloc=1935KB #58688) (peak=1999KB #58351)  //通过 malloc 系统调用方式一共分配了 1935KB，一共调用了 58688 次 malloc</span><br><span class="line">        (mmap: reserved=1048576KB, committed=15232KB, at peak)  //通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 15232KB 用于实际使用</span><br><span class="line">        (  Metadata:   ) //注意，MetaData 这块不属于类元空间，属于数据元空间</span><br><span class="line">        (    reserved=131072KB, committed=91072KB) //数据元空间当前 reserve 了 131072KB，commit 了 91072KB 用于实际使用</span><br><span class="line">        (    used=90300KB) //但是实际从 MetaChunk 的角度去看使用，只有 90300KB 用于实际数据的分配，有 772KB 的浪费</span><br><span class="line">        (    waste=772KB =0.85%)</span><br><span class="line">        (  Class space:)</span><br><span class="line">        (    reserved=1048576KB, committed=15232KB) //类元空间当前 reserve 了 1048576KB，commit 了 15232KB 用于实际使用 </span><br><span class="line">        (    used=14704KB)  //但是实际从 MetaChunk 的角度去看使用，只有 14704KB 用于实际数据的分配，有 528KB 的浪费</span><br><span class="line">        (    waste=528KB =3.46%)</span><br><span class="line">Module (reserved=276KB, committed=276KB) //加载并记录模块占用空间，当前 reserve 了 276KB，commit 了 276KB 用于实际使用</span><br><span class="line">        (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line">Metaspace (reserved=131503KB, committed=91503KB) //等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 131503KB，commit 了 91503KB 用于实际使用</span><br><span class="line">        (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">        (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="C-字符串即符号-Symbol-占用空间"><a href="#C-字符串即符号-Symbol-占用空间" class="headerlink" title="C++ 字符串即符号(Symbol)占用空间"></a>C++ 字符串即符号(Symbol)占用空间</h4><blockquote><p>前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复。所以统一放入符号表(Symbol table)复用。元空间中保存的是针对符号表中符号的引用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">        (malloc=33100KB #285200) (peak=33111KB #284967)  //通过 malloc 系统调用方式一共分配了 33100KB，一共调用了 285200 次 malloc</span><br><span class="line">        (arena=6017KB #1) (at peak) //通过 arena 系统调用方式一共分配了 6017KB，一共调用了 1 次 arena</span><br></pre></td></tr></table></figure><h4 id="线程占用内存-Thread"><a href="#线程占用内存-Thread" class="headerlink" title="线程占用内存(Thread)"></a>线程占用内存(Thread)</h4><blockquote><p>主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 总共 reserve 了 117590KB(114M)，commit 了 117590KB(114M)</span><br><span class="line">Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">    (threads #58) //当前线程数量是 58</span><br><span class="line">    (stack: reserved=117420KB, committed=117420KB, peak=117420KB) //线程栈占用的空间: 每个线程实际占用 ≈ 1MB(栈) + 2MB(Guard Pages) 58个线程总占用 ≈ 58 * (1MB + 2MB) ≈ 174MB，实际看到117MB比理论值小，因为Guard Pages可能共享</span><br><span class="line">    (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">    (arena=67KB #114) (peak=3010KB #121)</span><br></pre></td></tr></table></figure><h4 id="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code"><a href="#JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code" class="headerlink" title="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)"></a>JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">    (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">    (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">    (arena=0KB #0) (peak=33KB #1)</span><br></pre></td></tr></table></figure><h4 id="Arena-数据结构占用空间-Arena-Chunk"><a href="#Arena-数据结构占用空间-Arena-Chunk" class="headerlink" title="Arena 数据结构占用空间(Arena Chunk)"></a>Arena 数据结构占用空间(Arena Chunk)</h4><blockquote><p>Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">            (malloc=199KB #306) (peak=16383KB #630) </span><br></pre></td></tr></table></figure><h4 id="JVM-Tracing-占用内存"><a href="#JVM-Tracing-占用内存" class="headerlink" title="JVM Tracing 占用内存"></a>JVM Tracing 占用内存</h4><blockquote><p>包括 JVM perf 以及 JFR 占用的空间。其中 JFR 占用的空间可能会比较大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">    (malloc=21522KB #12431) (at peak) </span><br><span class="line">    (arena=0KB #0) (peak=32KB #1)</span><br></pre></td></tr></table></figure><h4 id="写-JVM-日志占用的内存-Logging"><a href="#写-JVM-日志占用的内存-Logging" class="headerlink" title="写 JVM 日志占用的内存(Logging)"></a>写 JVM 日志占用的内存(Logging)</h4><blockquote><p>-Xlog 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志-Xlog:async，异步日志所需的 buffer 也在这里</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logging (reserved=0KB, committed=0KB)</span><br><span class="line">        (malloc=0KB #2) (peak=6KB #4) </span><br></pre></td></tr></table></figure><h4 id="JVM-参数占用内存-Arguments"><a href="#JVM-参数占用内存-Arguments" class="headerlink" title="JVM 参数占用内存(Arguments)"></a>JVM 参数占用内存(Arguments)</h4><blockquote><p>我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">(malloc=31KB #90) </span><br></pre></td></tr></table></figure><h4 id="JVM-安全点占用内存-Safepoint"><a href="#JVM-安全点占用内存-Safepoint" class="headerlink" title="JVM 安全点占用内存(Safepoint)"></a>JVM 安全点占用内存(Safepoint)</h4><blockquote><p>是固定的两页内存（我这里是一页是 16KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">           (mmap: reserved=32KB, committed=32KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="Java-同步机制-Synchronization"><a href="#Java-同步机制-Synchronization" class="headerlink" title="Java 同步机制(Synchronization)"></a>Java 同步机制(Synchronization)</h4><blockquote><p>例如 synchronized，还有 AQS 的基础 LockSupport 底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                (malloc=3462KB #66139) (peak=3479KB #66484) </span><br></pre></td></tr></table></figure><h4 id="JVM-TI-相关内存-Serviceability"><a href="#JVM-TI-相关内存-Serviceability" class="headerlink" title="JVM TI 相关内存(Serviceability)"></a>JVM TI 相关内存(Serviceability)</h4><blockquote><p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏检测工具等等。这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                (malloc=2837KB #33552) (peak=2850KB #33877) </span><br></pre></td></tr></table></figure><h4 id="Java-字符串去重占用内存-String-Deduplication"><a href="#Java-字符串去重占用内存-String-Deduplication" class="headerlink" title="Java 字符串去重占用内存(String Deduplication)"></a>Java 字符串去重占用内存(String Deduplication)</h4><blockquote><p>Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 <code>G1GC</code> 以及 <code>ZGC</code> 中，所以默认是关闭的，可以通过 <code>-XX:+UseStringDeduplication</code> 来启用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                    (malloc=1KB #8) (at peak) </span><br></pre></td></tr></table></figure><h4 id="JVM-GC需要的数据结构与记录信息占用的空间-GC"><a href="#JVM-GC需要的数据结构与记录信息占用的空间-GC" class="headerlink" title="JVM GC需要的数据结构与记录信息占用的空间(GC)"></a>JVM GC需要的数据结构与记录信息占用的空间(GC)</h4><blockquote><p>这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 <code>ZGC</code>。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">    (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">    (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br></pre></td></tr></table></figure><h4 id="JVM内部与其他占用"><a href="#JVM内部与其他占用" class="headerlink" title="JVM内部与其他占用"></a>JVM内部与其他占用</h4><blockquote><p>JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">        (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">        (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"></span><br><span class="line"> Other (reserved=108KB, committed=108KB)</span><br><span class="line">        (malloc=108KB #18) (peak=130KB #20) </span><br></pre></td></tr></table></figure><h4 id="开启-Native-Memory-Tracking-本身消耗的内存"><a href="#开启-Native-Memory-Tracking-本身消耗的内存" class="headerlink" title="开启 Native Memory Tracking 本身消耗的内存"></a>开启 Native Memory Tracking 本身消耗的内存</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                    (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                    (tracking overhead=8525KB)</span><br></pre></td></tr></table></figure><h3 id="Native-Memory-Tracking-的-summary-信息的持续监控"><a href="#Native-Memory-Tracking-的-summary-信息的持续监控" class="headerlink" title="Native Memory Tracking 的 summary 信息的持续监控"></a>Native Memory Tracking 的 summary 信息的持续监控</h3><p>现在 JVM 一般大部分部署在 k8s 这种云容器编排的环境中，每个 JVM 进程内存是受限的。如果超过限制，那么会触发 OOMKiller 将这个 JVM 进程杀掉。我们一般都是由于自己的 JVM 进程被 OOMKiller杀掉，才会考虑打开 <code>NativeMemoryTracking</code> 去看看哪块内存占用比较多以及如何调整的。</p><p><code>OOMKiller 是积分制</code>，并不是你的 JVM 进程一超过限制就立刻会被杀掉，而是超过的话会累积分，累积到一定程度，就可能会被 OOMKiller 杀掉。所以，我们可以通过<code>定时输出</code> Native Memory Tracking的 summary 信息，从而抓到超过内存限制的点进行分析</p><p>但是，我们不能仅通过 Native Memory Tracking 的数据就判断 JVM 占用的内存，因为在后面的 JVM 内存申请与使用流程的分析我们会看到，<code>JVM 通过 mmap 分配的大量内存都是先 reserve 再 commit 之后实际往里面写入数据的时候，才会真正分配物理内存</code>。同时，JVM 还会动态释放一些内存，这些内存可能不会立刻被操作系统回收。<code>Native Memory Tracking 是 JVM 认为自己向操作系统申请的内存，与实际操作系统分配的内存是有所差距的</code>，所以我们不能只查看 Native Memory Tracking 去判断，我们还需要查看能体现真正内存占用指标。这里可以查看 linux 进程监控文件 smaps_rollup 看出具体的内存占用，例如 (一般不看 Rss，因为如果涉及多个虚拟地址映射同一个物理地址的话会有不准确，所以主要关注 <code>Pss</code> 即可，但是 Pss 更新不是实时的，但也差不多，这就可以理解为进程占用的实际物理内存)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/1/smaps_rollup </span><br><span class="line">f8000000-ffffe5c27000 ---p 00000000 00:00 0                              [rollup]</span><br><span class="line">Rss:              198904 kB</span><br><span class="line">Pss:              197331 kB</span><br><span class="line">Pss_Dirty:        181900 kB</span><br><span class="line">Pss_Anon:         181880 kB</span><br><span class="line">Pss_File:          15451 kB</span><br><span class="line">Pss_Shmem:             0 kB</span><br><span class="line">Shared_Clean:       1864 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:     15140 kB</span><br><span class="line">Private_Dirty:    181900 kB</span><br><span class="line">Referenced:       198904 kB</span><br><span class="line">Anonymous:        181880 kB</span><br><span class="line">KSM:                   0 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FilePmdMapped:         0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure><p>通过在每个 Spring Cloud 微服务进程加入下面的代码，来实现定时的进程内存监控，主要通过 <code>smaps_rollup</code> 查看实际的物理内存占用找到内存超限的时间点，Native Memory Tracking 查看 JVM 每块内存占用的多少，用于指导优化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.bootstrap.BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorMemoryRSS</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">INITIALIZED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBootstrapContext(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (INITIALIZED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZED.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取 smaps_rollup</span></span><br><span class="line">                    List&lt;String&gt; strings = FileUtils.readLines(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/smaps_rollup&quot;</span>));</span><br><span class="line">                    log.info(<span class="string">&quot;MonitorMemoryRSS, smaps_rollup: &#123;&#125;&quot;</span>, strings.stream().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    <span class="comment">//读取 Native Memory Tracking 信息</span></span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;jcmd&quot;</span>, pid + <span class="string">&quot;&quot;</span>, <span class="string">&quot;VM.native_memory&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()))) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;MonitorMemoryRSS, native_memory: &#123;&#125;&quot;</span>, reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            INITIALIZED.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBootstrapContext</span><span class="params">(ApplicationReadyEvent applicationEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationEvent.getApplicationContext().getEnvironment().getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div></div><ul class="breadcrumb"><li><a href="/_posts/">_POSTS</a></li><li><a href="/_posts/jvm/">JVM</a></li><li><a href="/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/">内存解析</a></li><li>JVM内存解析-NATIVE MEMORY TRACKING</li></ul></div></main><footer class="footer"><div class="footer-inner"><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">77k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">4:40</span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://taeyang0126.github.io/_posts/jvm/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-Native%20Memory%20Tracking.html"}</script><script src="/js/third-party/quicklink.js"></script></body></html>