<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WL&#39;s blog</title>
  
  
  <link href="https://taeyang0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://taeyang0126.github.io/"/>
  <updated>2025-03-01T07:46:30.000Z</updated>
  <id>https://taeyang0126.github.io/</id>
  
  <author>
    <name>WU LEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存解析 - 2.JVM 内存申请与使用流程</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/</id>
    <published>2025-03-01T07:46:30.000Z</published>
    <updated>2025-03-01T07:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</p></blockquote><ul><li><a href="https://juejin.cn/post/7225875600644407357">JVM 内存申请与使用流程</a></li></ul><h2 id="Linux-下内存管理模型简述"><a href="#Linux-下内存管理模型简述" class="headerlink" title="Linux 下内存管理模型简述"></a>Linux 下内存管理模型简述</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21&key=d9f8952995f1859ec52d8f5d9e6ab4720ffabd5403c103322ee7ec6f45279c0d6ff004df4d91e603b8da30fc862da32560064a1680e06e498f1478dedf8d24cd54abfe5bbf80610ac6a1ecfcadeceb1ce74fd27e061bc962a5e9d18c369786619a9ac7ad030b16a0f350638aed32ec61ad2c47b2df53b2fffac6419c8a55feb1&ascene=2&uin=MTQxMDM0OTkyNA==&devicetype=Windows+11+x64&version=6308011a&exportkey=n_ChQIAhIQLReSAiPPBq/rjeEsvhWLGhLpAQIE97dBBAEAAAAAAPboBnzhWE0AAAAOpnltbLcz9gKNyK89dVj0LB8MByB+LnarvTJ9k5LjHnaHSiRCVUH6zSSXMnbZ9AQCusp6IDK5hwtnugd9Du4BG2pqPuJHPIkVIcUMia320lXFN61yM/+2MKyl86soaJUlu0zu8x69eop1Fbdi4YBaoocZrDbr+Buq4hsy+Kf6ElIQw+6gPfQqllJ5R86pa0DoVOjdnD2bi7ZuxdMyvcOPEu3pDa5H/BgY1A+DcifqtVZlp+5LoJKYNhtlZg1zOS06RY15Ry0DdonN38efMsG2Req/&acctmode=0&pass_ticket=ywhUvrTZ0ZCaWLuvLdidNGnNwyS7T41V+KEL2N0td3RvwmPJ+ZREM3Zc0lit4wDxNhALtKqF2gPCKD6sLdagzA==&wx_header=1&fontgear=2">bin神系列文章深入理解linux内存</a></li></ul><p>CPU 是通过寻址来访问内存的，目前大部分 CPU 都是 64 位的，即寻址范围是：<code>0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF</code>，即可以管理 16EB 的内存。但是，实际程序并不会直接通过 CPU 寻址访问到实际的物理内存，而是通过引入 <code>MMU</code>（Memory Management Unit 内存管理单元）与实际物理地址隔了一层虚拟内存的抽象。这样，程序申请以及访问的其实是<code>虚拟内存地址</code>，MMU 会将这个虚拟内存地址<code>映射</code>为实际的物理内存地址。同时，<code>为了减少内存碎片，以及增加内存分配效率</code>，在 MMU 的基础上 Linux 抽象了<code>内存分页（Paging）</code>的概念，将虚拟地址按固定大小分割成<code>页</code>（默认是 4K，如果平台支持更多更大的页大小 JVM 也是可以利用的，我们后面分析相关的 JVM 参数会看到），并在页被实际使用写入数据的时候，<code>映射同样大小的实际的物理内存</code>（页帧，Page Frame），或者是在物理内存不足的时候，将某些不常用的页<code>转移到其他存储设备比如磁盘上</code>。</p><p>一般系统中会有多个进程使用内存，每个进程都有自己独立的虚拟内存空间，假设我们这里有三个进程，进程 A 访问的虚拟地址可以与进程 B 和进程 C 的虚拟地址相同，那么操作系统如何区分呢？即操作系统如何将这些虚拟地址转换为物理内存。这就需要页表了，页表也是每个进程独立的，操作系统会在给进程映射物理内存用来保存用户数据的时候，将物理内存保存到进程的页表里面。然后，进程访问虚拟内存空间的时候，通过页表找到物理内存：<br><img data-src="/images/jvm/memory/01.png" alt="img"></p><p>页表如何将一个虚拟内存地址（我们需要注意一点，目前虚拟内存地址，用户空间与内核空间可以使用从 <code>0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF</code> 的地址，即 256TB），转化为物理内存的呢？下面我们举一个在 x86，64 位环境下四级页表的结构视图：<br><img data-src="/images/jvm/memory/02.png" alt="img"></p><p>在这里，页表分为四个级别：PGD（Page Global Directory），PUD（Page Upper Directory），PMD（Page Middle Directory），PTE（Page Table Entry）。每个页表，里面的页表项，保存了指向下一个级别的页表的引用，除了最后一层的 PTE 里面的页表项保存的是指向用户数据内存的指针。如何将虚拟内存地址通过页表找到对应用户数据内存从而读取数据，过程是：<br><img data-src="/images/jvm/memory/03.png" alt="img"></p><ol><li>取虚拟地址的 <code>39 ~ 47</code> 位（因为用户空间与内核空间可以使用从 0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF 的地址，即 47 位以下的地址）作为 offset，在<code>唯一</code>的 PGD 页面根据 offset 定位到 PGD 页表项 <code>pgd_t</code></li><li>使用 <code>pgd_t</code> 定位到具体的 PUD 页面</li><li>取虚拟地址的 <code>30 ~ 38</code> 位作为 offset，在对应的 PUD 页面根据 offset 定位到 PUD 页表项 <code>pud_t</code></li><li>使用 <code>pud_t</code> 定位到具体的 PMD 页面</li><li>取虚拟地址的 <code>21 ~ 29</code> 位作为 offset，在对应的 PMD 页面根据 offset 定位到 PMD 页表项 <code>pmd_t</code></li><li>使用 <code>pmd_t</code> 定位到具体的 PTE 页面</li><li>取虚拟地址的 <code>12 ~ 20</code> 位作为 offset，在对应的 PTE 页面根据 offset 定位到 PTE 页表项 <code>pte_t</code></li><li>使用 <code>pte_t</code> 定位到具体的用户数据物理内存页面</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset</li></ol><p>如果每次访问虚拟内存，都需要访问这个页表翻译成实际物理内存的话，性能太差。所以一般 CPU 里面都有一个 <code>TLB</code>（Translation Lookaside Buffer，翻译后备缓冲）存在，一般它属于 CPU 的 MMU 的一部分。<code>TLB 负责缓存虚拟内存与实际物理内存的映射关系</code>，一般 TLB 容量很小。每次访问虚拟内存，先查看 TLB 中是否有缓存，如果没有才会去页表查询。<br><img data-src="/images/jvm/memory/04.png" alt="img"><br>默认情况下，TLB 缓存的 key 为地址的 <code>12 ~ 47</code> 位，value 是实际的物理内存页面。这样前面从<code>第 1 到第 7 步</code>就可以被替换成访问 TLB 了：</p><ol><li>取虚拟地址的 <code>12 ~ 47</code> 位作为 key，访问 TLB，定位到具体的用户数据物理内存页面。</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset。<br><img data-src="/images/jvm/memory/05.png" alt="img"></li></ol><p>TLB 整体可以容纳个数不多；页大小越大，TLB 能容纳的个数越少。但是整体看，TLB 能容纳的页大小还是增多的（比如 Nehalem 的 iTLB，页大小 4K 的时候，一共可以容纳 128 * 4 &#x3D; 512K 的内存，页大小 2M 的时候，一共可以容纳 2 * 7 &#x3D; 14M 的内存）</p><p>JVM 中很多地方需要知道页大小，JVM 在初始化的时候，通过系统调用 <code>sysconf(_SC_PAGESIZE)</code> 读取出页大小，并保存下来以供后续使用。参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp">https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置全局默认页大小，通过 Linux::page_size() 可以获取全局默认页大小</span></span><br><span class="line">Linux::<span class="built_in">set_page_size</span>(<span class="built_in">sysconf</span>(_SC_PAGESIZE));</span><br><span class="line"><span class="keyword">if</span> (Linux::<span class="built_in">page_size</span>() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;</span>,</span><br><span class="line">      os::<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将默认页大小加入可选的页大小列表，在涉及大页分配的时候有用</span></span><br><span class="line">_page_sizes.<span class="built_in">add</span>(Linux::<span class="built_in">page_size</span>());</span><br></pre></td></tr></table></figure><h2 id="JVM-主要内存申请分配流程"><a href="#JVM-主要内存申请分配流程" class="headerlink" title="JVM 主要内存申请分配流程"></a>JVM 主要内存申请分配流程</h2><h3 id="每个子系统-Reserve-内存"><a href="#每个子系统-Reserve-内存" class="headerlink" title="每个子系统 Reserve 内存"></a>每个子系统 <code>Reserve</code> 内存</h3><p><strong>第一步，JVM 的每个子系统</strong>（例如 Java 堆，元空间，JIT 代码缓存，GC 等等等等），<strong>如果需要的话，在初始化的时候首先 <code>Reserve</code> 要分配区域的最大限制大小的内存</strong>（这个最大大小，需要按照<code>页大小对齐</code>（即是页大小的整数倍），默认页大小是前面提到的 <code>Linux::page_size()</code>），例如对于 Java 堆，就是最大堆大小（通过 <code>-Xmx</code> 或者 <code>-XX:MaxHeapSize</code>限制），还有对于代码缓存，也是最大代码缓存大小（通过 <code>-XX:ReservedCodeCacheSize</code> 限制）。Reserve 的目的是在虚拟内存空间划出一块内存专门给某个区域使用，这样做的好处是：</p><ol><li>隔离每个 JVM 子系统使用的内存的<code>虚拟空间</code>，这样在 JVM 代码有 bug 的时候（例如发生 Segment Fault 异常），通过报错中的<code>虚拟内存地址</code>可以快速定位到是哪个子系统出了问题。</li><li>可以很方便的限制这个区域使用的最大内存大小。</li><li>便于管理，<code>Reserve 不会触发操作系统分配映射实际物理内存</code>，这个区域可以在 Reserve 的区域内按需伸缩。</li><li>便于一些 JIT 优化，例如我们故意将这个区域保留起来但是故意不将这个区域的虚拟内存映射物理内存，访问这块内存会造成 Segment Fault 异常。JVM 会预设 Segment Fault 异常的处理器，在处理器里面检查发生 Segment Fault 异常的内存地址属于哪个子系统的 Reserve 的区域，判断要做什么操作。后面我们会看到，null 检查抛出 <code>NullPointerException</code> 异常的优化，全局安全点，抛出 <code>StackOverflowError</code> 的实现，都和这个机制有关。</li></ol><p>在 Linux 的环境下，Reserve 通过  <code>mmap(2)</code> 系统调用实现，参数传入 <code>prot = PROT_NONE</code>，<code>PROT_NONE</code> 代表不会使用，即<code>不能做任何操作，包括读和写</code>。如果 JVM 使用这块内存，会发生 Segment Fault 异常。</p><h3 id="每个子系统按照各自策略向操作系统申请映射物理内存"><a href="#每个子系统按照各自策略向操作系统申请映射物理内存" class="headerlink" title="每个子系统按照各自策略向操作系统申请映射物理内存"></a>每个子系统按照各自策略向操作系统申请映射物理内存</h3><p><strong>第二步，JVM 的每个子系统，按照各自的策略，通过 <code>Commit</code> 第一步 Reserve 的区域的<code>一部分扩展内存</code>（大小也一般页大小对齐的），从而<code>向操作系统申请映射物理内存</code>，通过 <code>Uncommit</code> 已经 Commit 的内存来释放物理内存给操作系统</strong></p><p>Commit 内存之后，并不是操作系统会立刻分配物理内存，而是在向 <code>Commit 的内存里面写入数据的时候，操作系统才会实际映射内存</code>，JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 AlwaysPreTouch 这个参数</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225875600644407357&quot;&gt;JVM 内存申请与使用流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Linux-下内存管理模型简述&quot;&gt;&lt;a href=&quot;#Linux-下内存管理模型简述&quot; class=&quot;headerlink&quot; title=&quot;Linux 下内存管理模型简述&quot;&gt;&lt;/a&gt;Linux 下内存管理模型简述&lt;/h2&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="linux内存" scheme="https://taeyang0126.github.io/tags/linux%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Statistics/Class Loading Statistics</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/</id>
    <published>2025-03-01T03:01:52.000Z</published>
    <updated>2025-03-01T03:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ClassLoadingStatistics</code></li><li>Label(Event Type，用于显示): Class Loading Statistics</li><li>Category(用于分类显示): Java Application，Statistics</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>定时事件</code>: 代表定时采集，没有线程栈信息，因为执行线程都是 <code>JFR Periodic Tasks</code> 线程，采集这个线程栈没有意义</li><li><code>JVM内部事件</code></li></ul></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li><code>Loaded Class Count</code>: 加载类的个数 _class_loaded_count + _shard_classes_loaded_count</li><li><code>UnLoaded Class Count</code>: 卸载类的个数 _class_unloaded_count + _shard_classes_unloaded_count</li><li>这两个字段都是类似于 <code>OpenTelemetry</code> 中的 <code>Gauge</code> 类型字段，瞬时值</li><li>由此可以推测出，当前 JVM 内存中有多少个类 &#x3D; <code>Loaded Class Count - UnLoaded Class Count</code></li></ul><h3 id="采集原理"><a href="#采集原理" class="headerlink" title="采集原理"></a>采集原理</h3><ul><li>每隔 1000ms（默认配置），生成 <code>jdk.ClassLoadingStatistics</code> 事件</li><li>即在 JVM 层面，读取 <code>ClassLoadingService</code> 中的统计数据:<ul><li>加载类的个数: _class_loaded_count + _shard_classes_loaded_count</li><li>卸载类的个数: _class_unloaded_count + _shard_classes_unloaded_count</li></ul></li></ul><h3 id="统计数据的更新时机"><a href="#统计数据的更新时机" class="headerlink" title="统计数据的更新时机"></a>统计数据的更新时机</h3><ul><li>_classes_loaded_count: 每次通过非 CDS 方式加载一个类的时候 +1</li><li>_shard_classes_loaded_count: 每次通过 CDS 方式加载一个类的时候 +1</li><li>_class_unloaded_count: 每次卸载一个非 CDS 类的时候 +1</li><li>_shard_classes_unloaded_count: 每次卸载一个 CDS 类的时候 +1</li></ul><h3 id="什么是-CDS（Class-Data-Sharing）"><a href="#什么是-CDS（Class-Data-Sharing）" class="headerlink" title="什么是 CDS（Class Data Sharing）"></a>什么是 CDS（Class Data Sharing）</h3><ul><li><a href="https://openjdk.org/jeps/310">CDS</a></li><li>Java 10 引入，允许多个 Java 应用程序共享相同的类数据，这样可以减少内存占用</li><li>在启动时，JVM 可以从共享的类数据存储中加载类元数据，而不是每次都从 JAR 文件或类文件中读取</li></ul><h3 id="jfr事件观察"><a href="#jfr事件观察" class="headerlink" title="jfr事件观察"></a>jfr事件观察</h3><blockquote><p>使用 <code>spring-petclinic</code> 项目测试</p></blockquote><ul><li><img data-src="/images/jfr/27.png" alt="img"></li><li>使用图表类型，将两个指标放在折线图中，同时将默认的柱状图隐藏</li></ul><h3 id="还有哪些地方能看到这个事件相同的指标数据？"><a href="#还有哪些地方能看到这个事件相同的指标数据？" class="headerlink" title="还有哪些地方能看到这个事件相同的指标数据？"></a>还有哪些地方能看到这个事件相同的指标数据？</h3><ul><li>_classes_loaded_count，_shard_classes_loaded_count，_classes_unloaded_count，_shard_classes_unloaded_count 这四个在 JVM内部<br>都是通过 <code>PerfDataManager</code> 实现</li><li>所有 <code>PerfDataManager</code> 的数据，JVM 通过下面的虚拟文件暴露出来了<ul><li>默认位置: 临时文件目录 <code>/hsperfdata_用户/进程号</code><br><img data-src="/images/jfr/28.png" alt="img"></li></ul></li><li>很多 JVM 监控工具，比如 Jvisualvm，JConsole 等等，都会访问这个虚拟文件拿实时指标</li><li>Jstat 类加载数据也是读取这个<br><img data-src="/images/jfr/29.png" alt="img"></li><li>Java Mbean 里面也是读取的这些指标<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ManagementFactory.getClassLoadingMXBean().getTotalLoadedClassCount(); <span class="comment">// 等同于事件中的 loadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount(); <span class="comment">// 等同于事件中的 unloadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getLoadedClassCount(); <span class="comment">// 即 loadedClassCount - unloadedClassCount</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h3><ul><li>该事件默认开启，1s采集一次，消耗很小很小，是读取一个现成的 JVM 内部指标，不是通过遍历某个数据结构计数实现。</li><li>使用下面的视图，可以发现类加载和类卸载急剧变化的时候<br><img data-src="/images/jfr/27.png" alt="img"></li><li>一般用来定位：<ol><li>异常大量类加载的问题: 一些反序列化框架，例如老版本 fastjson，利用ASM 定义类加速反序列化，但是由于缓存设计有问题，导致某些情况<br>反序列化会加载大量的类</li><li>大量类的反复加载与卸载的性能问题: 有大量这样的类: 同一个类，一会加载，一会卸载。一般发生在使用大量 lambda 表达式的时候。</li></ol></li><li>需要结合哪些东西一起定位:<ul><li>由于这个事件只能找到变化大的时间段</li><li>具体要定位是哪些类，可以:<ul><li>添加类加载和类卸载日志: <code>-Xlog:class+load,class+unload</code> 这两个，默认的 info 级别就够<br><img data-src="/images/jfr/30.png" alt="img"></li><li>结合其他类加载相关 JFR 事件一起</li></ul></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ClassLoadingStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Class Loading Statistics&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application，Statistics&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;定时事件&lt;/code&gt;: 代表定时采集，没有线程栈信息，因为执行线程都是 &lt;code&gt;JFR Periodic Tasks&lt;/code&gt; 线程，采集这个线程栈没有意义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="类加载" scheme="https://taeyang0126.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Z Allocation Stall</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/</id>
    <published>2025-03-01T02:01:52.000Z</published>
    <updated>2025-03-01T02:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ZAllocationStall</code></li><li>Label(Event Type，用于显示): Z Allocation Stall</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java15</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>ZGC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足</li><li><code>ZGC</code> 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，<br>不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 <code>Allocation Stall</code>（从而被<code>Z Allocation Stall</code>这个事件采集到），<br>但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>ZGC</code></li><li>在 GC 速度跟不上应用线程分配对象的速度时，应用线程尝试分配内存但是内存不足以分配的时候，该线程遇到 <code>Allocation Stall</code>，从而触发这个事件</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Duration</code>: 线程因 Allocation Stall 被阻塞等待 GC 回收足够内存的时间</li><li><code>Size</code>: 触发事件的分配大小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li><code>Type</code>: 从哪个区域分配（不同区域的分配策略，以及扫描回收的策略不一样）<ul><li>small: 小对象在这个区域分配</li><li>medium: 如果最大堆内存大于一定程度，就没必须有 medium。大于一定程度的堆内存，需要在 small 和 large 之间再增加一个区域粒度进行分配和管理</li><li>large: 大对象在这个区域分配</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）<br>启动参数使用 ZGC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// -Xmx32m</span></span><br><span class="line">      <span class="comment">// jdk 23</span></span><br><span class="line">      <span class="comment">// -XX:+UseZGC</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件和 JavaErrorThrow 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">      <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// jfr 启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个 8 * 1G 的数组（ZGC无法使用压缩指针），超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">        Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Z Allocation Stall</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/25.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz();</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM();</span><br><span class="line">  </span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">      T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">            objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">            <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">              objects.clear();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/26.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>保持打开这个事件的采集<ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 Allocation Stall 基本就能采集到，针对大对象，大概率可以采集到，如果对象大小大于 Java 堆内存，必定可以采集到</li><li>对于持续小对象的内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，看到的噪声比较多。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ZAllocationStall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Z Allocation Stall&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java15&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;ZGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZGC&lt;/code&gt; 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，&lt;br&gt;不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 &lt;code&gt;Allocation Stall&lt;/code&gt;（从而被&lt;code&gt;Z Allocation Stall&lt;/code&gt;这个事件采集到），&lt;br&gt;但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Allocation Requiring GC</title>
    <link href="https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/</id>
    <published>2025-02-24T12:55:52.000Z</published>
    <updated>2025-02-24T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.AllocationRequiringGC</code></li><li>Label(Event Type，用于显示): Allocation Requiring GC</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>触发<a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程-路径四</a>分配，<code>在 GC 之前</code>，会触发这个事件的采集</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Pending GC Identifier</code>: 即将触发的 GC ID(每次发生垃圾回收时，JVM 会生成一个全局自增 GC ID，以便于跟踪和分析不同的垃圾回收事件)</li><li>Size: 触发事件的分配发小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// -Xmx32m</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件和 JavaErrorThrow 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line">        <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jfr 启动</span></span><br><span class="line">        recording.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分配一个 4 * 1G 的数组，超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">            <span class="comment">// 为什么这里分配1g的数组，实际对象有4g呢？</span></span><br><span class="line">            <span class="comment">// 1. 如果对象引用启用了压缩指针，那么是4字节</span></span><br><span class="line">            <span class="comment">// 2. 如果使用的是ZGC，由于ZGC没法使用压缩指针，所以是8字节</span></span><br><span class="line">            <span class="comment">// 3. 如果超过32g的内存，也是没法使用压缩指针的，因为四字节就不够用了(无法寻址)</span></span><br><span class="line">            Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                    <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                            + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                            + ProcessHandle.current().pid()</span><br><span class="line">                            + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">            ).toPath();</span><br><span class="line">            recording.dump(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Allocation Requiring GC</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/23.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/24.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>默认没有打开，<code>非常建议打开这个事件的采集</code><ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 GC <code>基本就能采集到</code>，针对大对象，大概率可以采集到。如果对象大小<br>大于 Java 对象堆内存，必定可以采集到</li><li>对于持续小对象内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，会看到噪声比较多。</li></ul></li><li>该事件适合定位的问题<ul><li><code>大对象分配</code>：适合度<code>80%</code>。无论是否分配成功，只要触发了 GC 就都会上报这个事件。对于由于分配大对象导致的<br>OufOfMemoryError（比如一不小心执行了一个扫描全表的 SQL 返回数据的时候），特别合适</li><li><code>Java 堆对象内存泄漏</code>：适合度<code>60%</code>。对于大对象直接导致的 OufOfMemoryError 比较好定位。对于较大对象堆积导致的内存泄漏最终触发 OufOfMemoryError，<br>也比较合适，因为大概率会被采集到。但是对于持续小对象的内存泄漏，这个事件的适合度就比较低了，可能被正常分配导致 GC 的事件覆盖掉了。</li><li><code>GC 过于频繁</code>：适合度<code>50%</code>。对于 GC 过于频繁（比如 GC 暂停时间占应用运行时间的比例超过的一定比例），可以通过这个事件的上报，找到是哪个对象触发导致的<br>GC过于频繁，一般触发的对象比较大或者某一类对象出现的过于频繁，就可以考虑优化这个调用栈去减少 GC。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.AllocationRequiringGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Allocation Requiring GC&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;SerialGC，ParallelGC 或者 G1GC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>java在容器中运行的脚本解析</title>
    <link href="https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/</id>
    <published>2025-02-23T09:46:30.000Z</published>
    <updated>2025-02-23T09:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/files/java/run.sh">run.sh</a></li></ul><h3 id="基础运行命令"><a href="#基础运行命令" class="headerlink" title="基础运行命令"></a>基础运行命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./run.sh           # 直接运行Java应用</span><br><span class="line">./run.sh run       # 同上</span><br><span class="line">./run.sh options   # 打印可用的Java选项</span><br></pre></td></tr></table></figure><h3 id="通过环境变量启用的功能"><a href="#通过环境变量启用的功能" class="headerlink" title="通过环境变量启用的功能"></a>通过环境变量启用的功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试相关</span></span><br><span class="line">export JAVA_ENABLE_DEBUG=true    # 启用远程调试</span><br><span class="line">export JAVA_DEBUG_PORT=5005      # 设置调试端口(默认5005)</span><br><span class="line">export JAVA_DEBUG_SUSPEND=y      # 启动时暂停等待调试器连接</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存相关</span></span><br><span class="line">export JAVA_MAX_MEM_RATIO=80     # 设置最大堆内存占比(默认50%)</span><br><span class="line">export JAVA_INIT_MEM_RATIO=25    # 设置初始堆内存占比</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">诊断相关</span></span><br><span class="line">export JAVA_DIAGNOSTICS=true     # 启用诊断功能</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">效果：启用GC日志、内存跟踪等</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代理相关</span></span><br><span class="line">export HTTP_PROXY=&quot;http://proxy:8080&quot;    # 设置HTTP代理</span><br><span class="line">export HTTPS_PROXY=&quot;https://proxy:8080&quot;   # 设置HTTPS代理</span><br><span class="line">export NO_PROXY=&quot;localhost,127.0.0.1&quot;     # 设置不使用代理的地址</span><br><span class="line"></span><br><span class="line">export JAVA_APP_NAME=&quot;myapp&quot;    # 设置进程名称</span><br><span class="line">export JAVA_MAIN_CLASS=&quot;com.example.Main&quot;  # 指定主类</span><br><span class="line">export JAVA_APP_JAR=&quot;app.jar&quot;   # 指定JAR包</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">===================================================================================</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个用于在容器中运行Java应用的通用启动脚本</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Usage:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="comment"># 可以直接运行Java应用:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh 参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#    # 可以获取Java选项:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh options</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This script will pick up either a <span class="string">&#x27;fat&#x27;</span> jar <span class="built_in">which</span> can be run with <span class="string">&quot;-jar&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or you can sepcify a JAVA_MAIN_CLASS.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 脚本来自于以下项目:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at https://github.com/fabric8io-images/run-java-sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Env-variables evaluated in this script:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># JAVA_OPTIONS: Checked for already set options(设置java参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_MAX_MEM_RATIO: Ratio use to calculate a default maximum Memory, <span class="keyword">in</span> percent.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    用于计算默认最大内存的比例 容器内存*JAVA_MAX_MEM_RATIO=-Xmx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    默认情况下容器内存&lt;300，设置为25，超过则设置为50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    For a good overviews what tuning options are available --&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://youtu.be/Vt4G-pHXfs4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://www.youtube.com/watch?v=w1rZOY5gbvk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://vimeo.com/album/4133413/video/181900266</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还请注意，堆只是 JVM 使用的内存的一小部分。还有很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他内存区域（元数据、线程、代码缓存等），这会增加整体</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大小。当您的容器因 OOM 而终止时，您应该调整</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绝对值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_INIT_MEM_RATIO：用于计算默认初始堆内存的比例（百分比）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下未设置此值。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 以下变量将暴露给您的 Java 应用程序：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># CONTAINER_MAX_MEMORY：容器的最大内存（如果在容器内运行）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAX_CORE_LIMIT：容器可用的内核数（如果在容器内运行）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">==========================================================</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fail on a single failed <span class="built_in">command</span> <span class="keyword">in</span> a pipeline (<span class="keyword">if</span> supported)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查并启用pipefail选项(如果支持) - 使管道中任一命令失败时整个管道都失败</span></span><br><span class="line">(set -o | grep -q pipefail) &amp;&amp; set -o pipefail</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遇到错误就终止执行，使用未定义变量时报错</span></span><br><span class="line">set -eu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存所有传入的参数到ARGS变量</span></span><br><span class="line">ARGS=&quot;$@&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否在ksh环境</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是,将<span class="built_in">local</span>命令别名为<span class="built_in">typeset</span>(ksh使用<span class="built_in">typeset</span>声明局部变量)</span></span><br><span class="line">if [ -n &quot;$&#123;KSH_VERSION:-&#125;&quot; ]; then</span><br><span class="line">  alias local=typeset</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Error is indicated with a prefix <span class="keyword">in</span> the <span class="built_in">return</span> value 错误检查函数</span></span><br><span class="line">check_error() &#123;</span><br><span class="line">  local error_msg=&quot;$1&quot;</span><br><span class="line">  if echo &quot;$&#123;error_msg&#125;&quot; | grep -q &quot;^ERROR:&quot;; then</span><br><span class="line">    echo &quot;$&#123;error_msg&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The full qualified directory <span class="built_in">where</span> this script is located <span class="keyword">in</span> 获取脚本所在目录</span></span><br><span class="line">script_dir() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Default is current directory</span></span><br><span class="line">  local dir=$(dirname &quot;$0&quot;)</span><br><span class="line">  local full_dir=$(cd &quot;$&#123;dir&#125;&quot; &amp;&amp; pwd)</span><br><span class="line">  echo $&#123;full_dir&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Try hard to find a sane default jar-file</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动检测JAR文件</span></span><br><span class="line">auto_detect_jar_file() &#123;</span><br><span class="line">  local dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Filter out temporary jars from the shade plugin <span class="built_in">which</span> start with <span class="string">&#x27;original-&#x27;</span></span></span><br><span class="line">  local old_dir=&quot;$(pwd)&quot;</span><br><span class="line">  cd $&#123;dir&#125;</span><br><span class="line">  if [ $? = 0 ]; then</span><br><span class="line">    # NB: Find both (single) JAR *or* WAR &lt;https://github.com/fabric8io-images/run-java-sh/issues/79&gt;</span><br><span class="line">    local nr_jars=&quot;$(ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27; | wc -l | awk &#x27;&#123;print $1&#125;&#x27;)&quot;</span><br><span class="line">    if [ &quot;$&#123;nr_jars&#125;&quot; = 1 ]; then</span><br><span class="line">      ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27;</span><br><span class="line">      exit 0</span><br><span class="line">    fi</span><br><span class="line">    cd &quot;$&#123;old_dir&#125;&quot;</span><br><span class="line">    echo &quot;ERROR: Neither JAVA_MAIN_CLASS nor JAVA_APP_JAR is set and $&#123;nr_jars&#125; found in $&#123;dir&#125; (1 expected)&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;ERROR: No directory $&#123;dir&#125; found for auto detection&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check directories (arg 2...n) <span class="keyword">for</span> a jar file (arg 1) 在指定目录中查找jar文件</span></span><br><span class="line">find_jar_file() &#123;</span><br><span class="line">  local jar=&quot;$1&quot;</span><br><span class="line">  shift;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Absolute path check <span class="keyword">if</span> jar specifies an absolute path</span></span><br><span class="line">  if [ &quot;$&#123;jar&#125;&quot; != $&#123;jar#/&#125; ]; then</span><br><span class="line">    if [ -f &quot;$&#123;jar&#125;&quot; ]; then</span><br><span class="line">      echo &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;ERROR: No such file $&#123;jar&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    for dir in $*; do</span><br><span class="line">      if [ -f &quot;$&#123;dir&#125;/$jar&quot; ]; then</span><br><span class="line">        echo &quot;$&#123;dir&#125;/$jar&quot;</span><br><span class="line">        return</span><br><span class="line">      fi</span><br><span class="line">    done</span><br><span class="line">    echo &quot;ERROR: No $&#123;jar&#125; found in $*&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generic formula evaluation based on awk 数学计算函数</span></span><br><span class="line">calc() &#123;</span><br><span class="line">  local formula=&quot;$1&quot;</span><br><span class="line">  shift</span><br><span class="line">  echo &quot;$@&quot; | awk &#x27;</span><br><span class="line">    function ceil(x) &#123;</span><br><span class="line">      return x % 1 ? int(x) + 1 : x</span><br><span class="line">    &#125;</span><br><span class="line">    function log2(x) &#123;</span><br><span class="line">      return log(x)/log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    function max2(x, y) &#123;</span><br><span class="line">      return x &gt; y ? x : y</span><br><span class="line">    &#125;</span><br><span class="line">    function round(x) &#123;</span><br><span class="line">      return int(x + 0.5)</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;print &#x27;&quot;int($&#123;formula&#125;)&quot;&#x27;&#125;</span><br><span class="line">  &#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Based on the cgroup limits, figure out the max number of core we should utilize</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算容器的CPU核心限制</span></span><br><span class="line">core_limit() &#123;</span><br><span class="line">  local cpu_period_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;</span><br><span class="line">  local cpu_quota_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;</span><br><span class="line">  if [ -r &quot;$&#123;cpu_period_file&#125;&quot; ]; then</span><br><span class="line">    local cpu_period=&quot;$(cat $&#123;cpu_period_file&#125;)&quot;</span><br><span class="line"></span><br><span class="line">    if [ -r &quot;$&#123;cpu_quota_file&#125;&quot; ]; then</span><br><span class="line">      local cpu_quota=&quot;$(cat $&#123;cpu_quota_file&#125;)&quot;</span><br><span class="line">      # cfs_quota_us == -1 --&gt; no restrictions</span><br><span class="line">      if [ $&#123;cpu_quota:-0&#125; -ne -1 ]; then</span><br><span class="line">        echo $(calc &#x27;ceil($1/$2)&#x27; &quot;$&#123;cpu_quota&#125;&quot; &quot;$&#123;cpu_period&#125;&quot;)</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确定容器的最大内存限制</span></span><br><span class="line">max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">High number <span class="built_in">which</span> is the max <span class="built_in">limit</span> <span class="keyword">until</span> <span class="built_in">which</span> memory is supposed to be</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">unbounded.</span></span><br><span class="line">  local mem_file=&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</span><br><span class="line">  if [ -r &quot;$&#123;mem_file&#125;&quot; ]; then</span><br><span class="line">    local max_mem_cgroup=&quot;$(cat $&#123;mem_file&#125;)&quot;</span><br><span class="line">    local max_mem_meminfo_kb=&quot;$(cat /proc/meminfo | awk &#x27;/MemTotal/ &#123;print $2&#125;&#x27;)&quot;</span><br><span class="line">    local max_mem_meminfo=&quot;$(expr $max_mem_meminfo_kb \* 1024)&quot;</span><br><span class="line">    if [ $&#123;max_mem_cgroup:-0&#125; != -1 ] &amp;&amp; [ $&#123;max_mem_cgroup:-0&#125; -lt $&#123;max_mem_meminfo:-0&#125; ]</span><br><span class="line">    then</span><br><span class="line">      echo &quot;$&#123;max_mem_cgroup&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化容器限制相关的环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取并设置CPU核心限制，获取并设置内存限制，这些变量后续会被Java应用使用</span></span><br><span class="line">init_limit_env_vars() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Read <span class="keyword">in</span> container limits and <span class="built_in">export</span> the as environment variables</span></span><br><span class="line">  local core_limit=&quot;$(core_limit)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;core_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_CORE_LIMIT=&quot;$&#123;core_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local mem_limit=&quot;$(max_memory)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;mem_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_MAX_MEMORY=&quot;$&#123;mem_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取Java主版本号</span></span><br><span class="line">init_java_major_version() &#123;</span><br><span class="line">    # Initialize JAVA_MAJOR_VERSION variable if missing</span><br><span class="line">    if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ]; then</span><br><span class="line">        local full_version=&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Parse JAVA_VERSION variable available in containers</span><br><span class="line">        if [ -n &quot;$&#123;JAVA_VERSION:-&#125;&quot; ]; then</span><br><span class="line">            full_version=&quot;$JAVA_VERSION&quot;</span><br><span class="line">        elif [ -n &quot;$&#123;JAVA_HOME:-&#125;&quot; ] &amp;&amp; [ -r &quot;$&#123;JAVA_HOME&#125;/release&quot; ]; then</span><br><span class="line">            full_version=&quot;$(grep -e &#x27;^JAVA_VERSION=&#x27; $&#123;JAVA_HOME&#125;/release | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)&quot;</span><br><span class="line">        else</span><br><span class="line">            full_version=$(java -version 2&gt;&amp;1 | head -1 | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)</span><br><span class="line">        fi</span><br><span class="line">        export JAVA_MAJOR_VERSION=$(echo $full_version | sed -e &#x27;s/[^0-9]*\(1\.\)\&#123;0,1\&#125;\([0-9]\&#123;1,\&#125;\).*/\2/&#x27;)</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载环境配置</span></span><br><span class="line">load_env() &#123;</span><br><span class="line">  local script_dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Configuration stuff is <span class="built_in">read</span> from this file</span></span><br><span class="line">  local run_env_sh=&quot;run-env.sh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Load default default config</span></span><br><span class="line">  if [ -f &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Check also <span class="variable">$JAVA_APP_DIR</span>. Overrides other defaults</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">It<span class="string">&#x27;s valid to set the app dir in the default script</span></span></span><br><span class="line">  JAVA_APP_DIR=&quot;$&#123;JAVA_APP_DIR:-$&#123;script_dir&#125;&#125;&quot;</span><br><span class="line">  if [ -f &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  export JAVA_APP_DIR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JAVA_LIB_DIR defaults to JAVA_APP_DIR</span></span></span><br><span class="line">  export JAVA_LIB_DIR=&quot;$&#123;JAVA_LIB_DIR:-$&#123;JAVA_APP_DIR&#125;&#125;&quot;</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] &amp;&amp; [ -z &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    JAVA_APP_JAR=&quot;$(auto_detect_jar_file $&#123;JAVA_APP_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    local jar=&quot;$(find_jar_file $&#123;JAVA_APP_JAR&#125; $&#123;JAVA_APP_DIR&#125; $&#123;JAVA_LIB_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    export JAVA_APP_JAR=&quot;$&#123;jar&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    export JAVA_MAIN_CLASS</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for standard /opt/run-java-options first, fallback to run-java-options in the path if not existing</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">获取Java运行选项(优先 /opt/run-java-options)</span></span></span><br><span class="line">run_java_options() &#123;</span><br><span class="line">  if [ -f &quot;/opt/run-java-options&quot; ]; then</span><br><span class="line">    echo &quot;$(. /opt/run-java-options)&quot;</span><br><span class="line">  else</span><br><span class="line">    which run-java-options &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    if [ $? = 0 ]; then</span><br><span class="line">      echo &quot;$(run-java-options)&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置java debug，远程debug</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">JAVA_ENABLE_DEBUG = true</span></span></span><br><span class="line">debug_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_ENABLE_DEBUG:-&#125;&quot; ] || [ -n &quot;$&#123;JAVA_DEBUG_ENABLE:-&#125;&quot; ] ||  [ -n &quot;$&#123;JAVA_DEBUG:-&#125;&quot; ]; then</span><br><span class="line">  local debug_port=&quot;$&#123;JAVA_DEBUG_PORT:-5005&#125;&quot;</span><br><span class="line">    local suspend_mode=&quot;n&quot;</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_DEBUG_SUSPEND:-&#125;&quot; ]; then</span><br><span class="line">      if ! echo &quot;$&#123;JAVA_DEBUG_SUSPEND&#125;&quot; | grep -q -e &#x27;^\(false\|n\|no\|0\)$&#x27;; then</span><br><span class="line">        suspend_mode=&quot;y&quot;</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local address_prefix=&quot;&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;9&quot; ]; then</span><br><span class="line">      address_prefix=&quot;*:&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=$&#123;suspend_mode&#125;,address=$&#123;address_prefix&#125;$&#123;debug_port&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read in a classpath either from a file with a single line, colon separated</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">or given line-by-line in separate lines</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Arg 1: path to claspath (must exist), optional arg2: application jar, which is stripped from the classpath in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">multi line arrangements</span></span></span><br><span class="line">format_classpath() &#123;</span><br><span class="line">  local cp_file=&quot;$1&quot;</span><br><span class="line">  local app_jar=&quot;$&#123;2:-&#125;&quot;</span><br><span class="line"></span><br><span class="line">  local wc_out=&quot;$(wc -l $1 2&gt;&amp;1)&quot;</span><br><span class="line">  if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;Cannot read lines in $&#123;cp_file&#125;: $wc_out&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local nr_lines=$(echo $wc_out | awk &#x27;&#123; print $1 &#125;&#x27;)</span><br><span class="line">  if [ $&#123;nr_lines&#125; -gt 1 ]; then</span><br><span class="line">    local sep=&quot;&quot;</span><br><span class="line">    local classpath=&quot;&quot;</span><br><span class="line">    while read file; do</span><br><span class="line">      local full_path=&quot;$&#123;JAVA_LIB_DIR&#125;/$&#123;file&#125;&quot;</span><br><span class="line">      # Don&#x27;t include app jar if include in list</span><br><span class="line">      if [ &quot;$&#123;app_jar&#125;&quot; != &quot;$&#123;full_path&#125;&quot; ]; then</span><br><span class="line">        classpath=&quot;$&#123;classpath&#125;$&#123;sep&#125;$&#123;full_path&#125;&quot;</span><br><span class="line">      fi</span><br><span class="line">      sep=&quot;:&quot;</span><br><span class="line">    done &lt; &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">    echo &quot;$&#123;classpath&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    # Supposed to be a single line, colon separated classpath file</span><br><span class="line">    cat &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==========================================================================</span></span></span><br><span class="line"></span><br><span class="line">memory_options() &#123;</span><br><span class="line">  echo &quot;$(calc_init_memory) $(calc_max_memory)&quot;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set max heap size if needed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">根据不同条件自动计算并设置JVM的最大堆内存(-Xmx参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">主要逻辑：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">优先级判断：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已在JAVA_OPTIONS中设置了-Xmx，则保持用户设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果没有设置容器最大内存(CONTAINER_MAX_MEMORY)，则不进行设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">堆内存计算规则(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果设置了JAVA_MAX_MEM_RATIO：使用指定比例计算</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果是Java 10+且未设置JAVA_MAX_MEM_RATIO：不设置最大内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 ≤ 300MB：设为容器内存的25%</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 &gt; 300MB：设为容器内存的50%</span></span></span><br><span class="line">calc_max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xmx is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xmx&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check for the &#x27;</span>real memory size<span class="string">&#x27; and calculate Xmx from the ratio</span></span></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAX_MEM_RATIO:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">      # Explicitely switched off</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; &quot;mx&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">When JAVA_MAX_MEM_RATIO not set and JVM &gt;= 10 no max_memory</span></span></span><br><span class="line">  elif [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  elif [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">    # Restore the one-fourth default heap size instead of the one-half below 300MB threshold</span><br><span class="line">    # See https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;25&quot; &quot;mx&quot;</span><br><span class="line">  else</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;50&quot; &quot;mx&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set initial heap size if requested</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">calc_init_memory 的核心功能：计算并设置JVM的初始堆内存大小(-Xms参数)。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断逻辑(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS中已有-Xms，使用用户设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果未设置JAVA_INIT_MEM_RATIO或容器内存，不设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果设置了上述参数，用公式计算：初始堆内存 = 容器内存 × (JAVA_INIT_MEM_RATIO/100)</span></span></span><br><span class="line">calc_init_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xms is already given in JAVA_OPTIONS.</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xms&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check if value set</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_INIT_MEM_RATIO:-&#125;&quot; ] || [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ] || [ &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Calculate Xms from the ratio given</span></span></span><br><span class="line">  calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; &quot;ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xmx -Xms</span></span></span><br><span class="line">calc_mem_opt() &#123;</span><br><span class="line">  local max_mem=&quot;$1&quot;</span><br><span class="line">  local fraction=&quot;$2&quot;</span><br><span class="line">  local mem_opt=&quot;$3&quot;</span><br><span class="line"></span><br><span class="line">  local val=$(calc &#x27;round($1*$2/100/1048576)&#x27; &quot;$&#123;max_mem&#125;&quot; &quot;$&#123;fraction&#125;&quot;)</span><br><span class="line">  echo &quot;-X$&#123;mem_opt&#125;$&#123;val&#125;m&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">当容器内存 ≤ 300MB (314572800字节) 时，禁用C2编译器</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">其他情况启用</span></span></span><br><span class="line">c2_disabled() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    # Disable C2 compiler when container memory &lt;=300MB</span><br><span class="line">    if [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">      echo true</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo false</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">jit_options 函数决定JVM的即时编译器(JIT)级别：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断流程：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS已有TieredStopAtLevel配置则用用户配置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">内存≤300MB时，返回 -XX:TieredStopAtLevel=1，只用C1编译器节省内存</span></span></span><br><span class="line">jit_options() &#123;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -XX:TieredStopAtLevel is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:TieredStopAtLevel&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line">  if [ $(c2_disabled) = true ]; then</span><br><span class="line">    echo &quot;-XX:TieredStopAtLevel=1&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Switch on diagnostics except when switched off</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11+版本：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xlog:gc*:stdout:time            // 统一日志格式输出GC日志</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGC                      // 打印GC信息</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCDateStamps           // 打印GC时间戳</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCTimeStamps           // 打印GC耗时</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line">diagnostics_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_DIAGNOSTICS:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;11&quot; ]; then</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -Xlog:gc*:stdout:time -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Replicate thread ergonomics for tiered compilation.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This could ideally be skipped when tiered compilation is disabled.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The algorithm is taken from:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">OpenJDK / jdk8u / jdk8u / hotspot</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">src/share/vm/runtime/advancedThresholdPolicy.cpp</span></span></span><br><span class="line">ci_compiler_count() &#123;</span><br><span class="line">  local core_limit=&quot;$1&quot;</span><br><span class="line">  local log_cpu=$(calc &#x27;log2($1)&#x27; &quot;$core_limit&quot;)</span><br><span class="line">  local loglog_cpu=$(calc &#x27;log2(max2($1,1))&#x27; &quot;$log_cpu&quot;)</span><br><span class="line">  local count=$(calc &#x27;max2($1*$2,1)*3/2&#x27; &quot;$log_cpu&quot; &quot;$loglog_cpu&quot;)</span><br><span class="line">  local c1_count=$(calc &#x27;max2($1/3,1)&#x27; &quot;$count&quot;)</span><br><span class="line">  local c2_count=$(calc &#x27;max2($1-$2,1)&#x27; &quot;$count&quot; &quot;$c1_count&quot;)</span><br><span class="line">  [ $(c2_disabled) = true ] &amp;&amp; echo &quot;$c1_count&quot; || echo $(calc &#x27;$1+$2&#x27; &quot;$c1_count&quot; &quot;$c2_count&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理(因为能自动识别容器CPU限制)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">当设置了容器CPU限制时，配置以下参数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ParallelGCThreads=核心数     // 并行GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ConcGCThreads=核心数        // 并发GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-Djava.util.concurrent.ForkJoinPool.common.parallelism=核心数  // ForkJoin池线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:CICompilerCount=动态计算值   // JIT编译器线程数</span></span></span><br><span class="line">cpu_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JVMs &gt;= 10 know about CPU limits</span></span></span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local core_limit=&quot;$&#123;JAVA_CORE_LIMIT:-&#125;&quot;</span><br><span class="line">  if [ &quot;$core_limit&quot; = &quot;0&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_CORE_LIMIT:-&#125;&quot; ]; then</span><br><span class="line">    if [ -z $&#123;core_limit&#125; ]; then</span><br><span class="line">      core_limit=&quot;$&#123;CONTAINER_CORE_LIMIT&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;-XX:ParallelGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:ConcGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-Djava.util.concurrent.ForkJoinPool.common.parallelism=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:CICompilerCount=$(ci_compiler_count $core_limit)&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MinHeapFreeRatio=20  These parameters tell the heap to shrink aggressively and to grow conservatively.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MaxHeapFreeRatio=40  Thereby optimizing the amount of memory available to the operating system.</span></span></span><br><span class="line">heap_ratio() &#123;</span><br><span class="line">  echo &quot;-XX:MinHeapFreeRatio=20 -XX:MaxHeapFreeRatio=40&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">These parameters are necessary when running parallel GC if you want to use the Min and Max Heap Free ratios.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Skip setting gc_options if any other GC is set in JAVA_OPTIONS.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已配置GC(比如-XX:UseG1GC)则不处理</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">对Java 10以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UseParallelGC                  # 使用并行GC</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4                   # GC时间占比不超过20%</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90     # GC自适应策略权重</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">$(heap_ratio)                       # 堆内存比例配置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">非Java7版本 -XX:+ExitOnOutOfMemoryError        # OOM时直接退出JVM</span></span></span><br><span class="line">gc_options() &#123;</span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:.*Use.*GC&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local opts=&quot;&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">for JVMs &lt; 10 set GC settings</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -lt &quot;10&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+UseParallelGC -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90 $(heap_ratio)&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; != &quot;7&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+ExitOnOutOfMemoryError&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo $opts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_default_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Echo options, trimming trailing and multiple spaces</span></span></span><br><span class="line">  echo &quot;$(memory_options) $(jit_options) $(diagnostics_options) $(cpu_options) $(gc_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">parse the URL</span></span></span><br><span class="line">parse_url() &#123;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="string">[scheme://][user[:password]@]host[:port][/path][?params]</span></span></span><br><span class="line">  echo &quot;$1&quot; | sed -e &quot;s+^\(\([^:]*\)://\)\?\(\([^:@]*\)\(:\([^@]*\)\)\?@\)\?\([^:/?]*\)\(:\([^/?]*\)\)\?.*$+ local scheme=&#x27;\2&#x27; username=&#x27;\4&#x27; password=&#x27;\6&#x27; hostname=&#x27;\7&#x27; port=&#x27;\9&#x27;+&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_proxy_options() &#123;</span><br><span class="line">  local url=&quot;$1&quot;</span><br><span class="line">  local transport=&quot;$2&quot;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$url&quot; ] ; then</span><br><span class="line">    eval $(parse_url &quot;$url&quot;)</span><br><span class="line">    if [ -n &quot;$hostname&quot; ] ; then</span><br><span class="line">      ret=&quot;-D$&#123;transport&#125;.proxyHost=$&#123;hostname&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$port&quot; ] ; then</span><br><span class="line">      ret=&quot;$ret -D$&#123;transport&#125;.proxyPort=$&#123;port&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$username&quot; -o -n &quot;$password&quot; ] ; then</span><br><span class="line">      echo &quot;WARNING: Proxy URL for $&#123;transport&#125; contains authentication credentials, these are not supported by java&quot; &gt;&amp;2</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for proxy options and echo if enabled.</span></span></span><br><span class="line">proxy_options() &#123;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line">  ret=&quot;$(java_proxy_options &quot;$&#123;https_proxy:-$&#123;HTTPS_PROXY:-&#125;&#125;&quot; https)&quot;</span><br><span class="line">  ret=&quot;$ret $(java_proxy_options &quot;$&#123;http_proxy:-$&#123;HTTP_PROXY:-&#125;&#125;&quot; http)&quot;</span><br><span class="line"></span><br><span class="line">  local noProxy=&quot;$&#123;no_proxy:-$&#123;NO_PROXY:-&#125;&#125;&quot;</span><br><span class="line">  if [ -n &quot;$noProxy&quot; ] ; then</span><br><span class="line">    ret=&quot;$ret -Dhttp.nonProxyHosts=$(echo &quot;|$noProxy&quot; | sed -e &#x27;s/,[[:space:]]*/|/g&#x27; | sed -e &#x27;s/[[:space:]]//g&#x27; | sed -e &#x27;s/|\./|\*\./g&#x27; | cut -c 2-)&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set process name if possible</span></span></span><br><span class="line">exec_args() &#123;</span><br><span class="line">  EXEC_ARGS=&quot;&quot;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_NAME:-&#125;&quot; ]; then</span><br><span class="line">    # Not all shells support the &#x27;exec -a newname&#x27; syntax..</span><br><span class="line">    if $(exec -a test true 2&gt;/dev/null); then</span><br><span class="line">      echo &quot;-a &#x27;$&#123;JAVA_APP_NAME&#125;&#x27;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Combine all java options</span></span></span><br><span class="line">java_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Normalize spaces with awk (i.e. trim and elimate double spaces)</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">See e.g. https://www.physicsforums.com/threads/awk-1-1-1-file-txt.658865/ for an explanation</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">of this awk idiom</span></span></span><br><span class="line">  echo &quot;$&#123;JAVA_OPTIONS:-&#125; $(run_java_options) $(debug_options) $(proxy_options) $(java_default_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fetch classpath from env or from a local &quot;run-classpath&quot; file</span></span></span><br><span class="line">classpath() &#123;</span><br><span class="line">  local cp_path=&quot;.&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_LIB_DIR&#125;&quot; != &quot;$&#123;JAVA_APP_DIR&#125;&quot; ]; then</span><br><span class="line">    cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_LIB_DIR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ] &amp;&amp; [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ]; then</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -f &quot;$&#123;JAVA_LIB_DIR&#125;/classpath&quot; ]; then</span><br><span class="line">      # Classpath is pre-created and stored in a &#x27;run-classpath&#x27; file</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$(format_classpath $&#123;JAVA_LIB_DIR&#125;/classpath $&#123;JAVA_APP_JAR:-&#125;)&quot;</span><br><span class="line">    else</span><br><span class="line">      # No order implied</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_DIR&#125;/*&quot;</span><br><span class="line">    fi</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ]; then</span><br><span class="line">    # Given from the outside</span><br><span class="line">    cp_path=&quot;$&#123;JAVA_CLASSPATH&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$&#123;cp_path&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Checks if a flag is present in the arguments.</span></span></span><br><span class="line">hasflag() &#123;</span><br><span class="line">    local filters=&quot;$@&quot;</span><br><span class="line">    for var in $ARGS; do</span><br><span class="line">        for filter in $filters; do</span><br><span class="line">          if [ &quot;$var&quot; = &quot;$filter&quot; ]; then</span><br><span class="line">              echo &#x27;true&#x27;</span><br><span class="line">              return</span><br><span class="line">          fi</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">开启对应的配置</span></span></span><br><span class="line">options() &#123;</span><br><span class="line">    if [ -z $&#123;1:-&#125; ]; then</span><br><span class="line">      java_options</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local ret=&quot;&quot;</span><br><span class="line">    if [ $(hasflag --debug) ]; then</span><br><span class="line">      ret=&quot;$ret $(debug_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --proxy) ]; then</span><br><span class="line">      ret=&quot;$ret $(proxy_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --java-default) ]; then</span><br><span class="line">      ret=&quot;$ret $(java_default_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --memory) ]; then</span><br><span class="line">      ret=&quot;$ret $(memory_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --jit) ]; then</span><br><span class="line">      ret=&quot;$ret $(jit_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --diagnostics) ]; then</span><br><span class="line">      ret=&quot;$ret $(diagnostics_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --cpu) ]; then</span><br><span class="line">      ret=&quot;$ret $(cpu_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --gc) ]; then</span><br><span class="line">      ret=&quot;$ret $(gc_options)&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo $ret | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Start JVM</span></span></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Initialize environment</span></span></span><br><span class="line">  load_env $(script_dir)</span><br><span class="line"></span><br><span class="line">  local args</span><br><span class="line">  cd $&#123;JAVA_APP_DIR&#125;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] ; then</span><br><span class="line">     args=&quot;$&#123;JAVA_MAIN_CLASS&#125;&quot;</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">     args=&quot;-jar $&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">     echo &quot;Either JAVA_MAIN_CLASS or JAVA_APP_JAR needs to be given&quot;</span><br><span class="line">     exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != 1 ] &amp;&amp; [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != true ]; then</span><br><span class="line">    echo exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Don&#x27;</span>t put <span class="variable">$&#123;args&#125;</span> <span class="keyword">in</span> quotes, otherwise it would be interpreted as a single arg.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">However it could be two args (see above). zsh doesn<span class="string">&#x27;t like this btw, but zsh is not</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">supported anyway.</span></span></span><br><span class="line">  exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">=============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fire up</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Initialize JAVA_MAJOR_VERSION variable if missing</span></span></span><br><span class="line">init_java_major_version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set env vars reflecting limits</span></span></span><br><span class="line">init_limit_env_vars</span><br><span class="line"></span><br><span class="line">first_arg=$&#123;1:-&#125;</span><br><span class="line">if [ &quot;$&#123;first_arg&#125;&quot; = &quot;options&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Print out options only</span></span></span><br><span class="line">  shift</span><br><span class="line">  options $@</span><br><span class="line">  exit 0</span><br><span class="line">elif [ &quot;$&#123;first_arg&#125;&quot; = &quot;run&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Run is the default command, but can be given to allow &quot;options&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">as first argument to your</span></span></span><br><span class="line">  shift</span><br><span class="line">fi</span><br><span class="line">run &quot;$@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/files/java/run.sh&quot;&gt;run.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础运行命令&quot;&gt;&lt;a href=&quot;#基础运行命令&quot; class=&quot;headerlink&quot; title=&quot;基础运行命令&quot;&gt;&lt;/a&gt;基础运行命令&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./run.sh           # 直接运行Java应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh run       # 同上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh options   # 打印可用的Java选项&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="run.sh" scheme="https://taeyang0126.github.io/tags/run-sh/"/>
    
    <category term="运行脚本" scheme="https://taeyang0126.github.io/tags/%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 1.Native Memory Tracking</title>
    <link href="https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/</id>
    <published>2025-02-23T01:46:30.000Z</published>
    <updated>2025-02-23T01:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</p></blockquote><ul><li><a href="https://juejin.cn/post/7225871227743043644">Native Memory Tracking</a></li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>Native Memory Tracking 主要是用来通过在 <code>JVM 向系统申请内存的时候进行埋点实现的</code>。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是有不小消耗的，这个 Native Memory Tracking 默认是不开启的，并且<code>无法动态开启</code>（因为这是埋点采集统计的，如果可以动态开启那么没开启的时候的内存分配没有记录无法知晓，所以无法动态开启），目前只能通过在启动 JVM 的时候通过启动参数开启。即通过 <code>-XX:NativeMemoryTracking</code> 开启:</p><ul><li><code>-XX:NativeMemoryTracking=off</code>:这是默认值，即关闭 Native Memory Tracking</li><li><code>-XX:NativeMemoryTracking=summary</code>: 开启 Native Memory Tracking，但是仅仅按照各个 JVM 子系统去统计内存占用情况</li><li><code>-XX:NativeMemoryTracking=detail</code>: 开启 Native Memory Tracking，从每次 JVM 中申请内存的不同调用路径的维度去统计内存占用情况。注意，开启 detail 比开启 summary 的消耗要大不少，因为 detail 每次都要解析 CallSite 分辨调用位置。我们一般用不到这么详细的内容，除非是 JVM 开发。</li></ul><p>开启之后，我们可以通过 jcmd 命令去查看 Native Memory Tracking 的信息，即<code>jcmd &lt;pid&gt; VM.native_memory</code>：</p><ul><li><code>jcmd &lt;pid&gt; VM.native_memory</code>或者<code>jcmd &lt;pid&gt; VM.native_memory summary</code>：两者是等价的，即查看 Native Memory Tracking 的 summary 信息。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory summary scale&#x3D;MB</li><li><code>jcmd &lt;pid&gt; VM.native_memory detail</code>：查看 Native Memory Tracking 的 detail 信息，包括 summary 信息，以及按照虚拟内存映射分组的内存使用信息，还有按照不同 CallSite 调用分组的内存使用情况。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory detail scale&#x3D;MB</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>我们只关心并且查看 Native Memory Tracking 的 summary 信息即可，detail 信息一般是供 JVM 开发人员使用的，我们不用太关心</p></blockquote><p>一般地，只有遇到问题的时候，我们才会考虑开启 Native Memory Tracking，并且在定位出问题后，我们想把它关闭，可以通过 <code>jcmd &lt;pid&gt; VM.native_memory shutdown</code> 进行关闭并清理掉之前 Native Memory tracking 使用的埋点以及占用的内存。如前面所述，我们无法动态开启 Native Memory tracking，所以只要动态关闭了，这个进程就无法再开启了。</p><p>jcmd 本身提供了简单的对比功能，例如：</p><ol><li>使用 <code>jcmd &lt;pid&gt; VM.native_memory baseline</code> 记录当前内存占用信息</li><li>之后过一段时间 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 会输出当前 Native Memory Tracking 的 summary 信息，如果与第一步 baseline 的有差异，会在对应位将差异输出</li></ol><p>但是这个工具本身比较粗糙，我们有时候并不知道何时调用 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 合适，因为我们不确定什么时候会有我们想看到的内存使用过大的问题。所以我们一般做成一种持续监控的方式</p><h3 id="summary-信息每部分含义"><a href="#summary-信息每部分含义" class="headerlink" title="summary 信息每部分含义"></a>summary 信息每部分含义</h3><p>以下是一个 Native Memory Tracking 的示例输出：</p><ol><li>压测 <a href="https://github.com/spring-projects/spring-petclinic.git">spring-petclinic</a> 项目</li><li>jdk21</li><li>vm options</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">(Omitting categories weighting less than 1KB)</span><br><span class="line"></span><br><span class="line">Total: reserved=1751414KB, committed=470662KB</span><br><span class="line">       malloc: 104634KB #545587</span><br><span class="line">       mmap:   reserved=1646780KB, committed=366028KB</span><br><span class="line"></span><br><span class="line">-                 Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">                            (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">                            (classes #21948)</span><br><span class="line">                            (  instance classes #20377, array classes #1571)</span><br><span class="line">                            (malloc=1935KB #58688) (peak=1999KB #58351) </span><br><span class="line">                            (mmap: reserved=1048576KB, committed=15232KB, at peak) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=131072KB, committed=91072KB)</span><br><span class="line">                            (    used=90300KB)</span><br><span class="line">                            (    waste=772KB =0.85%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=14704KB)</span><br><span class="line">                            (    waste=528KB =3.46%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">                            (threads #58)</span><br><span class="line">                            (stack: reserved=117420KB, committed=117420KB, peak=117420KB)</span><br><span class="line">                            (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">                            (arena=67KB #114) (peak=3010KB #121)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">                            (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">                            (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=33KB #1)</span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">                            (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">                            (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br><span class="line"> </span><br><span class="line">-                 GCCardSet (reserved=70KB, committed=70KB)</span><br><span class="line">                            (malloc=70KB #778) (peak=483KB #1344) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=230KB, committed=230KB)</span><br><span class="line">                            (malloc=100KB #711) (peak=142KB #1118) </span><br><span class="line">                            (arena=130KB #2) (peak=10244KB #9)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">                            (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=108KB, committed=108KB)</span><br><span class="line">                            (malloc=108KB #18) (peak=130KB #20) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">                            (malloc=33100KB #285200) (peak=33111KB #284967) </span><br><span class="line">                            (arena=6017KB #1) (at peak)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                            (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                            (tracking overhead=8525KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">                            (malloc=199KB #306) (peak=16383KB #630) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">                            (malloc=21522KB #12431) (at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=32KB #1)</span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=0KB, committed=0KB)</span><br><span class="line">                            (malloc=0KB #2) (peak=6KB #4) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=276KB, committed=276KB)</span><br><span class="line">                            (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-           Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                            (malloc=3462KB #66139) (peak=3479KB #66484) </span><br><span class="line"> </span><br><span class="line">-            Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                            (malloc=2837KB #33552) (peak=2850KB #33877) </span><br><span class="line"> </span><br><span class="line">-                 Metaspace (reserved=131503KB, committed=91503KB)</span><br><span class="line">                            (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">                            (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br><span class="line"> </span><br><span class="line">-      String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #8) (at peak) </span><br><span class="line"> </span><br><span class="line">-           Object Monitors (reserved=24KB, committed=24KB)</span><br><span class="line">                            (malloc=24KB #116) (peak=162KB #798) </span><br><span class="line"> </span><br><span class="line">-                   Unknown (reserved=0KB, committed=0KB)</span><br><span class="line">                            (mmap: reserved=0KB, committed=0KB, peak=32KB) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Java堆内存-Java-Heap"><a href="#Java堆内存-Java-Heap" class="headerlink" title="Java堆内存(Java Heap)"></a>Java堆内存(Java Heap)</h4><blockquote><p>所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 堆内存占用，reserve 了 262144KB=256M，当前 commit 了 82944KB(81M) 用于实际使用</span><br><span class="line">// 发现 申请的内存大小正好等于=-Xmx256m，预留内存空间（不实际分配物理内存），只是为了让操作系统选择地址，预留大小。commit才是实际使用的物理内存</span><br><span class="line">Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">    // 堆内存都是通过 mmap 系统调用方式分配的，peak=最大使用量</span><br><span class="line">    (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br></pre></td></tr></table></figure><h4 id="元空间-Class"><a href="#元空间-Class" class="headerlink" title="元空间(Class)"></a>元空间(Class)</h4><blockquote><p>JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。对应的 Java 反射类 Class 还是在堆内存空间中</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Class 是类元空间总占用，reserve 了 1050511KB(1025M)，当前 commit 了 17167KB(16MB) 用于实际使用</span><br><span class="line">// 总共 reserved 1050511KB = mmap reserved 1048576KB(1024) + malloc 1935KB(1.8)</span><br><span class="line">// 总共 committed 17167KB = mmap committed 15232KB + malloc 1999KB</span><br><span class="line"> Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">        (classes #21948) //一共加载了 21948 个类</span><br><span class="line">        (  instance classes #20377, array classes #1571)    //其中 20377 个实体类，1571 个数组类</span><br><span class="line">        (malloc=1935KB #58688) (peak=1999KB #58351)  //通过 malloc 系统调用方式一共分配了 1935KB，一共调用了 58688 次 malloc</span><br><span class="line">        (mmap: reserved=1048576KB, committed=15232KB, at peak)  //通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 15232KB 用于实际使用</span><br><span class="line">        (  Metadata:   ) //注意，MetaData 这块不属于类元空间，属于数据元空间</span><br><span class="line">        (    reserved=131072KB, committed=91072KB) //数据元空间当前 reserve 了 131072KB，commit 了 91072KB 用于实际使用</span><br><span class="line">        (    used=90300KB) //但是实际从 MetaChunk 的角度去看使用，只有 90300KB 用于实际数据的分配，有 772KB 的浪费</span><br><span class="line">        (    waste=772KB =0.85%)</span><br><span class="line">        (  Class space:)</span><br><span class="line">        (    reserved=1048576KB, committed=15232KB) //类元空间当前 reserve 了 1048576KB，commit 了 15232KB 用于实际使用 </span><br><span class="line">        (    used=14704KB)  //但是实际从 MetaChunk 的角度去看使用，只有 14704KB 用于实际数据的分配，有 528KB 的浪费</span><br><span class="line">        (    waste=528KB =3.46%)</span><br><span class="line">Module (reserved=276KB, committed=276KB) //加载并记录模块占用空间，当前 reserve 了 276KB，commit 了 276KB 用于实际使用</span><br><span class="line">        (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line">Metaspace (reserved=131503KB, committed=91503KB) //等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 131503KB，commit 了 91503KB 用于实际使用</span><br><span class="line">        (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">        (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="C-字符串即符号-Symbol-占用空间"><a href="#C-字符串即符号-Symbol-占用空间" class="headerlink" title="C++ 字符串即符号(Symbol)占用空间"></a>C++ 字符串即符号(Symbol)占用空间</h4><blockquote><p>前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复。所以统一放入符号表(Symbol table)复用。元空间中保存的是针对符号表中符号的引用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">        (malloc=33100KB #285200) (peak=33111KB #284967)  //通过 malloc 系统调用方式一共分配了 33100KB，一共调用了 285200 次 malloc</span><br><span class="line">        (arena=6017KB #1) (at peak) //通过 arena 系统调用方式一共分配了 6017KB，一共调用了 1 次 arena</span><br></pre></td></tr></table></figure><h4 id="线程占用内存-Thread"><a href="#线程占用内存-Thread" class="headerlink" title="线程占用内存(Thread)"></a>线程占用内存(Thread)</h4><blockquote><p>主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 总共 reserve 了 117590KB(114M)，commit 了 117590KB(114M)</span><br><span class="line">Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">    (threads #58) //当前线程数量是 58</span><br><span class="line">    (stack: reserved=117420KB, committed=117420KB, peak=117420KB) //线程栈占用的空间: 每个线程实际占用 ≈ 1MB(栈) + 2MB(Guard Pages) 58个线程总占用 ≈ 58 * (1MB + 2MB) ≈ 174MB，实际看到117MB比理论值小，因为Guard Pages可能共享</span><br><span class="line">    (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">    (arena=67KB #114) (peak=3010KB #121)</span><br></pre></td></tr></table></figure><h4 id="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code"><a href="#JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code" class="headerlink" title="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)"></a>JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">    (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">    (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">    (arena=0KB #0) (peak=33KB #1)</span><br></pre></td></tr></table></figure><h4 id="Arena-数据结构占用空间-Arena-Chunk"><a href="#Arena-数据结构占用空间-Arena-Chunk" class="headerlink" title="Arena 数据结构占用空间(Arena Chunk)"></a>Arena 数据结构占用空间(Arena Chunk)</h4><blockquote><p> Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">            (malloc=199KB #306) (peak=16383KB #630) </span><br></pre></td></tr></table></figure><h4 id="JVM-Tracing-占用内存"><a href="#JVM-Tracing-占用内存" class="headerlink" title="JVM Tracing 占用内存"></a>JVM Tracing 占用内存</h4><blockquote><p>包括 JVM perf 以及 JFR 占用的空间。其中 JFR 占用的空间可能会比较大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">    (malloc=21522KB #12431) (at peak) </span><br><span class="line">    (arena=0KB #0) (peak=32KB #1)</span><br></pre></td></tr></table></figure><h4 id="写-JVM-日志占用的内存-Logging"><a href="#写-JVM-日志占用的内存-Logging" class="headerlink" title="写 JVM 日志占用的内存(Logging)"></a>写 JVM 日志占用的内存(Logging)</h4><blockquote><p>-Xlog 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志-Xlog:async，异步日志所需的 buffer 也在这里</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logging (reserved=0KB, committed=0KB)</span><br><span class="line">        (malloc=0KB #2) (peak=6KB #4) </span><br></pre></td></tr></table></figure><h4 id="JVM-参数占用内存-Arguments"><a href="#JVM-参数占用内存-Arguments" class="headerlink" title="JVM 参数占用内存(Arguments)"></a>JVM 参数占用内存(Arguments)</h4><blockquote><p>我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">(malloc=31KB #90) </span><br></pre></td></tr></table></figure><h4 id="JVM-安全点占用内存-Safepoint"><a href="#JVM-安全点占用内存-Safepoint" class="headerlink" title="JVM 安全点占用内存(Safepoint)"></a>JVM 安全点占用内存(Safepoint)</h4><blockquote><p>是固定的两页内存（我这里是一页是 16KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">           (mmap: reserved=32KB, committed=32KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="Java-同步机制-Synchronization"><a href="#Java-同步机制-Synchronization" class="headerlink" title="Java 同步机制(Synchronization)"></a>Java 同步机制(Synchronization)</h4><blockquote><p>例如 synchronized，还有 AQS 的基础 LockSupport 底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                (malloc=3462KB #66139) (peak=3479KB #66484) </span><br></pre></td></tr></table></figure><h4 id="JVM-TI-相关内存-Serviceability"><a href="#JVM-TI-相关内存-Serviceability" class="headerlink" title="JVM TI 相关内存(Serviceability)"></a>JVM TI 相关内存(Serviceability)</h4><blockquote><p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏检测工具等等。这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                (malloc=2837KB #33552) (peak=2850KB #33877) </span><br></pre></td></tr></table></figure><h4 id="Java-字符串去重占用内存-String-Deduplication"><a href="#Java-字符串去重占用内存-String-Deduplication" class="headerlink" title="Java 字符串去重占用内存(String Deduplication)"></a>Java 字符串去重占用内存(String Deduplication)</h4><blockquote><p>Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 <code>G1GC</code> 以及 <code>ZGC</code> 中，所以默认是关闭的，可以通过 <code>-XX:+UseStringDeduplication</code> 来启用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                    (malloc=1KB #8) (at peak) </span><br></pre></td></tr></table></figure><h4 id="JVM-GC需要的数据结构与记录信息占用的空间-GC"><a href="#JVM-GC需要的数据结构与记录信息占用的空间-GC" class="headerlink" title="JVM GC需要的数据结构与记录信息占用的空间(GC)"></a>JVM GC需要的数据结构与记录信息占用的空间(GC)</h4><blockquote><p>这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 <code>ZGC</code>。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">    (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">    (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br></pre></td></tr></table></figure><h4 id="JVM内部与其他占用"><a href="#JVM内部与其他占用" class="headerlink" title="JVM内部与其他占用"></a>JVM内部与其他占用</h4><blockquote><p>JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">        (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">        (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"></span><br><span class="line"> Other (reserved=108KB, committed=108KB)</span><br><span class="line">        (malloc=108KB #18) (peak=130KB #20) </span><br></pre></td></tr></table></figure><h4 id="开启-Native-Memory-Tracking-本身消耗的内存"><a href="#开启-Native-Memory-Tracking-本身消耗的内存" class="headerlink" title="开启 Native Memory Tracking 本身消耗的内存"></a>开启 Native Memory Tracking 本身消耗的内存</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                    (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                    (tracking overhead=8525KB)</span><br></pre></td></tr></table></figure><h3 id="Native-Memory-Tracking-的-summary-信息的持续监控"><a href="#Native-Memory-Tracking-的-summary-信息的持续监控" class="headerlink" title="Native Memory Tracking 的 summary 信息的持续监控"></a>Native Memory Tracking 的 summary 信息的持续监控</h3><p>现在 JVM 一般大部分部署在 k8s 这种云容器编排的环境中，每个 JVM 进程内存是受限的。如果超过限制，那么会触发 OOMKiller 将这个 JVM 进程杀掉。我们一般都是由于自己的 JVM 进程被 OOMKiller杀掉，才会考虑打开 <code>NativeMemoryTracking</code> 去看看哪块内存占用比较多以及如何调整的。</p><p><code>OOMKiller 是积分制</code>，并不是你的 JVM 进程一超过限制就立刻会被杀掉，而是超过的话会累积分，累积到一定程度，就可能会被 OOMKiller 杀掉。所以，我们可以通过<code>定时输出</code> Native Memory Tracking的 summary 信息，从而抓到超过内存限制的点进行分析</p><p>但是，我们不能仅通过 Native Memory Tracking 的数据就判断 JVM 占用的内存，因为在后面的 JVM 内存申请与使用流程的分析我们会看到，<code>JVM 通过 mmap 分配的大量内存都是先 reserve 再 commit 之后实际往里面写入数据的时候，才会真正分配物理内存</code>。同时，JVM 还会动态释放一些内存，这些内存可能不会立刻被操作系统回收。<code>Native Memory Tracking 是 JVM 认为自己向操作系统申请的内存，与实际操作系统分配的内存是有所差距的</code>，所以我们不能只查看 Native Memory Tracking 去判断，我们还需要查看能体现真正内存占用指标。这里可以查看 linux 进程监控文件 smaps_rollup 看出具体的内存占用，例如 (一般不看 Rss，因为如果涉及多个虚拟地址映射同一个物理地址的话会有不准确，所以主要关注 <code>Pss</code> 即可，但是 Pss 更新不是实时的，但也差不多，这就可以理解为进程占用的实际物理内存)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/1/smaps_rollup </span><br><span class="line">f8000000-ffffe5c27000 ---p 00000000 00:00 0                              [rollup]</span><br><span class="line">Rss:              198904 kB</span><br><span class="line">Pss:              197331 kB</span><br><span class="line">Pss_Dirty:        181900 kB</span><br><span class="line">Pss_Anon:         181880 kB</span><br><span class="line">Pss_File:          15451 kB</span><br><span class="line">Pss_Shmem:             0 kB</span><br><span class="line">Shared_Clean:       1864 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:     15140 kB</span><br><span class="line">Private_Dirty:    181900 kB</span><br><span class="line">Referenced:       198904 kB</span><br><span class="line">Anonymous:        181880 kB</span><br><span class="line">KSM:                   0 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FilePmdMapped:         0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure><p>通过在每个 Spring Cloud 微服务进程加入下面的代码，来实现定时的进程内存监控，主要通过 <code>smaps_rollup</code> 查看实际的物理内存占用找到内存超限的时间点，Native Memory Tracking 查看 JVM 每块内存占用的多少，用于指导优化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.bootstrap.BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorMemoryRSS</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">INITIALIZED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBootstrapContext(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (INITIALIZED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZED.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取 smaps_rollup</span></span><br><span class="line">                    List&lt;String&gt; strings = FileUtils.readLines(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/smaps_rollup&quot;</span>));</span><br><span class="line">                    log.info(<span class="string">&quot;MonitorMemoryRSS, smaps_rollup: &#123;&#125;&quot;</span>, strings.stream().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    <span class="comment">//读取 Native Memory Tracking 信息</span></span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;jcmd&quot;</span>, pid + <span class="string">&quot;&quot;</span>, <span class="string">&quot;VM.native_memory&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()))) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;MonitorMemoryRSS, native_memory: &#123;&#125;&quot;</span>, reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            INITIALIZED.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBootstrapContext</span><span class="params">(ApplicationReadyEvent applicationEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationEvent.getApplicationContext().getEnvironment().getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225871227743043644&quot;&gt;Native Memory Tracking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开启&quot;&gt;&lt;a href=&quot;#开启&quot; class=&quot;headerlink&quot; title=&quot;开启&quot;&gt;&lt;/a&gt;开启&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="NMT" scheme="https://taeyang0126.github.io/tags/NMT/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Sample</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/</id>
    <published>2025-02-22T12:55:52.000Z</published>
    <updated>2025-02-22T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationSample</code></li><li>Label(Event Type，用于显示): Object Allocation Sample</li><li>Category(用于分类显示): Java Application</li><li>事件从<code>Java16</code>引入(目的是想有一个采集消耗不像 <code>ObjectAllocationInNewTLAB</code> 这么大的事件)</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二、路径三、路径四</code></li><li><code>路径二、路径三</code> 分配一定进入采样中，<code>路径四</code> 分配失败不会进入采样中</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>150/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>300/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二、三、四分配然后被采集到的线程的名称</li><li>Object Class：发生路径二、三、四分配然后被采集到的对象大小类型</li><li><code>Sample Weight</code><ul><li>采样到的采样权重</li><li>每个线程都有一个采样数据记录了分配了多少对象，对象的总大小</li><li>这个采样权重就是这个线程当前分配对象总大小减去上次这个线程被采样到的时候的分配对象的总大小</li><li>其实就是近似的任务，这个线程这个期间分配的对象都是 Object Class 类型，大小是采样权重这么大</li><li>单独一个 Object Allocation Sample 事件的 weight 仅代表当前这个线程上次触发 Object Allocation Sample 之后，<br>这个线程分配的对象大小，所以<code>单独看一个事件的这个值没有参考意义</code></li><li><code>它的参考意义主要在于</code>，按照线程和 Object Class 分组，将所有 weight 相加，统计这个线程分配的对象的总大小，这个值可以<br>用于分析这个线程在这段时间的分配压力，以及这个线程的分配对象的类型分布情况</li></ul></li><li>线程栈：发生路径二、三、四分配然后被采集到的线程栈，默认是采集的</li></ul><h3 id="事件采集原理"><a href="#事件采集原理" class="headerlink" title="事件采集原理"></a>事件采集原理</h3><pre><code class="mermaid">%%{init: {&#39;theme&#39;: &#39;default&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#2B6CB0&#39; }}}%%flowchart TD    A1[当前分配的对象触发申请新的 TLAB 分配并且成功分配后-路径二]    A2[当前分配的对象触发 TLAB 外分配并且分配成功后-路径三]    B[生成 Object Allocation Sample 事件]    C[设置事件的 objectClass 为分配对象的 class]    A1 --&gt; B    A2 --&gt; |重复n次，n &#x3D; 分配的对象大小除以 TLAB 大小，用于让大对象更容易生成 Object Allocation Sample-更容易被采集到| B    B --&gt; C    C --&gt; D[设置事件的 weight 为当前线程已经分配的总内存减去上次触发 Object Allocation Sample 事件当前线程已经分配的总内存]    D --&gt; E[记录当前线程已经分配的总内存用于下次计算 weight]</code></pre><h3 id="编写测试代码-使用虚拟线程"><a href="#编写测试代码-使用虚拟线程" class="headerlink" title="编写测试代码(使用虚拟线程)"></a>编写测试代码(使用虚拟线程)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 和 ObjectAllocationOutsideTLAB 事件，用于对比</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;150/s&quot;</span>);</span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object Allocation Sample 定位可能的内存泄漏，并不是太合适，容易被热点对象吞没<br><img data-src="/images/jfr/15.png" alt="img"></li><li>Object Allocation Sample <code>非常适合定位热点分配对象中有没有哪些意料之外的频繁对象分配</code>，从而优化性能<ul><li>以 Object Allocation Sample 创建新的标签页<br><img data-src="/images/jfr/16.png" alt="img"></li><li>在标签页，首页按照线程分组<br><img data-src="/images/jfr/17.png" alt="img"></li><li>在上个分组基础上按照对象类型分组<br><img data-src="/images/jfr/18.png" alt="img"></li></ul></li><li>从JFR可以看出，<code>.values</code>遍历数组每次都会新创建一个数组对象，造成非常频繁的对象分配，影响性能(jdk21)<br><img data-src="/images/jfr/19.png" alt="img"></li><li>jdk23下，发现Object分配比Enum还多，这是个奇特的点！<br><img data-src="/images/jfr/20.png" alt="img"></li><li>将 Object Allocation Sample 的 throttle 改为 1&#x2F;s，效果如下(jdk21)<br><img data-src="/images/jfr/21.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>建议维持打开 Object Allocation Sample</li><li>但是 throttle 设置为 1&#x2F;s ~ 5&#x2F;s 即可，基本可以定位到分配热点以及意想不到的分配，进行代码优化</li><li>这个事件适合定位什么问题？<ul><li>大对象分配：适合度50%。这个只会采集分配成功的对象，对于大对象分配，如果触发 OutOfMemoryError 代表分配失败，那采集不到。</li><li>意想不到大量对象分配：适合度 90% 。通过 weight 统计，可以找到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。<br>在做定期性能优化的时候，可以经常看看。</li><li>Java 堆对象内存泄漏：适合度 10% 。仅仅可以定位热点分配的对象类型和堆栈，但是内存泄漏如果不是热点对象导致的，就不太好定位了。</li><li>GC 过于频繁：适合度 100% 。可以定位到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationSample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Sample&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java16&lt;/code&gt;引入(目的是想有一个采集消耗不像 &lt;code&gt;ObjectAllocationInNewTLAB&lt;/code&gt; 这么大的事件)&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径二、路径三、路径四&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;路径二、路径三&lt;/code&gt; 分配一定进入采样中，&lt;code&gt;路径四&lt;/code&gt; 分配失败不会进入采样中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>画图工具</title>
    <link href="https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/</id>
    <published>2025-02-22T11:55:52.000Z</published>
    <updated>2025-02-22T11:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mermaid-live.nodejs.cn/">mermaid在线画图</a></li><li><a href="https://www.min2k.com/tools/mermaid/">中文mermaid在线画图</a></li><li><a href="https://mermaid.nodejs.cn/intro/">mermaid中文网</a></li><li><a href="https://excalidraw.com/">手绘风格画图</a></li><li><a href="https://fskpf.github.io/">svg图片转手绘风格</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mermaid-live.nodejs.cn/&quot;&gt;mermaid在线画图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.min2k.com/tools/mermaid/&quot;&gt;中文mermaid在线画图&lt;/a&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="画图" scheme="https://taeyang0126.github.io/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-你可能没必要 Heap Dump</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/</id>
    <published>2025-02-22T07:25:52.000Z</published>
    <updated>2025-02-22T07:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><blockquote><p>很多情况会导致 Java 应用抛出 <code>OutOfMemoryError</code> <a href="https://zhuanlan.zhihu.com/p/265039643">参考 StackOverflowError 与 OutOfMemoryError</a></p></blockquote><h4 id="会触发HeapDumpOnOutOfMemoryError"><a href="#会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="会触发HeapDumpOnOutOfMemoryError"></a>会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><code>OutOfMemoryError: Java heap space</code> 和 <code>OutOfMemoryError: GC overhead limit exceeded</code> ：这两个都是 Java 对象堆内存不够了，一个是分配的时候发现剩余空间不足，一个是到达某一界限</li><li><code>OutOfMemoryError: Requested array size exceeds VM limit</code> ：当申请的数组大小超过堆内存限制，就会抛出这个异常</li><li><code>OutOfMemoryError: Compressed class space</code> 和 <code>OutOfMemoryError: Metaspace</code> ：这两个都和元空间相关（<a href="https://juejin.cn/post/7225879724545835045">底层原理</a>）</li><li><code>Shenandoah</code> 分配区域位图，内存的时候，触发的 OutOfMemoryError</li></ul><h4 id="不会触发HeapDumpOnOutOfMemoryError"><a href="#不会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="不会触发HeapDumpOnOutOfMemoryError"></a>不会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><strong>OutOfMemoryError: unable to create native thread</strong> ：无法创建新的平台线程</li><li><strong>OutOfMemoryError: Cannot reserve xxx bytes of direct buffer memory (allocated: xxx, limit: xxx)</strong> ：在 DirectByteBuffer 中，首先向 Bits 类申请额度， Bits 类有一个全局的 totalCapacity 变量，记录着全部DirectByteBuffer 的总大小，每次申请，都先看看是否超限，可用 <code>-XX:MaxDirectMemorySize</code> 限制（未指定默认与-Xmx相同）</li><li><strong>OutOfMemoryError: map failed</strong> ：这个是 File MMAP （文件映射内存）时，如果系统内存不足，就会抛出这个异常</li><li>OutOfMemoryError: Native heap allocation failed ，这个 Message 可能不同操作系统不一样，但是一般都有 native heap 。这个就和 Java 对象堆一般没关系，而是其他块内存无法申请导致的</li></ul><h3 id="为什么不建议打开HeapDumpOnOutOfMemoryError"><a href="#为什么不建议打开HeapDumpOnOutOfMemoryError" class="headerlink" title="为什么不建议打开HeapDumpOnOutOfMemoryError"></a>为什么不建议打开<code>HeapDumpOnOutOfMemoryError</code></h3><h4 id="HeapDumpOnOutOfMemoryError-的原理"><a href="#HeapDumpOnOutOfMemoryError-的原理" class="headerlink" title="HeapDumpOnOutOfMemoryError 的原理"></a><code>HeapDumpOnOutOfMemoryError</code> 的原理</h4><ul><li>进入安全点，所有应用线程暂停，针对 HeapDumpOnOutOfMemoryError，单线程（如果是 jcmd jmap 可以多线程）dump 堆为线程个数个文件。退出安全点。</li><li>将上面的多个文件，合并为一个，压缩。</li></ul><h4 id="HeapDumpOnOutOfMemoryError-的瓶颈"><a href="#HeapDumpOnOutOfMemoryError-的瓶颈" class="headerlink" title="HeapDumpOnOutOfMemoryError 的瓶颈"></a><code>HeapDumpOnOutOfMemoryError</code> 的瓶颈</h4><blockquote><p>这里的瓶颈主要在于第一步写入，并且，主要瓶颈在磁盘 IO</p></blockquote><ul><li><a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html">AWS EFS （普通存储）</a></li><li><a href="https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html">AWS EBS （对标 SSD ）</a></li><li>对于一个 4G 大小的 Java 对象堆内存，如果是 EFS ，对标的应该是 100G 以内的磁盘，写入最少<br>也需要大概 4 * 1024 &#x2F; 300 &#x3D; 13.65 秒（注意，这个是峰值性能），如果当时峰值性能被用完了，那<br>么需要： 4 * 1024 &#x2F; 15 &#x3D; 273 秒。如果用 EBS ，那么也需要 4 * 1024 &#x2F; 1000 &#x3D; 4 秒。注意，这个<br>计算的时间，是应用线程个完全处于安全点（即 Stop-the-world ）的时间，还没有考虑一个<br>机器上部署多个容器实例的情况，考虑成本我们也不能堆每个微服务都使用 AWS EBS 这种（对标<br>SSD ）。所以，建议还是不要打开 <code>HeapDumpOnOutOfMemoryError</code></li></ul><h3 id="为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？"><a href="#为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？" class="headerlink" title="为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？"></a>为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？</h3><h4 id="jfr配置"><a href="#jfr配置" class="headerlink" title="jfr配置"></a>jfr配置</h4><ul><li>jfc配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>5/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ObjectAllocationOutsideTLAB：TLAB外的分配</li><li>ObjectAllocationSample：TLAB外的以及申请新的TLAB的采样</li><li>AllocationRequiringGC：某个对象分配失败导致gc采集，针对serial、parallel、G1 gc</li><li>ZAllocationStall：ZGC中使用，当一个线程分配对象发现内存不够了，就会阻塞，从而生成此事件。”threshold”&gt;0 阻塞0ms以上都采集<br>ZGC Allocation Stall事件为啥看不到触发内存溢出的业务代码呢？jdk23才可以</li><li>JVM参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stackdepth=256 是为了演示效果，一般不需要这么大</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxchunksize=128m 是为了演示效果，一般不需要这么大</span></span><br><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br></pre></td></tr></table></figure></li></ul><h4 id="大对象分配导致的问题"><a href="#大对象分配导致的问题" class="headerlink" title="大对象分配导致的问题"></a>大对象分配导致的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote><p>某个请求有 bug，导致全表扫描，冲爆了 Java 对象堆内存。抛出了 OutOfMemoryError ，但是这是异常情况，可能无法输出堆栈日志，在茫茫众多的请求中很难找到这个请求</p></blockquote><ul><li>模拟了一个方法，从db返回结果非常大，直接导致OOM，输出的jfr如下</li><li><img data-src="/images/jfr/08.png" alt="img"></li><li><img data-src="/images/jfr/09.png" alt="img"></li><li>ZGC查看如下图<br><img data-src="/images/jfr/10.png" alt="img"></li></ul><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote><p>用户累计订单量随着你的系统成熟越来越多，大历史订单量的用户越来越多。之前的代码有 bug ，用户订单列表实际是拉取每个用户的所有订单 内存分页。可能两个大历史订单量的用户同时查询的时候就会抛出 OutOfMemoryError ，就算不抛出也会频繁 GC 影响性能。</p></blockquote><ul><li>模拟了一个方法，多个大订单量的用户并发查询，可能没有导致OOM，但是会频繁的GC，输出的jfr如下</li><li><img data-src="/images/jfr/11.png" alt="img"></li><li><img data-src="/images/jfr/12.png" alt="img"></li></ul><h4 id="小对象分配导致的问题"><a href="#小对象分配导致的问题" class="headerlink" title="小对象分配导致的问题"></a>小对象分配导致的问题</h4><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote><p>某个请求会触发分配一个小对象放入类似于缓存的地方，但是这个小对象一直没有被回收，日积月累导致 FullGC 越来越频繁，最后<br>OutOfMemoryError</p></blockquote><ul><li>这种情况，可能导致 JFR 事件丢失，但是大概率不影响我们定位问题，因为是一连串的趋势可以看出来</li><li><img data-src="/images/jfr/13.png" alt="img"></li><li><img data-src="/images/jfr/14.png" alt="img"></li></ul><h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote><p>由于虚拟线程的引入，原来进程内处理请求的数量一定程度受限于 IO 以及线程数量，现在则是受限于 Java 对象堆内存大小，如何识别这种<code>背压</code>问题。</p></blockquote><h3 id="为什么抛出-OutOfMemoryError-的微服务最好下线重启？"><a href="#为什么抛出-OutOfMemoryError-的微服务最好下线重启？" class="headerlink" title="为什么抛出 OutOfMemoryError 的微服务最好下线重启？"></a>为什么抛出 OutOfMemoryError 的微服务最好下线重启？</h3><ul><li>因为包括 JDK 的源码在内，都没有在每一个分配内存的代码的地方考虑会出现 OutOfMemoryError ，这样会导致代码<br>状态不一致，例如 hashmap 的 rehash ，如果里面某行抛出 OutOfMemoryError ，前面更新的状态就不对了。</li><li>还有其他很多库，就不用说了，都很少有 catch Throwable 的，大部分是 catch Exception 的。并且，在每一个分配内<br>存的代码的地方考虑会出现 OutOfMemoryError 也是不现实的，所以为了防止 OutOfMemoryError 带来意想不到的<br>一致性问题，还是下线重启比较好。</li></ul><h3 id="如何实现抛出-OutOfMemoryError-的微服务下线重启？"><a href="#如何实现抛出-OutOfMemoryError-的微服务下线重启？" class="headerlink" title="如何实现抛出 OutOfMemoryError 的微服务下线重启？"></a>如何实现抛出 OutOfMemoryError 的微服务下线重启？</h3><ul><li>一般通过 -XX:OnOutOfMemoryError&#x3D;”&#x2F;path&#x2F;to&#x2F;script.sh” 指定脚本，脚本执行<ul><li>微服务的下线</li><li>微服务的重启(可以依赖k8s)</li></ul></li><li>针对 spring boot ，可以考虑开启允许本地访问 &#x2F;actuator&#x2F;shutdown 来关闭微服务（有群友反应抛出<br>OutOfMemoryError 的时候调用这个会卡死，这是因为前面说的原因，你可能开启了<br>HeapDumpOnOutOfMemoryError 导致的）， k8s 会自动拉起一个新的。<ul><li>因为<code>HeapDump</code>需要进入安全点，所有线程都 STW 了，导致k8s健康检查失败，从而k8s会自动拉起一个新的，导致dump失败</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;OutOfMemoryError&quot;&gt;&lt;a href=&quot;#OutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;OutOfMemoryError&quot;&gt;&lt;/a&gt;OutOfMemoryError&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多情况会导致 Java 应用抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/265039643&quot;&gt;参考 StackOverflowError 与 OutOfMemoryError&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="OOM" scheme="https://taeyang0126.github.io/tags/OOM/"/>
    
    <category term="Heap Dump" scheme="https://taeyang0126.github.io/tags/Heap-Dump/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Outside TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/</id>
    <published>2025-02-22T06:25:52.000Z</published>
    <updated>2025-02-22T06:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationOutsideTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation Outside TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径三</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径三分配的线程的名称</li><li>Allocation Size：触发路径三分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径三分配的对象类型</li><li>线程栈：发生路径三的线程栈，默认是采集的<br><img data-src="/images/jfr/07.png" alt="img"></li></ul><h3 id="编写代码模拟内存泄漏业务"><a href="#编写代码模拟内存泄漏业务" class="headerlink" title="编写代码模拟内存泄漏业务"></a>编写代码模拟内存泄漏业务</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocOutsideTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，三个线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">bizRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">              <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                  objects.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;biz-&quot;</span> + i)</span><br><span class="line">                      .unstarted(bizRunnable);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(bizRunnable);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                  threads[i].interrupt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">oomRun</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">              map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;oom-&quot;</span> + i)</span><br><span class="line">                      .unstarted(oomRun);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(oomRun);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否建议开启这个事件的采集"><a href="#是否建议开启这个事件的采集" class="headerlink" title="是否建议开启这个事件的采集"></a>是否建议开启这个事件的采集</h3><ul><li>建议开启<ul><li>上面提到的Java内存分配路径，对于一般的JVM应用，<code>TLAB</code>内分配的量远大于申请新的TLAB分配的量，同时申请新的TLAB的量又远大于在TLAB外分配的量。除非你的应用分配大量的大对象，否则这个事件发生的应该比较少</li><li>对于一般的JVM应用，建议还是开启这个事件的采集，这样能采集到在你应用的所有大对象分配。只要你的应用不是大对象分配过多，这个事件的采集对于性能的影响应该是可以接受的。</li><li>路径三分配一般会包含核心问题点：<ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li></ul></li><li>与其他哪些事件是否有重合<ul><li><code>Object Allocation Sample</code>: 虽然 Object Allocation Sample 官方默认开启，但是对于大部分小对象朝生夕死的应用，其实更应该开启 Object Allocation Outside TLAB，而不是Object Allocation Sample。大部分应用，采集到的 Object Allocation Outside TLAB 会比默认的 Object Allocation Sample 少很多很多，性能消耗小很多很多。建议将 Object Allocation Sample 的采样率调很低，主要用于看意向不到的对象分配。</li><li><code>Allocation Requiring GC 以及 ZAllocation Stall</code>: 后续分析这些事件我们会看到，有内存泄漏嫌疑的对象分配相关的对象分配路径，基本上很少会被这两个事件以及 Object Allocation Outside TLAB 采集到</li></ul></li></ul><h3 id="这个事件适合定位什么问题？"><a href="#这个事件适合定位什么问题？" class="headerlink" title="这个事件适合定位什么问题？"></a>这个事件适合定位什么问题？</h3><ul><li>大对象分配：适合度70%<ul><li>对于大于TLAB大小的对象，如果分配成功一定可以采集到</li><li>对于大于TLAB最大浪费比例的对象，分配成功有概率可以采集到，因为有一部分在TLAB内分配成功</li><li>这个<code>只会采集分配成功</code>的对象，对于大对象分配，如果触发 <code>OutOfMemoryError</code> 代表分配失败，那采集不到</li><li>比如前面的代码示例，可以看到 HashMap 不断扩容，但是如果扩容触发 OutOfMemoryError，那这次就采集不到，但是通过前面的事件也能推测出来</li></ul></li><li>Java 堆对象内存泄漏: 适合度50%。针对不断分配小对象并且不释放的场景比较合适。比如多线程不断向一个 ConcurrentHashMap 塞入对象，但是不释放，这个事件可以采集 ConcurrentHashMap 在不断扩容。</li><li><code>意想不到的大对象分配</code>: 适合度100%。可以定期回顾下这个事件的采集，看看有没有意想不到的大对象分配，以及是否可以优化，或者有利于加深对于JDK的理解</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationOutsideTLAB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Outside TLAB&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从哪个版本引入？&lt;ul&gt;
&lt;li&gt;Java11：即一开始就存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径三&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation In New TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/</id>
    <published>2025-02-22T06:20:52.000Z</published>
    <updated>2025-02-22T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><p><img data-src="/images/jfr/04.png" alt="img"><br><img data-src="/images/jfr/05.png" alt="img"></p><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationInNewTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation In New TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二分配的线程的名称</li><li>Allocation Size：触发路径二分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径二分配的对象类型</li><li>TLAB Size：触发路径二分配，申请新的TLAB的大小</li><li>线程栈：发生路径二的线程栈，默认是采集的<br><img data-src="/images/jfr/06.png" alt="img"></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocInNewTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于字节数组对象头占用16字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_ARRAY_OVERHEAD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 测试的对象大小是KB</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OBJECT_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 字节数组对象名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BYTE_ARRAY_CLASS_NAME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>].getClass().getName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[] 会被全部省略，只剩最后一次的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小1KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 强制 fullgc 回收所以 TLAB</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小100KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE * <span class="number">100</span> - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">      <span class="comment">// 统计事件类型</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf1KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf100KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 读取文件中的所有 JFR 事件</span></span><br><span class="line">      <span class="keyword">for</span> (RecordedEvent event : RecordingFile.readAllEvents(path)) &#123;</span><br><span class="line">          <span class="comment">// 获取分配的对象类型</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> event.getString(<span class="string">&quot;objectClass.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确保分配类型是byte</span></span><br><span class="line">          <span class="keyword">if</span> (BYTE_ARRAY_CLASS_NAME.equals(className)) &#123;</span><br><span class="line">              <span class="type">RecordedFrame</span> <span class="variable">recordedFrame</span> <span class="operator">=</span> event.getStackTrace().getFrames().get(<span class="number">0</span>);</span><br><span class="line">              <span class="comment">// 同时必须是main方法分配的对象，并且是java堆栈中的main方法</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                      recordedFrame.isJavaFrame()</span><br><span class="line">                              &amp;&amp; <span class="string">&quot;main&quot;</span>.equalsIgnoreCase(recordedFrame.getMethod().getName())</span><br><span class="line">              ) &#123;</span><br><span class="line">                  <span class="comment">// 获取分配对象大小</span></span><br><span class="line">                  <span class="type">long</span> <span class="variable">allocationSize</span> <span class="operator">=</span> event.getLong(<span class="string">&quot;allocationSize&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (EVENT_TYPE.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (allocationSize == OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf1KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allocationSize == <span class="number">100</span> * OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf100KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unexpected size of TLAB event&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(event);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;countOf1KBObjectAllocationInNewTLAB: &quot;</span> + countOf1KBObjectAllocationInNewTLAB);</span><br><span class="line">      System.out.println(<span class="string">&quot;countOf100KBObjectAllocationInNewTLAB: &quot;</span> + countOf100KBObjectAllocationInNewTLAB);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么针对大部分应用不建议开启这个事件的采集"><a href="#为什么针对大部分应用不建议开启这个事件的采集" class="headerlink" title="为什么针对大部分应用不建议开启这个事件的采集?"></a>为什么针对大部分应用不建议开启这个事件的采集?</h3><ul><li><code>路径二分配一般不是核心问题点</code><ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li><li><code>对于大部分应用，没有啥必要性</code><ul><li>重新申请 TLAB 分配，对于热点线程来说，虽然不如TLAB内分配那么多，但是也是比较频繁的</li><li>如果重新申请 TLAB 分配的次数，和 TLAB 内分配的次数差不多，这才会是问题</li><li>但是 TLAB 的大小是根据线程的分配情况动态调整的，所以 TLAB 内的分配的次数会比较多，而重新申请 TLAB 分配的次数会比较少</li><li>所以这个事件的采集，对于大部分的应用来说，并不是很有必要</li></ul></li><li><code>性能损耗</code><ul><li>这个事件的采集，会捕获堆栈信息，堆栈信息是比较耗性能的，如果开启这个事件的采集，会导致性能损耗比较大。并且这个事件的采集也相对频繁</li></ul></li></ul><h3 id="哪种情况下才会考虑开启这个事件的采集"><a href="#哪种情况下才会考虑开启这个事件的采集" class="headerlink" title="哪种情况下才会考虑开启这个事件的采集?"></a>哪种情况下才会考虑开启这个事件的采集?</h3><ul><li>正常的应用场景下，不需要调整TLAB的配置参数。一般情况下，JVM会根据应用的情况自动调整TLAB的大小</li><li>如果确实怀疑TLAB的配置参数有问题，第一步是开启 Java Application -&gt; Allocation In New TLAB(jdk.ObjectAllocationInNewTLAB) 和 Java Application -&gt;  Allocation outside TLAB(jdk.ObjectAllocationOutsideTLAB)</li><li>确认有大量的 Object Allocation Outside TLAB 事件发生（一般在应用稳定之后，如果很多线程的 Object Allocation Outside TLAB 相对于 Allocation In New TLAB 大于 5%以上就需要调整 TLAB 相关参数了），然后再考虑是否需要调整 TLAB 的配置参数。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/jfr/04.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;/images/jfr/05.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>Java对象分配过程</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/</id>
    <published>2025-02-22T06:13:52.000Z</published>
    <updated>2024-02-24T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路径一-TLAB-内分配"><a href="#路径一-TLAB-内分配" class="headerlink" title="路径一 TLAB 内分配"></a>路径一 TLAB 内分配</h3><ul><li>需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配</li><li>这是大多数对象的分配路径</li></ul><h3 id="路径二-申请新的-TLAB-分配"><a href="#路径二-申请新的-TLAB-分配" class="headerlink" title="路径二 申请新的 TLAB 分配"></a>路径二 申请新的 TLAB 分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间</li><li>重新分配一个 TLAB，然后在新的 TLAB 中分配</li></ul><h3 id="路径三-TLAB-外分配"><a href="#路径三-TLAB-外分配" class="headerlink" title="路径三 TLAB 外分配"></a>路径三 TLAB 外分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间</li><li>或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小</li><li>或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁</li><li>以上三种情况都会直接在堆上分配</li></ul><h3 id="路径四-分配前触发GC或者等待GC"><a href="#路径四-分配前触发GC或者等待GC" class="headerlink" title="路径四 分配前触发GC或者等待GC"></a>路径四 分配前触发GC或者等待GC</h3><ul><li>路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁</li><li>这种情况下，会 <code>触发GC</code>(serial&#x2F;parallel&#x2F;G1 GC) 或者<code>等待GC释放对象</code>(ZGC)</li><li>路基四如果太多，那其实可能是整体 Java 堆内存就设置的太小了，需要考虑扩容</li><li>如果用的是 SerialGC，ParallelGC，G1GC，那么路径四会产生 <code>Allocation Requiring GC</code></li><li>如果使用的是 ZGC，那么路径四会产生 <code>Z Allocation Stall</code></li><li>如果用的是 ShenandoahGC，路径四会导致 Degenerated GC，这个目前没有对应的 JFR 事件，可以通过 GC 相关的时间看到，但是目前看不到是哪个对象触发</li></ul><h3 id="为什么有个最大浪费空间？？"><a href="#为什么有个最大浪费空间？？" class="headerlink" title="为什么有个最大浪费空间？？"></a>为什么有个最大浪费空间？？</h3><ul><li>这是为了避免更有效的利用空间</li><li>假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择<ul><li>丢弃掉当前这个TLAB，去申请一个新的</li><li>不在当前这个TLAB上配置，去堆上分配</li><li>最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><ul><li>TLAB 是动态的，一般分配频繁的线程TLAB&#x3D;2M</li><li>每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;路径一-TLAB-内分配&quot;&gt;&lt;a href=&quot;#路径一-TLAB-内分配&quot; class=&quot;headerlink&quot; title=&quot;路径一 TLAB 内分配&quot;&gt;&lt;/a&gt;路径一 TLAB 内分配&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配&lt;/li&gt;
&lt;li&gt;这是大多数对象的分配路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;路径二-申请新的-TLAB-分配&quot;&gt;&lt;a href=&quot;#路径二-申请新的-TLAB-分配&quot; class=&quot;headerlink&quot; title=&quot;路径二 申请新的 TLAB 分配&quot;&gt;&lt;/a&gt;路径二 申请新的 TLAB 分配&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-准备工作</title>
    <link href="https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/</id>
    <published>2025-02-20T06:13:52.000Z</published>
    <updated>2025-02-20T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h2 id="为什么需要JFR"><a href="#为什么需要JFR" class="headerlink" title="为什么需要JFR?"></a>为什么需要JFR?</h2><h3 id="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式"><a href="#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式" class="headerlink" title="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式"></a>我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 <code>OpenTelemetry</code> 标准的监控方式</h3><ul><li>arthas: 主要用于实时定位问题，必须有问题线程，必须复现才能定位，没法事后定位，如果有应用问题也可能挂载不上。<br>JFR可以实现从JVM启动开始一直持续采集监控与事后定位，即使应用有问题卡住，也基本能通过JFR定位。</li><li>APM 框架: 例如 micrometer，open-telemetry，Skywalking 等等，大部分基于 <code>Java Agent</code> 和侵入代码的方式结合实现，<br>这些对于JFR来说：<ul><li>这些框架没办法采集JVM层面的指标</li><li>JVM协调安全点，JVM卡住，Java应用有问题，CPU吃满等等，这些框架会受很大影响</li></ul></li></ul><h3 id="结合学习-JVM-JDK-的最佳方式"><a href="#结合学习-JVM-JDK-的最佳方式" class="headerlink" title="结合学习 JVM + JDK 的最佳方式"></a>结合学习 JVM + JDK 的最佳方式</h3><ul><li>JFR 有哪些事件，为啥要采集这些事件</li><li>采集这些事件的机制</li><li>搞懂上面的问题，基本从 JVM 到 JDK 的任意一个细节都搞懂了，比如：<ul><li>JVM GC 的时候有哪些阶段，每个阶段耗时与做了什么？看 GC 相关 JFR 事件</li><li>JVM Safepoint 是啥，有啥原因会进入 safePoint？看 Safepoint 相关 JFR 事件</li><li>JDK 中的 AQS 究竟基于啥，实现原理是啥？看 Thread Park 事件属性与对应线程栈</li></ul></li></ul><h2 id="JFR-如何实现高效"><a href="#JFR-如何实现高效" class="headerlink" title="JFR 如何实现高效"></a>JFR 如何实现高效</h2><ul><li><img data-src="/images/jfr/01.png" alt="img"></li></ul><h2 id="JFR-如何从-JVM-启动一开始监控到任意时候"><a href="#JFR-如何从-JVM-启动一开始监控到任意时候" class="headerlink" title="JFR 如何从 JVM 启动一开始监控到任意时候"></a>JFR 如何从 JVM 启动一开始监控到任意时候</h2><blockquote><p>突破 JFR 本身限制，不用 dumponexit，不用主动 dump</p></blockquote><ul><li>JFR 写入磁盘的 Data Chunk，默认在临时目录(<code>java.io.tmpdir</code>)，这个可以通过<br>JFR 配置限制<ul><li><code>maxage</code>：限制保留的 JFR 事件的最早时间</li><li><code>maxsize</code>：限制保留在本地磁盘临时文件的最大总大小</li></ul></li><li>Java 14开始，增加了 JFR Event Streaming 机制<ul><li>写入的临时文件不再是.part，而是.jfr，这样即使JMC无法解析，也可以使用jfr命令解析</li><li>java 14 引入定时任务定时（默认1s）执行 JFR Flush 将元数据刷入本地文件 Data Chunk，这样大概率最新的文件就是数据完整的，即可以被JMC解析</li></ul></li></ul><h3 id="k8s环境下怎么监控jfr"><a href="#k8s环境下怎么监控jfr" class="headerlink" title="k8s环境下怎么监控jfr"></a>k8s环境下怎么监控jfr</h3><blockquote><p>JFR 与日志是同等定位，其实就是简单结构化的日志。先通过 Grafana 看 Metrics 指标，之后通过少量上报 span 大概定位时间段以及出问题的实例，最后看对应时段的 JFR</p></blockquote><p>升级了 SpringBoot 3.x，升级后，全面改造了原来的 Sleuth 以及 Micrometer 监控，最新的 io.micrometer.observation.Observation 抽象将链路追踪以及指标监控（opentracing 和 opentelemetry 两个标准）结合，这样，我们就可以在链路追踪中，同时记录指标监控数据了。<br>并且，在此基础上，我们还加入了全局的 io.micrometer.observation.ObservationHandler，用于在 Observation start 的时候，生成 JFR 事件，在 stop 的时候 commit JFR 事件。这样我们就实现了通过一个 Observation：</p><ul><li>暴露指标监控数据到 &#x2F;actuator&#x2F;prometheus，供 Prometheus 采集，Grafana 展示</li><li>上报链路追踪数据到 Grafana Tempo</li><li>生成 JFR 事件，供 JDK Mission Control 分析</li></ul><p>为什么要这么做呢？</p><ul><li>指标数据是统计数据，是聚合数据，是一段时间内的数据，而链路追踪数据是实时数据，是每个请求的数据</li><li>但是像是链路追踪上报在生产上肯定不能 100% 上报（上报性能，还有成本考虑，以及查询的存储性能有限，成本不能太高），而是采样上报，这样就会导致链路追数据不全</li><li>JFR 是保留详细数据的好选择，保留在本地，只有发生问题需要排查的时候，事后按需获取就行。</li><li>这样，既节约了成本，又能及时报警，又能容易通过 Tempo 通过链路追踪数据定位出问题的实例和时间段，然后通过获取对应实例的 JFR 事件定位详细问题。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Java-17-以上的-JDK"><a href="#Java-17-以上的-JDK" class="headerlink" title="Java 17 以上的 JDK"></a>Java 17 以上的 JDK</h3><blockquote><p>Azul、Corretto、OpenJdk随意</p></blockquote><h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><blockquote><p>下载最新版本即可，即 JMC 9</p></blockquote><h3 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h3><blockquote><p><code>WhiteBox API</code> 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的API暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解JVM并调优参数</p></blockquote><ul><li>编译 WhiteBox API<ol><li>拉取 openjdk 源码</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 --filter=blob:none --sparse https://github.com/openjdk/jdk</span><br><span class="line">cd jdk</span><br><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout set test/lib/jdk/test/whitebox</span><br></pre></td></tr></table></figure><ol start="2"><li>新建 maven 空项目，将刚刚拉取的代码复制进去，执行 <code>maven package</code> 即可</li><li>将编译的 jar 包放在项目根目录，通过 maven 本地 system 依赖的方式将 jar 包加入依赖<br><img data-src="/images/jfr/02.png" alt="img"></li><li>不想自己构建可以使用 <a href="/files/jfr/whitebox-1.0-SNAPSHOT.jar">whitebox-1.0-SNAPSHOT.jar</a></li><li>编写测试代码<ul><li>代码</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWhiteBox</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            主要用于添加WhiteBox测试API的jar包，这个jar必须通过引导类加载器加载，因为它需要访问JVM内部功能，/a 表示append，将指定的jar追加到引导类路径末尾</span></span><br><span class="line"><span class="comment">            -Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            解锁JVM诊断选项，启用一些默认被禁用的诊断/调试选项，这是使用WhiteBox API的前提条件</span></span><br><span class="line"><span class="comment">            -XX:+UnlockDiagnosticVMOptions</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            启用WhiteBox测试API，WhiteBox API提供了访问JVM内部状态的能力</span></span><br><span class="line"><span class="comment">            -XX:+WhiteBoxAPI</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            开启GC日志记录，输出带有gc标签的日志</span></span><br><span class="line"><span class="comment">            -Xlog:gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 获取 ReservedCodeCacheSize 这个 JVM flag 的值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">reservedCodeCacheSize</span> <span class="operator">=</span> whiteBox.getUintxVMFlag(<span class="string">&quot;ReservedCodeCacheSize&quot;</span>);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        <span class="comment">// 打印内存各项指标</span></span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        <span class="comment">// 执行 full GC</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        <span class="comment">// 保持进程不退出，打印完整日志</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动VM Options</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure><ul><li>执行结果，出现 NoSuchMethodError 错误没关系，因为打包的是最新的 whitebox，使用的jdk版本可能没有某些最新的api<br><img data-src="/images/jfr/03.png" alt="img"></li></ul></li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么需要JFR&quot;&gt;&lt;a href=&quot;#为什么需要JFR&quot; class=&quot;headerlink&quot; title=&quot;为什么需要JFR?&quot;&gt;&lt;/a&gt;为什么需要JFR?&lt;/h2&gt;&lt;h3 id=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot;&gt;&lt;a href=&quot;#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot; class=&quot;headerlink&quot; title=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式&quot;&gt;&lt;/a&gt;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 &lt;code&gt;OpenTelemetry&lt;/code&gt; 标准的监控方式&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 单元测试最佳实践</title>
    <link href="https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/</id>
    <published>2025-02-19T15:55:22.000Z</published>
    <updated>2025-02-19T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>标题党，各位大佬手下留情<del>_</del></p></blockquote><p>单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)</p><blockquote><p>!! 笔者使用的是 2.6.6 版本</p></blockquote><p><img data-src="/images/spring/boot/01.png" alt="image.png"></p><blockquote><p>SpringBoot 常规单元测试</p></blockquote><p>常规的单元测试如下图所示，这样会将整个容器启动起来，需要加载各种各样的外部化配置，耗时时间长且容易失败；大部分场景下我们只是测试某个功能，只需加载部分组件即可</p><p><img data-src="/images/spring/boot/02.png" alt="image.png"></p><blockquote><p>SpringBoot 单元测试指定加载配置</p></blockquote><p>为了解决以上问题，我们可以指定配置进行加载，避免加载整个容器；如下图所示，只会加载基础的Spring容器以及IdGenerator，大大提升了单测的效率</p><p><code>推荐学习</code><a href="https://github.com/chanjarster/spring-test-examples">spring-test-examples</a></p><p><img data-src="/images/spring/boot/03.png" alt="image.png"></p><blockquote><p>SprongBoot 固定组件单元测试</p></blockquote><p>以上指定配置加载已经基本满足了我们的需求(加载部分组件)；但在日常开发中，要求每次单测都指定加载的配置本身就是个伪命题，一是因为本身开发可能对于需要加载的配置不太熟悉，二是因为这种重复的工作过于啰嗦；那么我们该怎么优化这个流程呢？</p><ol><li>要简化配置，第一步就是禁用所有自动加载的配置</li></ol><ul><li>仿造<code>SpringBootTest</code>的注解，构建一个元注解，禁用所有自动加载的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(EmptyTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(EmptyTypeExcludeFilter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestEmptyEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTestContextBootstrapper</span> <span class="keyword">extends</span> <span class="title class_">SpringBootTestContextBootstrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getProperties(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestEmptyEnvironment</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">        <span class="keyword">return</span> (annotation != <span class="literal">null</span>) ? annotation.properties() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTypeExcludeFilter</span> <span class="keyword">extends</span> <span class="title class_">AnnotationCustomizableTypeExcludeFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEmptyEnvironment annotation;</span><br><span class="line"></span><br><span class="line">    EmptyTypeExcludeFilter(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ComponentScan.Filter[] getFilters(<span class="keyword">final</span> FilterType type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> INCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.includeFilters();</span><br><span class="line">            <span class="keyword">case</span> EXCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.excludeFilters();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported type &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation.useDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getDefaultIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getComponentIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>TestEmptyEnvironment</strong>: 禁用所有自动配置，只加载最基础的spring容器</li><li><strong>EmptyTestContextBootstrapper</strong>: 重写properties加载方法，将TestEmptyEnvironment注解中的properties属性加载到容器中</li><li><strong>EmptyTypeExcludeFilter</strong>: 容器过滤</li><li><strong>@OverrideAutoConfiguration(enabled &#x3D; false)</strong>: 禁用自动配置加载，如果是boot2.2.x之前的版本，此配置不会生效，可以使用 @ContextConfiguration(classes &#x3D; EmptyConfiguration.class) 替代，其中 EmptyConfiguration 表示空的配置</li></ul><ol start="2"><li>要简化单测的流程，就需要将重复的工作声明化，即使用注解完成自动配置的大部分工作；具体需要如何处理呢，我们可以将常用单测注解进行声明化处理，编写单测时只需引入对应组件的注解即可</li></ol><ul><li><strong>service</strong> 仅对service进行单测，可声明以下注解，构建一个简单的spring容器即可，需要测试哪个service，直接Import加载即可；若此service中有其他注解，可进行mock处理，这里不再赘述mock的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TestService</span></span><br><span class="line"><span class="comment">// 若是boot2.2.x之后这里不再需要，因为元注解中已经增加了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// @RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;</span></span><br><span class="line"><span class="meta">        LabelService.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LabelService labelService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>redis</strong> 对redis进行单测，需要引入redis相关的自动配置，如下代码中的 RedisTestAutoConfiguration 类，不同项目使用的框架不同，自动装配也不相同，这里需要根据项目进行个性化设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        RedisTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRedis &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        LettuceAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRedis</span></span><br><span class="line"><span class="comment">// 优先级最高，可覆盖项目中的配置文件</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;</span></span><br><span class="line"><span class="meta">        &quot;redis.host=localhost:6379&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getRedisHost</span><span class="params">()</span> &#123;</span><br><span class="line">        assertThat(redisClient)</span><br><span class="line">        .isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>kafka</strong> kafka单测也和redis一样，进行个性化配置即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestKafka &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其他组件也都是一样的做法，笔者暂时用到的组件如下<ul><li>feign</li><li>kafka</li><li>mongodb</li><li>redis</li><li>service</li><li>controller</li><li>mybatis</li></ul></li></ul><p>tips: 如果不知道组件需要加载哪些配置，可通过完整启动项目打印所有装配的配置，然后再筛选需要的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderPrint</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;标题党，各位大佬手下留情&lt;del&gt;_&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;!! 笔者使用的是 2.6.6 版本&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/categories/spring-boot/"/>
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
    <category term="单元测试" scheme="https://taeyang0126.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>rocksdb</title>
    <link href="https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/</id>
    <published>2025-02-19T15:52:22.000Z</published>
    <updated>2025-02-19T15:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h4><p><img data-src="/images/db/rocksdb/image1.png" alt="image1.png"></p><h4 id="数据读取流程"><a href="#数据读取流程" class="headerlink" title="数据读取流程"></a>数据读取流程</h4><p><img data-src="/images/db/rocksdb/image2.png" alt="image2.png"></p><h4 id="db-相关属性"><a href="#db-相关属性" class="headerlink" title="db 相关属性"></a>db 相关属性</h4><table><thead><tr><th>类别</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>总体统计</td><td>rocksdb.stats</td><td>提供详细的数据库统计信息，包括压缩、读写操作、块缓存等数据</td></tr><tr><td>数据库大小</td><td>rocksdb.total-sst-files-size</td><td>所有 SST 文件的总大小</td></tr><tr><td></td><td>rocksdb.estimate-table-readers-mem</td><td>估计表读取器使用的内存</td></tr><tr><td></td><td>rocksdb.estimate-live-data-size</td><td>估计的活跃数据大小</td></tr><tr><td>内存使用</td><td>rocksdb.cur-size-all-mem-tables</td><td>所有 MemTable 的当前大小</td></tr><tr><td></td><td>rocksdb.block-cache-usage</td><td>块缓存的使用量</td></tr><tr><td>压缩</td><td>rocksdb.background-errors</td><td>后台工作（如压缩）中的错误数</td></tr><tr><td></td><td>rocksdb.num-running-compactions</td><td>当前运行的压缩任务数</td></tr><tr><td>写入</td><td>rocksdb.num-immutable-mem-table</td><td>不可变 MemTable 的数量</td></tr><tr><td></td><td>rocksdb.mem-table-flush-pending</td><td>是否有待处理的 MemTable 刷新</td></tr><tr><td></td><td>rocksdb.is-write-stopped</td><td>写入是否已停止</td></tr><tr><td></td><td>rocksdb.actual-delayed-write-rate</td><td>实际的延迟写入速率</td></tr><tr><td>读取</td><td>rocksdb.estimate-num-keys</td><td>估计的键数量</td></tr><tr><td>文件</td><td>rocksdb.num-files-at-level<N></td><td>第 N 层的文件数量（如 rocksdb.num-files-at-level0）</td></tr><tr><td></td><td>rocksdb.live-sst-files-size</td><td>活跃 SST 文件的大小</td></tr></tbody></table><p>注意：</p><ol><li>使用方法示例：<code>String value = db.getProperty(&quot;rocksdb.stats&quot;);</code></li><li>某些属性可能会影响性能，应谨慎使用。</li><li>属性值可能会频繁变化，建议定期获取以监控趋势。</li><li>在生产环境中使用时，可能需要限制获取这些属性的频率。</li></ol><h4 id="事务操作使用场景"><a href="#事务操作使用场景" class="headerlink" title="事务操作使用场景"></a>事务操作使用场景</h4><ul><li>为单个 key 提供并发控制<ol><li>事务开始时获取逻辑锁</li><li>提交时检查冲突</li><li>避免显式锁定，提高并发性</li><li>减少死锁风险</li><li>计数器更新</li><li>用户状态修改</li></ol></li><li>确保多个 key 的一致性更新<ol><li>将多个 key 操作组合为单一事务</li><li>全部成功或全部失败</li><li>维护相关数据的一致性</li><li>简化复杂操作的实现</li><li>用户注册（创建账户 + 初始化设置）</li><li>订单处理（更新库存 + 记录订单）</li></ol></li></ul><h4 id="RocksDB-默认冲突检测机制"><a href="#RocksDB-默认冲突检测机制" class="headerlink" title="RocksDB 默认冲突检测机制"></a>RocksDB 默认冲突检测机制</h4><h5 id="事务间冲突检测"><a href="#事务间冲突检测" class="headerlink" title="事务间冲突检测"></a>事务间冲突检测</h5><ol><li>触发时机：事务提交时</li><li>检测对象：活跃事务之间的写集</li><li>检测方式：<ol><li>每个事务的 put 操作都会记录在写集中</li><li>提交时检查本事务的写集是否与其他活跃事务的写集冲突</li><li>结果：如果发现冲突，后提交的事务通常会失败</li></ol></li></ol><h5 id="非事务性写入检测"><a href="#非事务性写入检测" class="headerlink" title="非事务性写入检测"></a>非事务性写入检测</h5><ol><li>触发时机：执行非事务性写入时（如 txnDb.put()）</li><li>检测对象：所有活跃事务的锁和写意图</li><li>检测方式：<ol><li>检查目标键是否被任何活跃事务锁定</li><li>检查是否有活跃事务对该键有写意图</li><li>结果：如果存在冲突，非事务性写入会失败并抛出异常</li></ol></li></ol><h5 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h5><ol><li>写意图（Write Intents）：事务执行写操作时登记，用于冲突检测</li><li>锁定机制：事务的 put 操作会为相应的键设置锁</li><li>快照隔离：事务开始时获取数据快照，影响可见的数据版本</li><li>乐观并发控制（默认）：大多数冲突检测在提交时进行</li><li>悲观锁定（可配置）：启用后，冲突检测在写操作执行时就会进行</li></ol><h4 id="RocksDB-读取策略"><a href="#RocksDB-读取策略" class="headerlink" title="RocksDB 读取策略"></a>RocksDB 读取策略</h4><h5 id="读已提交-默认"><a href="#读已提交-默认" class="headerlink" title="读已提交(默认)"></a>读已提交(默认)</h5><p>内部事务对于外部事务提交的立马可见</p><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readOptions.setSnapshot(snapshot);</span><br></pre></td></tr></table></figure><p>快照读类比于读已提交，对于外部事务只能看到当前快照创建时提交的数据，对于当前事务，所有写入都是可见的</p><h4 id="RocksDB-事务版本号管理"><a href="#RocksDB-事务版本号管理" class="headerlink" title="RocksDB 事务版本号管理"></a>RocksDB 事务版本号管理</h4><ul><li>对于冲突检测来说，使用事务开始时的快照序列号作为基准，比较操作键的当前序列号与快照序列号</li><li>对于提交来说，获取新的全局序列号作为起始点，将事务内部的临时序列号映射到连续的全局序列号，最终序列号 &#x3D; 新全局序列号 + 临时序列号偏移</li><li>所以会出现某个事务过程中，外部事务修改了键，内部事务再使用getForUpdate就会报错，因为比较实用的是快照的序列号</li><li>getForUpdate还有个好处就是能检测外部非事务性操作，因为本质上使用的是序列号比较，所以能检测，但是默认的写写冲突是无法检测的，因为默认是读已提交，rocksdb认为这是合理的，内部事务会覆盖外部事物的值</li></ul><table><thead><tr><th>方面</th><th>描述</th></tr></thead><tbody><tr><td>全局序列号</td><td>- 全局递增的序列号作为版本标识<br>- 每次非事务写入或事务提交时分配</td></tr><tr><td>事务开始</td><td>- 创建数据库快照<br>- 记录当前最大序列号作为事务”基线”</td></tr><tr><td>读操作</td><td>- 使用事务开始时的快照序列号<br>- 只读取序列号≤快照序列号的数据</td></tr><tr><td>写操作</td><td>- 不立即分配全局序列号<br>- 事务内部使用临时本地序列号</td></tr><tr><td>事务提交</td><td>- 获取新的全局序列号<br>- 将事务内写操作映射到连续的全局序列号<br>- 用新序列号更新数据库</td></tr><tr><td>回滚处理</td><td>- 丢弃事务内的所有本地序列号<br>- 不影响全局序列号</td></tr><tr><td>冲突检测</td><td>- 读写冲突：比较快照序列号与当前数据序列号<br>- 写写冲突：提交时检查数据是否被其他事务修改</td></tr><tr><td>OptimisticTransactionDB</td><td>- 延迟冲突检测到提交阶段<br>- 提交时比较数据当前序列号与事务开始序列号</td></tr><tr><td>TransactionDB</td><td>- 可能在操作过程中进行冲突检测<br>- 使用锁机制预防冲突</td></tr><tr><td>隔离级别影响</td><td>- 读已提交：每次读操作使用最新快照<br>- 可重复读：整个事务使用开始时的快照<br>- 快照隔离：类似可重复读，但有额外写冲突检测</td></tr><tr><td>注意事项</td><td>- 版本号管理是实现 MVCC 的基础<br>- 有助于理解和处理事务冲突和并发问题</td></tr></tbody></table><h4 id="getForUpdate总结"><a href="#getForUpdate总结" class="headerlink" title="getForUpdate总结"></a>getForUpdate总结</h4><ol><li>用来解决读写冲突，这里的冲突可以是事务与其他事务之间，也可以是事务与非事务操作之间</li><li>我认为是使用序列号进行检测的，当前快照的序列号与键的序列号之间的比较判断是否冲突</li><li>对于OptimisticTransactionDB和TransactionDB检测的时机不一样，前者属于乐观型的，在commit才会检测，后者会立即检测</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;数据写入流程&quot;&gt;&lt;a href=&quot;#数据写入流程&quot; class=&quot;headerlink&quot; title=&quot;数据写入流程&quot;&gt;&lt;/a&gt;数据写入流程&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;/images/db/rocksdb/image1.png&quot; alt=&quot;image1.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据读取流程&quot;&gt;&lt;a href=&quot;#数据读取流程&quot; class=&quot;headerlink&quot; title=&quot;数据读取流程&quot;&gt;&lt;/a&gt;数据读取流程&lt;/h4&gt;</summary>
    
    
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/categories/rocksdb/"/>
    
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/tags/rocksdb/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/</id>
    <published>2025-02-19T14:51:22.000Z</published>
    <updated>2025-02-19T14:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-执行命令编译"><a href="#1-执行命令编译" class="headerlink" title="1. 执行命令编译"></a>1. 执行命令编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=./src/main/java ./proto3/User.proto</span><br></pre></td></tr></table></figure><h4 id="2-通过maven插件"><a href="#2-通过maven插件" class="headerlink" title="2. 通过maven插件"></a>2. 通过maven插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断系统--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Protobuf Maven 插件</span></span><br><span class="line"><span class="comment">        作用：</span></span><br><span class="line"><span class="comment">             - 自动下载和使用 protoc 编译器</span></span><br><span class="line"><span class="comment">             - 编译 .proto 文件生成 Java 代码</span></span><br><span class="line"><span class="comment">             - 集成到 Maven 生命周期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- protoc 编译器配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- proto 文件源目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>$&#123;project.basedir&#125;/src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的 Java 代码输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/protobuf/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否清空输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>true<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-proto3"><a href="#3-proto3" class="headerlink" title="3. proto3"></a>3. proto3</h4><ul><li>所有字段都有默认值，比如string默认为空串</li><li>因为有默认值，所以所有的字段都是不为null的，需要判断是否为空，hasXXX()、getCount() &gt; 0 等等进行判断</li><li>使用 1-15 的字段号给最常用的字段  （频繁访问的字段放在前面，cpu缓存命中率更高）</li><li>不常用字段使用 16+ 的字段号  （不常访问的字段放在后面）</li><li>对于较小范围的数字，用 int32 而不是 int64</li><li>固定长度的数字用 fixed32&#x2F;fixed64</li><li>对于负数多的场景用 sint32&#x2F;sint64</li><li>字段更新规则！！<ol><li>添加新字段</li><li>删除字段(但保留字段号)</li><li>重命名字段(字段号不变)</li><li>添加repeated字段   reserved 2, 15, 9 to 11;       &#x2F;&#x2F; 保留字段号  reserved “foo”, “bar”;         &#x2F;&#x2F; 保留字段名</li></ol></li><li>字段不能做的更新规则！！<ol><li>改变已有字段的类型</li><li>复用已删除的字段号</li><li>改变已有字段的编号</li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-执行命令编译&quot;&gt;&lt;a href=&quot;#1-执行命令编译&quot; class=&quot;headerlink&quot; title=&quot;1. 执行命令编译&quot;&gt;&lt;/a&gt;1. 执行命令编译&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protoc --java_out=./src/main/java ./proto3/User.proto&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-通过maven插件&quot;&gt;&lt;a href=&quot;#2-通过maven插件&quot; class=&quot;headerlink&quot; title=&quot;2. 通过maven插件&quot;&gt;&lt;/a&gt;2. 通过maven插件&lt;/h4&gt;</summary>
    
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/categories/protobuf/"/>
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/tags/protobuf/"/>
    
    <category term="序列化" scheme="https://taeyang0126.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>panama</title>
    <link href="https://taeyang0126.github.io/2025/02/19/panama/panama/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/panama/panama/posts/undefined/</id>
    <published>2025-02-19T13:51:22.000Z</published>
    <updated>2025-02-19T13:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://openjdk.org/jeps/454">JEP 454: Foreign Function &amp; Memory API</a></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><blockquote><p>通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。</p></blockquote><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><ul><li>JNI 涉及几个繁琐的人工制品：一个 Java API（ native 方法）、一个从 Java API 派生的 C 头文件和一个调用目标原生库的 C 实现。Java 开发人员必须跨多个工具链工作以保持平台相关的人工制品同步，而这在原生库快速演化时尤其繁重。</li><li>JNI 只能与用操作系统和 CPU 的调用约定编写的语言（通常是 C 和 C++）编写的库进行交互，这是 JVM 为其构建的。native 方法不能用于调用以使用不同约定的语言编写的函数。</li><li>JNI 无法协调 Java 类型系统和 C 类型系统。Java 代码使用对象表示聚合数据，但 C 代码使用结构表示聚合数据，因此任何传递给 native 方法的 Java 对象都必须由本机代码费力地解包。例如，考虑一个 Java 记录类 Person ：将一个 Person 对象传递给 native 方法，要求本机代码使用 JNI 的 C API 从该对象中提取字段（例如， firstName 和 lastName ）。因此，Java 开发人员有时会将他们的数据展平到单个对象中（例如，字节数组或直接字节缓冲区），但更多情况下，由于通过 JNI 传递 Java 对象速度很慢，他们使用 Unsafe API 分配堆外内存并将其地址作为 long 传递给 native 方法 - 这使得 Java 代码非常不安全！</li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol><li>控制外内存的分配和释放</li><li>操控和访问结构化的外部内存</li><li>调用外部函数（ Linker 、 SymbolLookup 、 FunctionDescriptor 和 MethodHandle ）</li></ol><h3 id="Memory-segments-and-arenas"><a href="#Memory-segments-and-arenas" class="headerlink" title="Memory segments and arenas"></a>Memory segments and arenas</h3><ul><li>内存段是一个由一块连续的内存区域支持的抽象概念，该区域可以位于堆外或堆上。<ol><li>从非堆内存中从头分配的本机段（如同通过 malloc)</li><li>映射段，围绕一块映射的非堆内存（如通过 mmap ）</li><li>一个数组或缓冲区段，它被包装在一个与现有 Java 数组或字节缓冲区关联的堆上内存区域周围</li></ol></li><li>所有内存段都提供空间和时间边界，这些边界确保内存访问操作是安全的。简而言之，这些边界保证不使用未分配的内存，也不进行释放后使用。</li><li><code>global arena</code> 全局区域，它提供无限的生命周期：它始终保持活动状态，只有在JVM退出的时候才会被自动卸载</li><li><code>Auto arena</code> 自动 arena 提供了有限的生命周期：由自动 arena 分配的段可以被访问，直到 JVM 的垃圾回收器检测到该内存段不可访问，此时该段背后的内存区域将被释放</li><li><code>confined arena</code> 提供了一种有界限且确定性的生存期：从客户端打开区域到客户端关闭区域之间的这段时间它将一直存在。在受限区域中分配的内存段只能在关闭区域之前访问，在关闭区域时，支持该段的内存区域将被取消分配。在区域关闭后尝试访问内存段将失败并引发异常。!!只有一个线程可以访问</li><li><code>shared arena</code> 在共享区域中分配的内存段可以被多个线程访问，并且任何线程——无论是否访问该区域——都可以关闭该区域以释放这些段。关闭区域会原子地使这些段无效，尽管支持这些段的内存区域的释放可能不会立即发生，因为需要昂贵的同步操作来检测和取消对这些段的挂起并发访问操作</li></ul><h3 id="Zero-length-memory-segments"><a href="#Zero-length-memory-segments" class="headerlink" title="Zero-length memory segments"></a>Zero-length memory segments</h3><ul><li>FFM API 将外函数返回的指针表示为零长度的内存段。该段的地址是该指针的值，该段的大小为零。类似地，当客户端从内存段读取指针时，将返回一个零长度的内存段。</li><li>任何 Address 布局返回的MemorySegment都是 Zero-length memory segments</li><li>零长度段具有微不足道的空间边界，因此任何访问此类段的尝试都会失败，并带有 IndexOutOfBoundsException 。这是一个至关重要的安全特性：由于这些段与大小未知的内存区域相关联，因此涉及这些段的访问操作无法验证。实际上，零长度内存段封装了一个地址，在没有明确意图的情况下无法使用它。</li><li>可以使用 MemorySegment::reinterpret 方法将零长度内存段转换为特定大小的本机段。 此方法将新的空间和时间边界附加到零长度内存段，以便允许解除引用操作。 此方法返回的内存段不安全：零长度内存段可能由 10 字节长的内存区域支持，但客户端可能会高估该区域的大小并使用 MemorySegment::reinterpret 获取 100 字节长的段。 稍后，这可能会导致尝试在该区域边界之外解除引用内存，从而可能导致 JVM 崩溃或更糟的情况，导致静默内存损坏。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/454&quot;&gt;JEP 454: Foreign Function &amp;amp; Memory API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="panama" scheme="https://taeyang0126.github.io/categories/panama/"/>
    
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
    <category term="panama" scheme="https://taeyang0126.github.io/tags/panama/"/>
    
    <category term="ffi" scheme="https://taeyang0126.github.io/tags/ffi/"/>
    
  </entry>
  
  <entry>
    <title>loom-springboot</title>
    <link href="https://taeyang0126.github.io/2025/02/19/loom/loom-springboot/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/loom/loom-springboot/posts/undefined/</id>
    <published>2025-02-19T12:52:22.000Z</published>
    <updated>2025-02-19T12:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring-Boot-使用-project-loom"><a href="#Spring-Boot-使用-project-loom" class="headerlink" title="Spring Boot 使用 project loom"></a>Spring Boot 使用 project loom</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul><li>jdk 22.0.1-graal</li><li>maven 3.6.3</li><li>内置容器 tomcat，最大线程数量 256</li><li>Xms200M Xmx300M</li><li>压测条件: 1000线程 循环100次 Ramp-up&#x3D;10s</li><li>M1 max 64g</li><li>SpringBoot 3.3.0</li></ul><h5 id="普通线程，同步请求"><a href="#普通线程，同步请求" class="headerlink" title="普通线程，同步请求"></a>普通线程，同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>压测吞吐量253&#x2F;s，与配置最大线程 256 基本一致</li></ul><p><img data-src="/images/loom/img4.png" alt="img.png"></p><ul><li>内存、线程占用情况</li></ul><p><img data-src="/images/loom/img3.png" alt="普通线程.png"></p><h5 id="虚拟线程，异步servlet"><a href="#虚拟线程，异步servlet" class="headerlink" title="虚拟线程，异步servlet"></a>虚拟线程，异步servlet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/loom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">helloLoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回异步 -&gt; springmvc会处理为异步servlet，提升吞吐量</span></span><br><span class="line">    DeferredResult&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;();</span><br><span class="line">    Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setResult(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>压测吞吐量879&#x2F;s，大概是普通线程的3~4倍</li></ul><p><img data-src="/images/loom/img6.png" alt="&#x2F;images&#x2F;loom"></p><ul><li>内存、线程占用情况，可以发现虚拟线程的内存比普通线程占用要大<br>这个很好理解，因为开启的虚拟线程多了，虚拟线程也是对象，自然占用的内存会大一些</li></ul><p><img data-src="/images/loom/img5.png" alt="img.png"></p><h5 id="旧版本tomcat不支持异步线程"><a href="#旧版本tomcat不支持异步线程" class="headerlink" title="旧版本tomcat不支持异步线程"></a>旧版本tomcat不支持异步线程</h5><ul><li>版本9.0.60</li><li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法是用 <code>synchronized</code><br>包裹住的，导致虚拟线程无法卸载，这个版本下即使替换了tomcat线程池为虚拟线程池，也会造成阻塞<br><img data-src="/images/loom/img.png" alt="img.png"></li><li>之所以在这里需要使用锁是因为对于一个socket来说，需要保证并发安全，因为这里是在业务线程池executor执行的，会有多个线程访问同一个socket，这里的锁就是锁住每个连接，防止单个连接多个请求并发(题外话: netty高明之处就在于事件监听+事件处理都是用一个eventLoop，就不存在并发问题，如果使用者使用了异步线程池，也只需要在涉及channel的操作放到eventLoop中执行大概率不会有什么并发问题)</li><li>如果在此版本下想要支持虚拟线程，可以使用上面的方式，将同步servlet转换为异步servlet，再使用虚拟线程包裹一层</li></ul><h5 id="新版本tomcat支持异步线程"><a href="#新版本tomcat支持异步线程" class="headerlink" title="新版本tomcat支持异步线程"></a>新版本tomcat支持异步线程</h5><ul><li>版本10.1.24</li><li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法调整为用 <code>ReentrantLock</code> 进行加锁，这样虚拟线程可以正常卸载<br><img data-src="/images/loom/img2.png" alt="img.png"></li><li>此版本下如何启用虚拟线程?<ol><li>自定义 <code>WebServerFactoryCustomizer</code> 修改tomcat执行线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadExecutorWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableTomcatWebServerFactory&gt;, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(ConfigurableTomcatWebServerFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newThreadPerTaskExecutor(Thread.ofVirtual().name(<span class="string">&quot;tomcat-virtual-&quot;</span>, <span class="number">0</span>).factory());</span><br><span class="line">        factory.addProtocolHandlerCustomizers(</span><br><span class="line">                (protocolHandler) -&gt; protocolHandler.setExecutor(executorService));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用框架自带的 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code></li><li>测试发现二者性能相差不大，可自行选择，不过 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code> 底层使用了反射，性能可能略有损耗，更推荐第一种自定义的</li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Spring-Boot-使用-project-loom&quot;&gt;&lt;a href=&quot;#Spring-Boot-使用-project-loom&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 使用 project loom&quot;&gt;&lt;/a&gt;Spring Boot 使用 project loom&lt;/h4&gt;&lt;h5 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;jdk 22.0.1-graal&lt;/li&gt;
&lt;li&gt;maven 3.6.3&lt;/li&gt;
&lt;li&gt;内置容器 tomcat，最大线程数量 256&lt;/li&gt;
&lt;li&gt;Xms200M Xmx300M&lt;/li&gt;
&lt;li&gt;压测条件: 1000线程 循环100次 Ramp-up&amp;#x3D;10s&lt;/li&gt;
&lt;li&gt;M1 max 64g&lt;/li&gt;
&lt;li&gt;SpringBoot 3.3.0&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/categories/loom/"/>
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/tags/loom/"/>
    
    <category term="虚拟线程" scheme="https://taeyang0126.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>loom</title>
    <link href="https://taeyang0126.github.io/2025/02/19/loom/loom/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/loom/loom/posts/undefined/</id>
    <published>2025-02-19T12:51:22.000Z</published>
    <updated>2025-02-19T12:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://wiki.openjdk.org/display/loom">openjdk loom</a></li><li><a href="https://openjdk.org/jeps/444">虚拟线程</a></li><li><a href="https://openjdk.org/jeps/480">结构化并发</a></li><li><a href="https://inside.java/2021/05/10/networking-io-with-virtual-threads/">虚拟线程网络IO实现原理</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html">Project Loom: Java虚拟机的纤程和计算续体</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html">State of Loom: part 1</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part2.html">State of Loom: part 2</a></li><li><a href="https://zhuanlan.zhihu.com/p/685013298">虚拟线程不推荐上生产的思考</a></li><li><a href="https://zhuanlan.zhihu.com/p/686222059">Java 虚拟线程截止 2024-3-10 在 OpenJDK 还没有解决消息的问题</a></li><li><a href="https://openjdk.org/jeps/481">Scoped Values</a></li></ul><h3 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h3><blockquote><p>We say that a virtual thread is <code>pinned</code> to its carrier if it is mounted but is in a state in which it cannot be unmounted. If a virtual thread blocks while pinned, it blocks its carrier. This behavior is still correct, but it holds on to a worker thread for the duration that the virtual thread is blocked, making it unavailable for other virtual threads.</p></blockquote><ul><li>Java 代码调用本地代码 (JNI)</li><li>synchronized 块或方法</li></ul><h4 id="减少pin发生"><a href="#减少pin发生" class="headerlink" title="减少pin发生"></a>减少pin发生</h4><ul><li>synchronized 保护的普通 I&#x2F;O 操作，请用 <code>ReentrantLock</code> 替换监视器，（如果可以的话，使用性能更高的 <code>StampedLock</code> 效果会更好）。</li></ul><h4 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h4><ol><li>Synchronization<ul><li>synchronized最终会解决，但是JNI不会处理</li><li>java.util.concurrent 中部分已经调整，比如LockSupport.park &#x2F; unpark 但是还有大部分的工作</li></ul></li><li>I&#x2F;O<ul><li>java.nio.channels 和 ServerSocketChannel 和 DatagramChannel 类改造为支持虚拟线程。当它们的同步操作（如 read 和 write ）在虚拟线程上执行时，在底层仅使用非阻塞 I&#x2F;O。</li><li>getHostName 、 getCanonicalHostName 和 getByName 方法的 DNS 查找仍然委托给操作系统,而操作系统仅提供一个阻塞操作系统线程的 API。正在探索替代方案。</li><li>Http(s)URLConnection 和 TLS&#x2F;SSL 的实现已更改为依赖 j.u.c 锁并避免pin</li><li>文件 I&#x2F;O 存在问题。内部,JDK 对文件使用缓冲 I&#x2F;O,即使读取操作会阻塞,也始终报告可用字节数。在 Linux 上,我们计划使用 io_uring 进行异步文件 I&#x2F;O,同时我们正在使用 ForkJoinPool.ManagedBlocker 机制,通过向工作池添加更多 OS 线程来平滑阻塞文件 I&#x2F;O 操作。</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.openjdk.org/display/loom&quot;&gt;openjdk loom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/444&quot;&gt;虚拟线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/480&quot;&gt;结构化并发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://inside.java/2021/05/10/networking-io-with-virtual-threads/&quot;&gt;虚拟线程网络IO实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html&quot;&gt;Project Loom: Java虚拟机的纤程和计算续体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html&quot;&gt;State of Loom: part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/loom/sol1_part2.html&quot;&gt;State of Loom: part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/685013298&quot;&gt;虚拟线程不推荐上生产的思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/686222059&quot;&gt;Java 虚拟线程截止 2024-3-10 在 OpenJDK 还没有解决消息的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/481&quot;&gt;Scoped Values&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pin&quot;&gt;&lt;a href=&quot;#pin&quot; class=&quot;headerlink&quot; title=&quot;pin&quot;&gt;&lt;/a&gt;pin&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;We say that a virtual thread is &lt;code&gt;pinned&lt;/code&gt; to its carrier if it is mounted but is in a state in which it cannot be unmounted. If a virtual thread blocks while pinned, it blocks its carrier. This behavior is still correct, but it holds on to a worker thread for the duration that the virtual thread is blocked, making it unavailable for other virtual threads.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/categories/loom/"/>
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/tags/loom/"/>
    
    <category term="虚拟线程" scheme="https://taeyang0126.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jvm监控和故障处理工具</title>
    <link href="https://taeyang0126.github.io/2025/02/19/jvm/jvm-jian-kong-he-gu-zhang-chu-li-gong-ju/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/jvm/jvm-jian-kong-he-gu-zhang-chu-li-gong-ju/posts/undefined/</id>
    <published>2025-02-19T05:53:30.000Z</published>
    <updated>2025-02-19T05:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令行处理工具"><a href="#命令行处理工具" class="headerlink" title="命令行处理工具"></a>命令行处理工具</h3><h4 id="1-jps"><a href="#1-jps" class="headerlink" title="1. jps"></a>1. jps</h4><blockquote><p>显示指定系统类所有的HotSpot虚拟机进程</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有java进程，输出主类的名称</span></span><br><span class="line">jps -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机进程启动时传给主类main()函数的参数</span></span><br><span class="line">jps -m </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机启动时JVM参数</span></span><br><span class="line">jps -v</span><br></pre></td></tr></table></figure><h4 id="2-jstat"><a href="#2-jstat" class="headerlink" title="2. jstat"></a>2. jstat</h4><blockquote><p>用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p></blockquote><blockquote><p>命令格式: jstat [ option vmind [interval[s|ms]] [count] ]-printcompilation</p></blockquote><ul><li>选项<code>option</code>代表用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况 使用 <code>jstat -options</code> 获取支持的options</li></ul><table><thead><tr><th>选项</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td><td><img data-src="/images/jvm/img.png" alt="img.png"></td></tr><tr><td>-gc</td><td>监视java堆状况</td><td><img data-src="/images/jvm/img2.png" alt="img.png">  <img data-src="/images/jvm/img3.png" alt="img.png"></td></tr><tr><td>-gccapacity</td><td>与-gc基本相同，主要关注堆各个区域使用到的最大最小空间</td><td><img data-src="/images/jvm/img4.png" alt="img.png"></td></tr><tr><td>-gcutil</td><td>与-gc基本相同，主要关注已使用空间占总空间的百分比</td><td><img data-src="/images/jvm/img5.png" alt="img.png"></td></tr><tr><td>-gccause</td><td>与-gcutil基本相同，但是会额外输出导致上一次GC产生的原因</td><td>LGCC: 上一次垃圾收集的原因 GCC: 触发垃圾收集的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td><td></td></tr><tr><td>-gcnewcapacity</td><td>与gcnew基本相同，主要关注使用到的最大、最小空间</td><td></td></tr><tr><td>-gcold</td><td>监视老年代GC状况</td><td></td></tr><tr><td>-gcoldcapacity</td><td>与gcold基本相同，主要关注使用到的最大、最小空间</td><td></td></tr><tr><td>-gcmetacapacity</td><td>metaspace用的最大、最小空间</td><td></td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td><td></td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td><td></td></tr></tbody></table><h4 id="3-jinfo"><a href="#3-jinfo" class="headerlink" title="3. jinfo"></a>3. jinfo</h4><blockquote><p>Java配置信息工具。使用<code>jps -v</code>可以查看虚拟机启动时显示指定的参数列表，如果想知道未被显示指定的参数的系统默认值，可以使用 jinfo 的 -flag 选项查询</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看进程所有的参数</span></span><br><span class="line">jinfo -flags #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个参数</span></span><br><span class="line">jinfo -flag UseG1GC #pid</span><br></pre></td></tr></table></figure><h4 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4. jmap"></a>4. jmap</h4><blockquote><p>jmap(Memory Map for Java) 命令用于生产堆快照(heapdump)。还可以查询finalize执行队列、java堆和metaspace的详细信息，如空间使用率、当前使用的是哪种收集器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 jmap 查看更多命令</span></span><br><span class="line">jmap </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示堆中对象统计信息，包括类、实例数量、合计容量</span></span><br><span class="line">jmap -histo:live,file=histo.data #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成dump快照 在线分析工具 https://heaphero.io/</span></span><br><span class="line">jmap -dump:live,format=b,file=hh.bin #pid</span><br></pre></td></tr></table></figure><h4 id="5-jstack"><a href="#5-jstack" class="headerlink" title="5. jstack"></a>5. jstack</h4><blockquote><p>用于生成虚拟机当前时刻的线程快照</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前线程堆栈输出到某个文件</span></span><br><span class="line">jstack -l 17723 &gt; thread.info</span><br></pre></td></tr></table></figure><h4 id="6-jcmd"><a href="#6-jcmd" class="headerlink" title="6. jcmd"></a>6. jcmd</h4><blockquote><p>jcmd 是从 Java 7 开始引入的一个命令行工具。它提供了一种非常强大和灵活的方式来与 JVM 进行交互，可以用于诊断和监控 Java 应用程序。jcmd是以上工具的集合</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用命令</span></span><br><span class="line">jcmd &lt;pid&gt; help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 JVM 运行时信息</span></span><br><span class="line">jcmd &lt;pid&gt; VM.info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印堆转储</span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump &lt;filename&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印线程信息</span></span><br><span class="line">jcmd &lt;pid&gt; Thread.print</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印系统属性</span></span><br><span class="line">jcmd &lt;pid&gt; VM.system_properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 JVM 配置参数</span></span><br><span class="line">jcmd &lt;pid&gt; VM.flags</span><br></pre></td></tr></table></figure><h3 id="可视化处理工具"><a href="#可视化处理工具" class="headerlink" title="可视化处理工具"></a>可视化处理工具</h3><h4 id="1-JCconsole"><a href="#1-JCconsole" class="headerlink" title="1. JCconsole"></a>1. JCconsole</h4><blockquote><p>JConsole 是一个图形化界面，用于监控和配置 Java 应用程序。它提供了一些基本的监控功能，如线程、内存、垃圾回收、类加载等，并提供了插件机制，可以扩展到更复杂的监控需求。</p></blockquote><p>a. 启动JConsole</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位于jdk/bin目录下</span></span><br><span class="line">open `sdk home java 17.0.11-zulu`/bin/jconsole</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;命令行处理工具&quot;&gt;&lt;a href=&quot;#命令行处理工具&quot; class=&quot;headerlink&quot; title=&quot;命令行处理工具&quot;&gt;&lt;/a&gt;命令行处理工具&lt;/h3&gt;&lt;h4 id=&quot;1-jps&quot;&gt;&lt;a href=&quot;#1-jps&quot; class=&quot;headerlink&quot; title=&quot;1. jps&quot;&gt;&lt;/a&gt;1. jps&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;显示指定系统类所有的HotSpot虚拟机进程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="工具" scheme="https://taeyang0126.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
