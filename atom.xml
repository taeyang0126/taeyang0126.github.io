<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WL&#39;s blog</title>
  
  
  <link href="https://taeyang0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://taeyang0126.github.io/"/>
  <updated>2025-02-09T08:48:34.000Z</updated>
  <id>https://taeyang0126.github.io/</id>
  
  <author>
    <name>WU LEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1. Netty Reactor 启动流程</title>
    <link href="https://taeyang0126.github.io/2025/02/09/1.netty-reactor-qi-dong-liu-cheng/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/1.netty-reactor-qi-dong-liu-cheng/posts/undefined/</id>
    <published>2025-02-09T07:00:22.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://zhuanlan.zhihu.com/p/459313682">详细图解Netty Reactor启动全流程 | 万字长文 | 多图预警</a></p><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RkN2M3YjVjNDQ5ZDdkMGI0OGE2Y2MwMjY0MzQ4NTRfMlhkYk5KOEp5ZGxqT1lHeWphWWtjVzRCTGIzOGgyTjNfVG9rZW46WFZWQWJxR09EbzVMekh4NHdiNmNPT2JUbnZnXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h2 id="Netty-服务端的启动流程"><a href="#Netty-服务端的启动流程" class="headerlink" title="Netty 服务端的启动流程"></a>Netty 服务端的启动流程</h2><ul><li>创建服务端<code>NioServerSocketChannel</code>并初始化</li><li>将服务端<code>NioServerSocketChannel</code>注册到<code>主Reactor线程组</code>中</li><li>注册成功后，开始初始化<code>NioServerSocketChannel</code>中的 pipeline，然后在 pipeline 中触发 channelRegister 事件。</li><li>随后由<code>NioServerSocketChannel</code>绑定端口地址。</li><li>绑定端口地址成功后，向<code>NioServerSocketChannel</code>对应的<code>Pipeline</code>中触发传播<code>ChannelActive事件</code>，在<code>ChannelActive事件回调</code>中向<code>Main Reactor</code>注册<code>OP_ACCEPT事件</code>，开始等待客户端连接。服务端启动完成。</li></ul><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdjNjJhMmQwYmYzN2VmY2M4OTk4NTczZTA0ODZjMTBfd1kxMVl4ZWxiemtQcHIzRk01aDFxbHRaQU9Ud2hBZkhfVG9rZW46RGlVbGJaQUtGb2FtRkF4Zk1QbmNuaU85bmVlXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h2 id="1-initAndRegister"><a href="#1-initAndRegister" class="headerlink" title="1. initAndRegister"></a>1. initAndRegister</h2><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNlYWMzY2YzYjBiZDBjZmU5MzU2ZTMzZTAwNWQwNDhfc2g0Z0dGR0RZRUl2S2FPalB3b3Q3VUFhRUhKVnRIT2pfVG9rZW46RlJEVGJhQ2k0b2RKWGV4c01kS2M3S3dxbkRmXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><p>开始注册</p><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVlMmQyMWM0NzgzNThjYWMyNTYwMzZlZjc1NzM2MTFfQU9DaEFWNUJIeENxYnBZMVNUYmdLZFpLUDRhR1lGTHlfVG9rZW46V1JlTWJqSFhkb1FKR1N4OFI0S2NObWJqbnlkXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h2 id="2-Bind"><a href="#2-Bind" class="headerlink" title="2. Bind"></a>2. Bind</h2><p><code>bind事件</code>在 Netty 中被定义为<code>outbound事件</code>，所以它在<code>pipeline</code>中是反向传播。先从<code>TailContext</code>开始反向传播直到<code>HeadContext</code>；<code>bind</code>的核心逻辑也正是实现在<code>HeadContext</code>中</p><blockquote><p>headContext 中的绑定方法</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU2YWI1OWU2OGE5ZTRhMWY0ODEzYmI4ZTlmOGU3NGVfcE5lbkVzUU1lalNEWkZIUXQ1bzdvOGU3RFc2U05ZdW9fVG9rZW46RjhRSWIwR0xjbzl2RVh4TXNtMWM4WmpBbndjXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><blockquote><p>NioServerSocketChannel 中的绑定动作</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNjZGZhY2UxMmJiNDJkYmI3MzQxZjhjM2FmZWEzYmNfWTlwSWVSTmFtQWVERDQ2MXJ3eENPSGh0OW4yajJPdk9fVG9rZW46TEt1SmJTOWdxb1k3OXd4d0RZeWNKMmJRbklkXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><blockquote><p>绑定完成后触发 active 操作 –&gt; HeadContext</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=MjBkYTExNDA4YTJlNDI1MjllM2NkNzg3MGIyZjMyODNfRGNVRzFIZmpkTUpzRnAxTGhnS3k0NUdYdHNNVFRTeUVfVG9rZW46TU5TamJMeUtWb2hRRlN4cEg3b2MwYmtQbmpkXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><blockquote><p>io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=N2QxNjBkZGYzNDI3N2FjZThiY2ZhYmJkMjBmMGRmZmJfVTFwbkc4RGJrU1llcVN6QUlWVUc2MUlDRlV4Y3BwMTRfVG9rZW46U04yT2I3VjRsb01IN0d4VE1jd2M2Q241bjlnXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><blockquote><p>io.netty.channel.nio.AbstractNioChannel#doBeginRead</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJmNDAxY2NmZjgxMzZiOGE3YzczZDhmYmRhMjNhMTBfeHU3dTl4SUdiQ0x1RUJ2OUNneDVoazNnYWpTMHBHNVdfVG9rZW46U0t3dWJXdzg5bzJKd2J4b3dUaGNtTXREbjliXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h2 id="细节点"><a href="#细节点" class="headerlink" title="细节点"></a>细节点</h2><h3 id="Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的"><a href="#Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的" class="headerlink" title="Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的"></a><code>Reactor线程</code>的启动是在向<code>Reactor</code>提交第一个异步任务的时候启动的</h3><blockquote><p>io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable, boolean)</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=NWFjYzZhNDgyMDk3YmU2Y2U3ZDJjMDk1YzE0MjE2YjBfOHBSQ0xRa1pyRUFId3gwNmNIYTRXWjFUTFVLZkI0b05fVG9rZW46SWM3V2JNcVdpb1JqY1h4SzV6d2NPZWpLbjNnXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h3 id="Reactor线程的核心工作-轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务"><a href="#Reactor线程的核心工作-轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务" class="headerlink" title="Reactor线程的核心工作 轮询所有注册其上的Channel中的IO就绪事件，处理对应Channel上的IO事件，执行异步任务"></a><code>Reactor</code>线程的核心工作 <code>轮询所有注册其上的Channel中的IO就绪事件</code>，<code>处理对应Channel上的IO事件</code>，<code>执行异步任务</code></h3><blockquote><p>io.netty.channel.nio.NioEventLoop#run</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZjJiYjNiNzIyNTE4ZjJiNmQ3ZDE4MjliMDcwZWJfRmtZS0liRHp0ZGVNREFkZlVSRXBheTBLNWFNTU1aNGdfVG9rZW46R29RcmJIYlgxb043bEd4S0ZkTGNBN3VKbkRjXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h3 id="Channel-的各种事件触发顺序"><a href="#Channel-的各种事件触发顺序" class="headerlink" title="Channel 的各种事件触发顺序"></a>Channel 的各种事件触发顺序</h3><ol><li><p>handlerAdded</p><p> socket 向 jdk selector 注册后、在通知注册的 promise 完成之前（也就是 promise 回调之前）触发</p><p> <img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E3NmM0N2QzM2MwNDExMDc4OWNiYTFjYzIyMzRmODNfSnhEUTdXTkpITHRxWWlMV0VZRGFUaTl3UzhrOVdFSE1fVG9rZW46RHMyamJJU0Z1b1FMQXJ4c2JBOWNpNUtybjliXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p></li><li><p>channelRegistered</p><p> 在通知 promise 完成后（也就是回调执行完成之后）会传播 Registered 事件</p><p> <img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5MGIxYzk4NjcwNmU1NTVkZTE4MmQ4NjQ3YzA2ZjdfUEtkQ1czdGdKVnV5VTlpRXNwVTlUcVVrYkxQYjVRc0hfVG9rZW46QkdyTmJNS0ZPb3VWNFp4c2VHeWMyYVdNbkNiXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p></li><li><p>Active </p><p>a. 服务端 NioServerSocketChannel 判断是否激活的标准为端口是否绑定成功。</p><p>b. </p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractNioMessageChannel</span></span><br><span class="line">                             <span class="keyword">implements</span> <span class="title class_">io</span>.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isOpen() &amp;&amp; javaChannel().socket().isBound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 客户端<code>NioSocketChannel</code>判断是否激活的标准为是否处于<code>Connected状态</code>。</p><p>d. </p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> javaChannel();</span><br><span class="line">    <span class="keyword">return</span> ch.isOpen() &amp;&amp; ch.isConnected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> e. 向后传播 active 事件<br> f. <code>readIfIsAutoRead</code></p><blockquote><p>如果开启了自动读（io.netty.channel.ChannelConfig#isAutoRead），则注册对应感兴趣的事件</p></blockquote><ul><li>server 连接注册 OP_ACCEPT 事件</li><li>client 连接注册 OP_READ 事件</li></ul></li></ol><h3 id="向底层-selector-注册"><a href="#向底层-selector-注册" class="headerlink" title="向底层 selector 注册"></a>向底层 selector 注册</h3><blockquote><p>io.netty.channel.nio.AbstractNioChannel#doRegister</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE3MGZhZjAzZWE4ODE0ZjAzNjM2ZDY3MmM1NmY2MmRfOU1SUmU1WHVVbzFmVjg0RDNKYUcyZzZTdlBTaVpJakRfVG9rZW46SGtaSmJXSnpyb0xTQlp4aDZNb2NYMmlrbmdlXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h3 id="NioServerSocketChannel-注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行"><a href="#NioServerSocketChannel-注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行" class="headerlink" title="NioServerSocketChannel 注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行"></a>NioServerSocketChannel 注册成功后回调任务进行端口绑定，会将端口绑定封装为一个任务提交到队列中，而不是即刻执行</h3><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=OTBiZTI4ZjgwMjBhNjZhZTUxZDk5YmY4NDAyZTFlNzdfaWl3RUNlVjM2VDlXV01rekEycnFRSGtZc3I0bHRuRkdfVG9rZW46TVBva2JmTVdYb0F6OWF4UUI1WWNsVE9EbkliXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h3 id="事件在pipeline中的传播"><a href="#事件在pipeline中的传播" class="headerlink" title="事件在pipeline中的传播"></a>事件在<code>pipeline</code>中的传播</h3><ul><li><code>inbound事件</code>从<code>HeadContext</code>开始逐个向后传播直到<code>TailContext</code></li><li><code>outbound事件</code>则是反向传播，从<code>TailContext</code>开始反向向前传播直到<code>HeadContext</code></li></ul><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=NzgwNDg4ZDkwMjViMDI3OGM3MzJjZWY4MTYwZmFjODNfZzAxVllzZ1ZWVzJtemJ5dENZdHowVnh6VkNtUnVuaTVfVG9rZW46T0xFYmJOU1Y0b3Fnekd4N3JnZGN2cDZPbkZkXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><h3 id="服务端-Socket-和客户端-Socket-分别在何时向-seletor-注册感兴趣的事件？"><a href="#服务端-Socket-和客户端-Socket-分别在何时向-seletor-注册感兴趣的事件？" class="headerlink" title="服务端 Socket 和客户端 Socket 分别在何时向 seletor 注册感兴趣的事件？"></a>服务端 Socket 和客户端 Socket 分别在何时向 seletor 注册感兴趣的事件？</h3><ul><li>注册感兴趣的事件触发时机都是<code>ChannelActive</code><ul><li><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I2ZjE5ZjU1MTM0MjdjZWI0NjNiZTFlYWViZjdjYmJfM28xa05jbEl5OFdHUnVLS3U5bnRtMzRtOTNid0E5YzFfVG9rZW46SmNma2JNT0dRb0FIQjF4VXRwTGNZMWZjbkxnXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></li><li>对于服务端 socket 来说，bind 成功后会传递 <code>channelActive</code>事件</li><li>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</li><li><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZkMzU1OGZjZGM5NWQxNzNjNzdjYjA5YjlhNzJiZDBfUEtDN3FpOXFtbzZXNTRKYWF6ZDU3Vmo0ampra3UzVUNfVG9rZW46WG1hRmJiYkxWb3M5Q0l4OEp6RGMxS003bnNmXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></li><li>对于客户端 socket 来说，register 成功后会传递 <code>channelActive</code>事件</li><li>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</li><li><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIyOGFiNmY3MGQwOGYwZTY0OWFhYjEwMDU2NzMxYjJfMjU2UEJpb3AwdDRXUUJmZVp4STRDVXdRSDRKQkh1MEFfVG9rZW46UmE0RmJkQ09ab1o1S0h4Wm95c2MyQ3hobndDXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></li></ul></li><li>通过 <code>HeadContext#read</code> 方法进行感兴趣事件的注册</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBlMzQ4NTJjNzFiM2ZiNDFkZDhlMDAyNjc1MDJjN2ZfZzl5N1NUTE5YVzhkak1tOEVvS1g3aVF0aWtMRjlXOFFfVG9rZW46VnczYWJESDBGb3RWakl4OWxtMGNaemRqbkxjXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p><blockquote><p>io.netty.channel.nio.AbstractNioChannel#doBeginRead</p></blockquote><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA0MzgyZDc2NjY4YTY3N2NjNjgxMjRkYWNjN2NhYzZfaE8zOU1tWGhMSzRYWUlwdVR6Z3pZdHVjY2lUS0k1dWpfVG9rZW46Sm1ZNmI4TnFTb0VLZGp4YTVIQmNKS0NZbnlFXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/459313682&quot;&gt;详细图解Netty Reactor启动全流程 | 万字长文 | 多图预警&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RkN2M3YjVjNDQ5ZDdkMGI0OGE2Y2MwMjY0MzQ4NTRfMlhkYk5KOEp5ZGxqT1lHeWphWWtjVzRCTGIzOGgyTjNfVG9rZW46WFZWQWJxR09EbzVMekh4NHdiNmNPT2JUbnZnXzE3MzkwODQ0MjY6MTczOTA4ODAyNl9WNA&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/tags/Netty/"/>
    
    <category term="源码解析" scheme="https://taeyang0126.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Arthas</title>
    <link href="https://taeyang0126.github.io/2025/02/09/arthas/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/arthas/posts/undefined/</id>
    <published>2025-02-09T06:51:22.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://github.com/alibaba/arthas/issues/71">Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&#x2F;arthas</a></p></li><li><p><a href="https://github.com/alibaba/arthas/issues/1424">arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&#x2F;arthas</a></p></li><li><p><a href="https://github.com/alibaba/arthas/issues/537">Arthas实践–jad&#x2F;mc&#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&#x2F;arthas</a></p></li></ul><h3 id="1-获取当前HttpServletRequest"><a href="#1-获取当前HttpServletRequest" class="headerlink" title="1. 获取当前HttpServletRequest"></a>1. 获取当前HttpServletRequest</h3><ul><li><p>执行某个request方法</p><p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx</code></p></li><li><p>获取全部的请求头</p><p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()</code></p></li></ul><h3 id="2-获取spring-context-并执行某些操作"><a href="#2-获取spring-context-并执行某些操作" class="headerlink" title="2. 获取spring context 并执行某些操作"></a>2. 获取spring context 并执行某些操作</h3><blockquote><p><strong>前置</strong> 使用tt记录请求，获取到上下文</p><p>tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</p></blockquote><pre><code>tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;)&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).dataSource.ConnectionPool&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target.cacheMap&#39;tt -i 1000  -w &#39;target.getApplicationContext().getEnvironment().getProperty(&quot;spring.datasource.riskctrl.url&quot;)&#39;</code></pre><h3 id="3-使用ognl"><a href="#3-使用ognl" class="headerlink" title="3. 使用ognl"></a>3. 使用<a href="https://commons.apache.org/dormant/commons-ognl/language-guide.html">ognl</a></h3><ul><li><p>对前置表达式值进行二次计算  #this 表示前置表达式的值 <strong><code>.()</code></strong> 表示自表达式，产生一个单一值</p><p>  <strong><code>listeners.size().(#this &gt; 100? 2\*#this : 20+#this)</code></strong></p></li><li><p>对前置表达式进行二次计算，产生一个数组</p><p>  <strong><code>params[0].&#123;#this == &quot;lei&quot; ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p></li><li><p>对前置表达式(数组类型)进行二次计算，产生一个新的数组</p><p>  <strong><code>params.&#123;#this instanceof String ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p></li><li><p>返回数组中第一个匹配的对象</p><p>  <strong><code>params.&#123;^#this instanceof Integer&#125;</code></strong></p></li><li><p>调用static方法 使用  <strong>@class@method(<strong><strong>args</strong></strong>)</strong></p><p>  <strong><code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes()</code></strong></p></li><li><p>获取静态字段 <strong>@class@field</strong></p></li></ul><h3 id="4-一些常用命令"><a href="#4-一些常用命令" class="headerlink" title="4. 一些常用命令"></a>4. 一些常用命令</h3><ul><li><p>获取classloader hash，如果是springBoot项目取 org.springframework.boot.loader.LaunchedURLClassLoader</p><p>  <strong><code>classloader -t</code></strong></p></li><li><p>容器安装 vim</p><p>  <strong><code>apt-get update &amp;&amp; apt-get install -y vim</code></strong></p></li><li><p>Ognl 获取spring context</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 49c2faae 表示classloader hash</span><br><span class="line"># cn.hutool.extra.spring.SpringUtil 表示能获取到spring容器的方法</span><br><span class="line">ognl -c 49c2faae &#x27;#beanName=&quot;eventDataAuthManage&quot;, #bean=@cn.hutool.extra.spring.SpringUtil@getBean(#beanName), @org.springframework.aop.support.AopUtils@getTargetClass(#bean).getName()&#x27;</span><br></pre></td></tr></table></figure></li><li><p>Ognl lambda 表达式</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 =:[] 定义lambda即函数</span><br><span class="line">-- 使用 #getBean() 调用</span><br><span class="line">ognl -c 49c2faae &#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean =:[@cn.hutool.extra.spring.SpringUtil@getBean(#this)],</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean(<span class="string">&quot;syncDataAuthController&quot;</span>).dataCodeList<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure></li><li><p>查找方法</p><p>  <strong><code>sm com.xx.class</code></strong></p></li><li><p>修改静态变量的值</p><p>  <strong><code>getstatic com.xyz.HelloWorld s &quot;#s=&#39;abc&#39;&quot;</code></strong></p></li><li><p>修改变量的值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 使用 tt 记录方法调用</span><br><span class="line">tt -t com.example.UserService getUserById</span><br><span class="line">-- 2. 查看记录</span><br><span class="line">tt -l</span><br><span class="line">-- 3. 修改捕获的对象 target 代表当前被调用方法的对象实例（即 &quot;this&quot; 对象）</span><br><span class="line">tt -i 1000 -w &#x27;target.name=&quot;newName&quot;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>过滤参数类型为class的方法</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 过滤要点就是通过全类名@class拿到class对象，再getName()获取名称</span><br><span class="line">watch com.wangji92.arthas.plugin.demo.controller.StaticTest invokeClass &#x27;&#123;returnObj,throwExp&#125;&#x27;  -n 5  -x 3  </span><br><span class="line">&#x27;params[0].getName().equals(@com.wangji92.arthas.plug.demo.controller.User@class.getName())&#x27; -v</span><br></pre></td></tr></table></figure></li><li><p>查找response404的堆栈</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack -E javax.servlet.http.HttpServletResponse sendError|setStatus params[0]==404</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-特殊命令"><a href="#5-特殊命令" class="headerlink" title="5. 特殊命令"></a>5. 特殊命令</h3><ul><li><p>Trace 命令多个类、多个方法、指定线程、指定耗时时间</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># trace -E 表示正则</span><br><span class="line">trace -E </span><br><span class="line"># 表示类是 NioEventLoop 或者 SingleThreadEventExecutor</span><br><span class="line">&#x27;io\.netty\.channel\.nio\.NioEventLoop|io\.netty\.util\.concurrent\.SingleThreadEventExecutor&#x27;  </span><br><span class="line"># 表示方法是 select processSelectedKeys runAllTasks</span><br><span class="line">&#x27;select|processSelectedKeys|runAllTasks&#x27; </span><br><span class="line"># @Thread arthas提供表示当前线程 #cost arthas提供，表示耗时</span><br><span class="line">&#x27;@Thread@currentThread().getName().contains(&quot;IO-HTTP-WORKER-IOPool&quot;)&amp;&amp;#cost&gt;500&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获取代理对象的原始对象</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -w &#x27;#isProxy=:[ @org.springframework.aop.support.AopUtils@isAopProxy(#this)?1: #this instanceof java.lang.reflect.Proxy ? 0 :-1],#isJdkDynamicProxy =:[@org.springframework.aop.support.AopUtils@isJdkDynamicProxy(#this) ? true :false ],#cglibTarget =:[#hField =#this.getClass().getDeclaredField(&quot;CGLIB$CALLBACK_0&quot;),#hField.setAccessible(true),#dynamicAdvisedInterceptor=#hField.get(#this),#fieldAdvised=#dynamicAdvisedInterceptor.getClass().getDeclaredField(&quot;advised&quot;),#fieldAdvised.setAccessible(true),1==1? #fieldAdvised.get(#dynamicAdvisedInterceptor).getTargetSource().getTarget():null],#jdkTarget=:[ #hField=#this.getClass().getSuperclass().getDeclaredField(&quot;h&quot;),#hField.setAccessible(true),#aopProxy=#hField.get(#this),#advisedField=#aopProxy.getClass().getDeclaredField(&quot;advised&quot;),#advisedField.setAccessible(true),1==1?#advisedField.get(#aopProxy).getTargetSource().getTarget():null],#nonProxyResultFunc = :[#proxyResul=#isProxy(#this),#proxyResul== -1 ?#this :#proxyResul== 0? @java.lang.reflect.Proxy@getInvocationHandler(#this):#isJdkDynamicProxy(#this)? #isJdkDynamicProxy(#this) : #cglibTarget(#this)],#nonProxyTarget=#nonProxyResultFunc(target),#nonProxyTarget&#x27;  -x 1 -i 1002</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Vmtool-使用"><a href="#6-Vmtool-使用" class="headerlink" title="6. Vmtool 使用"></a>6. Vmtool 使用</h3><blockquote><p><code>vmtool</code> 利用 Java 的 Instrumentation API 和 JVM TI（JVM Tool Interface）与 JVM 进行交互，可以绕过spring context 直接获取对象</p></blockquote><ul><li><p>常用子命令</p><ul><li><code>--action getInstances</code>：获取类的实例</li><li><code>--action forceGc</code>：强制执行垃圾回收</li><li><code>--action getClassLoader</code>：获取类加载器信息</li></ul></li><li><p>com.xxx.cache.CacheAspect 中的 boolean 变量 cacheEnabled 修改为false</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vmtool: Arthas 的一个命令，用于对 JVM 进行底层操作。</span><br><span class="line">-x 3: 设置执行次数限制为 3 次。</span><br><span class="line">--action getInstances: 指定操作为获取类的实例。</span><br><span class="line">--className com.xxx.cache.CacheAspect: 指定要操作的类名。</span><br><span class="line">--express: 后面跟着的是要执行的 OGNL 表达式</span><br><span class="line">ongl表达式:</span><br><span class="line">反射获取字段 #field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;)</span><br><span class="line">设置为true #field.setAccessible(true)</span><br><span class="line">修改字段 #field.set(instances[0],false)</span><br><span class="line"></span><br><span class="line">vmtool -x 3 --action getInstances --className com.xxx.cache.CacheAspect --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;),#field.setAccessible(true),#field.set(instances[0],false)&#x27; -c 3bd94634</span><br></pre></td></tr></table></figure></li><li><p>修改final变量</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool -x 4 --action getInstances --className com.wangji92.arthas.plugin.demo.controller.CommonController  --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;FINAL_VALUE&quot;),#modifiers=#field.getClass().getDeclaredField(&quot;modifiers&quot;),#modifiers.setAccessible(true),#modifiers.setInt(#field,#field.getModifiers() &amp; ~@java.lang.reflect.Modifier@FINAL),#field.setAccessible(true),#field.set(instances[0],&quot; 3333&quot;)&#x27; -c  18b4aac2</span><br></pre></td></tr></table></figure></li><li><p>执行某个方法</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmtool -x 1 --action getInstances </span><br><span class="line">--className com.xx.SyncDataAuthController </span><br><span class="line">--express &#x27;instances[0].getDataCodePage(@com.xx.UtilJson@convertValue(&quot;&#123;\&quot;pageIndex\&quot;:0,\&quot;pageSize\&quot;:0&#125;&quot;, @com.xx.BaseQuery@class))&#x27;</span><br><span class="line">-c 49c2faae</span><br></pre></td></tr></table></figure></li><li><p>获取spring context</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.springframework.context.ConfigurableApplicationContext --express &#x27;instances[0].getEnvironment().getProperty(&quot;server.port&quot;)&#x27;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot;&gt;Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/1424&quot;&gt;arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/537&quot;&gt;Arthas实践–jad&amp;#x2F;mc&amp;#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-获取当前HttpServletRequest&quot;&gt;&lt;a href=&quot;#1-获取当前HttpServletRequest&quot; class=&quot;headerlink&quot; title=&quot;1. 获取当前HttpServletRequest&quot;&gt;&lt;/a&gt;1. 获取当前HttpServletRequest&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行某个request方法&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取全部的请求头&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Arthas" scheme="https://taeyang0126.github.io/categories/Arthas/"/>
    
    
    <category term="Arthas" scheme="https://taeyang0126.github.io/tags/Arthas/"/>
    
    <category term="问题排查" scheme="https://taeyang0126.github.io/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程异常处理</title>
    <link href="https://taeyang0126.github.io/2025/02/09/duo-xian-cheng-yi-chang-chu-li/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/duo-xian-cheng-yi-chang-chu-li/posts/undefined/</id>
    <published>2025-02-09T06:43:22.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 多线程场景下，如果没有显示的捕获异常并处理，那么异常会输出到 System.err 中，导致异常信息丢失</p></blockquote><h3 id="异常被吞噬的例子"><a href="#异常被吞噬的例子" class="headerlink" title="异常被吞噬的例子"></a>异常被吞噬的例子</h3><ul><li>新起线程中抛出异常</li></ul><blockquote><p>由于是新启动的线程，此异常并不会抛到父线程或者调用方上，导致异常被没了- - </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个异常!&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><ul><li>线程池中抛出的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>)</span><br><span class="line">        .execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;线程池中的异常!&quot;</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p>针对上面出现的异常吞噬的例子，有以下解决方案</p></blockquote><ul><li><p>Try catch 显示处理异常</p></li><li><p>指定<code> Thread.UncaughtExceptionHandler</code></p><ul><li><p>线程处理</p></li><li><p>thread.setUncaughtExceptionHandler</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">uncaughtExceptionHandler</span> <span class="operator">=</span> (t, e) -&gt; log.error(<span class="string">&quot;[catch error]thread -&gt; &#123;&#125;, e -&gt; &#123;&#125;&quot;</span>, t, e);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]这是一个异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>线程池处理</p></li><li><p>new ThreadFactoryBuilder().setUncaughtExceptionHandler  线程工厂中设置</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">uncaughtExceptionHandler</span> <span class="operator">=</span> (t, e) -&gt; log.error(<span class="string">&quot;[catch error]thread -&gt; &#123;&#125;, e -&gt; &#123;&#125;&quot;</span>, t, e);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]这是一个异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS</span><br><span class="line">        , <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>)</span><br><span class="line">        , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setUncaughtExceptionHandler(uncaughtExceptionHandler).build());</span><br><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;[catch]线程池中的异常!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>Hold on…..有人的地方就不存在信任这一说- -</p><h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><blockquote><p>上面的解决方案是没问题的，但是但是但是，某些开发者可能没有这个意识或者忘记了，导致异常还是被吞噬了</p></blockquote><p>既然未捕获的异常最终会输出到 <code>System.err</code> 那么重新设置系统的 err 处理，把信息输出到日志系统中。下面这个是兜底方案，会存在部分的不合理，但是为了不丢异常信息还是可以容忍的，日常开发中发现此类异常，需要定位到对应的业务代码，用上面提供的解决方案完善代码；毕竟这只是一个兜底的方案，而不是常规方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stderr</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logErr</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;[UnCatchError]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">STDERR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.err) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">            logErr.error(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">            logErr.error(<span class="string">&quot;&quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            logErr.error(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.setErr(STDERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 多线程场景下，如果没有显示的捕获异常并处理，那么异常会输出到 System.err 中，导致异常信息丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异常被吞噬的例子&quot;&gt;&lt;a href=&quot;#异常被吞噬的例子&quot; class=&quot;headerlink&quot; title=&quot;异常被吞噬的例子&quot;&gt;&lt;/a&gt;异常被吞噬的例子&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新起线程中抛出异常&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="多线程" scheme="https://taeyang0126.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JFR</title>
    <link href="https://taeyang0126.github.io/2025/02/09/jfr/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/jfr/posts/undefined/</id>
    <published>2025-02-09T06:13:52.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul><li><a href="https://www.zhihu.com/column/c_1264859821121355776">hashcon JFR 全解</a></li></ul><h3 id="JVM-启动"><a href="#JVM-启动" class="headerlink" title="JVM 启动"></a>JVM 启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java - XX:StartFlightRecording=delay=6s,disk=<span class="literal">true</span>,dumponexit=<span class="literal">true</span>,filename=/Users/wulei/tmp/recording.jfr,maxsize=1024m,maxage=<span class="number">1d</span>,settings=/Users/wulei/IdeaProjects/personal/op-lei4play/op-samples/jfr/lei-<span class="keyword">default</span>.jfc,path-to-gc-roots=<span class="literal">true</span> -XX:FlightRecorderOptions=repository=/Users/wulei/tmp,stackdepth=<span class="number">64</span> test.Main</span><br></pre></td></tr></table></figure><p><code>-XX:StartFlightRecording</code>有这个参数就会启用 JFR 记录，以下是相关的参数</p><table><thead><tr><th align="center">配置 key</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">delay</td><td align="left">0</td><td align="left">延迟多久后启动 JFR 记录，支持带单位配置， 例如 delay&#x3D;60s（秒）， delay&#x3D;20m（分钟）， delay&#x3D;1h（小时）， delay&#x3D;1d（天），不带单位就是秒， 0 就是没有延迟直接开始记录。一般为了避免框架初始化等影响，我们会延迟 1 分钟开始记录（例如 Spring cloud 应用，可以看下日志中应用启动耗时，来决定下这个时间</td></tr><tr><td align="center">disk</td><td align="left">true</td><td align="left">是否写入磁盘，global buffer 满了之后，是直接丢弃还是写入磁盘文件</td></tr><tr><td align="center">dumponexit</td><td align="left">false</td><td align="left">程序退出时，是否要 dump 出 。jfr 文件</td></tr><tr><td align="center">duration</td><td align="left">0</td><td align="left">JFR 记录持续时间，同样支持单位配置，不带单位就是秒，0 代表不限制持续时间，一直记录</td></tr><tr><td align="center">filename</td><td align="left">启动目录&#x2F;hotspot-pid-26732-id-1-2020_03_12_10_07_22.jfr，pid 后面就是 pid， id 后面是第几个 JFR 记录，可以启动多个 JFR 记录。最后就是时间</td><td align="left">dump 的输出文件</td></tr><tr><td align="center">name</td><td align="left">无</td><td align="left">记录名称，由于可以启动多个 JFR 记录，这个名称用于区分，否则只能看到一个记录 id，不好区分</td></tr><tr><td align="center">maxage</td><td align="left">0</td><td align="left">这个参数只有在 disk 为 true 的情况下才有效。最大文件记录保存时间，就是 global buffer 满了需要刷入本地临时目录下保存，这些文件最多保留多久的。也可以通过单位配置，没有单位就是秒，默认是 0，就是不限制</td></tr><tr><td align="center">maxsize</td><td align="left">250MB</td><td align="left">这个参数只有在 disk 为 true 的情况下才有效。最大文件大小，支持单位配置， 不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。设置为 0 代表不限制大小**。虽然官网说默认就是 0，但是实际用的时候，不设置会有提示**： No limit specified， using maxsize&#x3D;250MB as default。 注意，这个配置不能小于后面将会提到的 maxchunksize 这个参数</td></tr><tr><td align="center">path-to-gc-roots</td><td align="left">false</td><td align="left">是否记录 GC 根节点到活动对象的路径，一般不打开这个，首先这个在我个人定位问题的时候，很难用到，只要你的编程习惯好。还有就是打开这个，性能损耗比较大，会导致 FullGC 一般是在怀疑有内存泄漏的时候热启动这种采集，并且通过产生对象堆栈无法定位的时候，动态打开即可。一般通过产生这个对象的堆栈就能定位，如果定位不到，怀疑有其他引用，例如 ThreadLocal 没有释放这样的，可以在 dump 的时候采集 gc roots</td></tr><tr><td align="center">settings</td><td align="left">default.jfc</td><td align="left">位于 <code>$JAVA_HOME/lib/jfr/default.jfc</code>采集 Event 的详细配置，采集的每个 Event 都有自己的详细配置。另一个 JDK 自带的配置是 profile.jfc，位于 <code>$JAVA_HOME/lib/jfr/profile.jfc</code>如果需要指定自己的配置，这里可以设置为全路径的配置文件，类似 <code>settings=/Users/wulei/tmp/lei-default.jfc</code></td></tr></tbody></table><p><strong><code>-XX:FlightRecorderOptions</code></strong> 相关的参数</p><table><thead><tr><th align="left">配置 key</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">allow_threadbuffers_to_disk</td><td align="left">false</td><td align="left">是否允许 在 thread buffer 线程阻塞的时候，直接将 thread buffer 的内容写入文件。默认不启用，一般没必要开启这个参数，只要你设置的参数让 global buffer 大小合理不至于刷盘很慢，就行了</td></tr><tr><td align="left">globalbuffersize</td><td align="left">如果不设置，根据设置的 memorysize 自动计算得出</td><td align="left">单个 global buffer 的大小，一般通过 memorysize 设置，不建议自己设置</td></tr><tr><td align="left">maxchunksize</td><td align="left">12M</td><td align="left">存入磁盘的每个临时文件的大小。默认为 12MB，不能小于 1M。可以用单位配置，不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。注意这个大小最好不要比 memorySize 小，更不能比 globalbuffersize 小，否则会导致性能下降</td></tr><tr><td align="left">memorysize</td><td align="left">10M</td><td align="left">FR 的 global buffer 占用的整体内存大小，一般通过设置这个参数，numglobalbuffers 还有 globalbuffersize 会被自动计算出。可以用单位配置，不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB</td></tr><tr><td align="left">numglobalbuffers</td><td align="left">如果不设置，根据设置的 memorysize 自动计算得出</td><td align="left">global buffer 的个数，一般通过 memorysize 设置，不建议自己设置</td></tr><tr><td align="left">old-object-queue-size</td><td align="left">256</td><td align="left">对于 Profiling 中的 Old Object Sample 事件，记录多少个 Old Object，这个配置并不是越大越好。记录是怎么记录的，会在后面的各种 Event 介绍里面详细介绍。我的建议是，一般应用 256 就够，时间跨度大的，例如 maxage 保存了一周以上的，可以翻倍</td></tr><tr><td align="left">repository</td><td align="left">等同于 -Djava.io.tmpdir 指定的目录</td><td align="left">JFR 保存到磁盘的临时记录的位置</td></tr><tr><td align="left">retransform</td><td align="left">true</td><td align="left">是否通过 JVMTI 转换 JFR 相关 Event 类，如果设置为 false，则只在 Event 类加载的时候添加相应的 Java Instrumentation，这个一般不用改，这点内存 metaspace 还是足够的</td></tr><tr><td align="left">samplethreads</td><td align="left">true</td><td align="left">这个是是否开启线程采集的状态位配置，只有这个配置为 true，并且在 Event 配置中开启线程相关的采集（这个后面会提到），才会采集这些事件</td></tr><tr><td align="left">stackdepth</td><td align="left">64</td><td align="left">采集事件堆栈深度，有些 Event 会采集堆栈，这个堆栈采集的深度，统一由这个配置指定。注意这个值不能设置过大，如果你采集的 Event 种类很多，堆栈深度大很影响性能。比如你用的是 default.jfc 配置的采集，堆栈深度 64 基本上就是不影响性能的极限了。你可以自定义采集某些事件，增加堆栈深度</td></tr><tr><td align="left">threadbuffersize</td><td align="left">8KB</td><td align="left">threadBuffer 大小，最好不要修改这个，如果增大，那么随着你的线程数增多，内存占用会增大。过小的话，刷入 global buffer 的次数就会变多。8KB 就是经验中最合适的</td></tr></tbody></table><h3 id="jcmd-命令启动"><a href="#jcmd-命令启动" class="headerlink" title="jcmd 命令启动"></a>jcmd 命令启动</h3><ul><li><strong><code>jcmd &lt;pid&gt; JFR.start</code></strong> 启动 JFR 记录，参数和<code>-XX:StartFlightRecording</code>一模一样，请参考上面的表格。但是注意这里不再是逗号分割，而是空格示例，代表启动一个名称为 profile_online， 最多保留一天，最大保留 1G 的本地文件记录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 21 JFR.start name=profile_online maxage=1d maxsize=1g</span><br></pre></td></tr></table></figure><ul><li><strong><code>jcmd &lt;pid&gt; JFR.stop</code></strong> 停止 JFR 记录，需要传入名称，例如如果要停止上面打开的，则执行：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 21 JFR.stop name=profile_online</span><br></pre></td></tr></table></figure><ul><li><strong><code>jcmd &lt;pid&gt; JFR.check</code></strong> 查看当前正在执行的 JFR 记录</li><li><strong><code>jcmd &lt;pid&gt; JFR.configure</code></strong> 如果不传入参数，则是查看当前配置，传入参数就是修改配置。配置与-XX:FlightRecorderOptions 的一模一样。请参考上面的表格 示例</li><li><strong><code>jcmd &lt;pid&gt; JFR.dump</code></strong> 生成 jfr 文件</li></ul><table><thead><tr><th align="left">参数</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">无</td><td align="left">指定要查看的 JFR 记录名称</td></tr><tr><td align="left">filename</td><td align="left">无</td><td align="left">指定文件输出位置</td></tr><tr><td align="left">maxage</td><td align="left">0</td><td align="left">dump 最多的时间范围的文件，可以通过单位配置，没有单位就是秒，默认是 0，就是不限制</td></tr><tr><td align="left">maxsize</td><td align="left">0</td><td align="left">dump 最大文件大小，支持单位配置， 不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。设置为 0 代表不限制大小</td></tr><tr><td align="left">begin</td><td align="left">无</td><td align="left">dump 开始位置， 可以这么配置：09:00， 21:35:00， 2018-06-03T18:12:56.827Z， 2018-06-03T20:13:46.832， -10m， -3h， or -1d</td></tr><tr><td align="left">end</td><td align="left">无</td><td align="left">dump 结束位置，可以这么配置： 09:00， 21:35:00， 2018-06-03T18:12:56.827Z， 2018-06-03T20:13:46.832， -10m， -3h， or -1d （STRING， no default value）</td></tr><tr><td align="left">path-to-gc-roots</td><td align="left">false</td><td align="left">是否记录 GC 根节点到活动对象的路径，一般不记录，dump 的时候打开这个肯定会触发一次 fullGC，对线上应用有影响。最好参考之前对于 JFR 启动记录参数的这个参数的描述，考虑是否有必要</td></tr></tbody></table><h3 id="jfr-配置文件"><a href="#jfr-配置文件" class="headerlink" title="jfr 配置文件"></a>jfr 配置文件</h3><ul><li>openJdk 11.0.22</li></ul><p> <a href="/files/default.jfc">default.jfc</a> </p><p> <a href="/files/profile.jfc">profile.jfc</a> </p><ul><li>优化后的配置文件，基于 openJdk 11.2.22 default.jfr，根据👇🏻JFR Event 中的建议对于某些事件进行了关闭或者调整</li></ul><p> <a href="/files/lei-default.jfc">lei-default.jfc</a> </p><h3 id="JFR-Event"><a href="#JFR-Event" class="headerlink" title="JFR Event"></a>JFR Event</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/124242959">EVENT-1</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/126709861">EVENT-2</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/158592899">EVENT-3</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/158592899">JIT相关jfr事件</a></p></li></ul><p><img src="https://rq3nt70g815.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ5ZTQ4M2E5NTExOTI1MmQ2N2QyYjM2MTEyZjcxZDFfMk5FVW5iMXFUWXdjS1J5c2xXU21YOWJJZnBqT290QTZfVG9rZW46RldvTmIwOG1lbzBHRFd4U3pqcmNUYWdabmJiXzE3MzkwODE2OTc6MTczOTA4NTI5N19WNA" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/column/c_1264859821121355776&quot;&gt;hashcon JFR 全解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;JVM-启动&quot;&gt;&lt;a href=&quot;#JVM-启动&quot; class=&quot;headerlink&quot; title=&quot;JVM 启动&quot;&gt;&lt;/a&gt;JVM 启动&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM重要参数</title>
    <link href="https://taeyang0126.github.io/2025/02/09/jvm-chong-yao-can-shu/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/jvm-chong-yao-can-shu/posts/undefined/</id>
    <published>2025-02-09T06:08:56.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规启动配置参数"><a href="#常规启动配置参数" class="headerlink" title="常规启动配置参数"></a>常规启动配置参数</h2><table><thead><tr><th align="left">参数</th><th align="left">说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">-XX:+PrintFlagsFinal</td><td align="left">启动时打印出所有JVM参数</td><td align="left"></td></tr><tr><td align="left">-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;heap.hprof-XX:+ExitOnOutOfMemoryError</td><td align="left">开启OOM时堆转储指定dump文件位置发生 OOM 时强制 JVM 立即退出</td><td align="left">！！dump hprof文件时要求内存比较大，这块后续要再找更好的方案</td></tr><tr><td align="left">-Xlog:gc*:file&#x3D;gc.log::filecount&#x3D;5,filesize&#x3D;20M</td><td align="left">JDK 9+ 的新版 GC 日志参数-Xlog:  gc*                    # 记录所有gc相关日志  :file&#x3D;gc.log          # 输出到gc.log文件  :                           # 空的tag过滤器  :filecount&#x3D;5,         # 最多保留5个文件  filesize&#x3D;20M          # 每个文件最大20MB</td><td align="left">等价  jdk8           -verbose:gc        -Xloggc:&#x2F;path&#x2F;to&#x2F;gc.log        -XX:+PrintGCDetails        -XX:+PrintGCDateStamps        -XX:+PrintGCTimeStamps        -XX:+UseGCLogFileRotation        -XX:NumberOfGCLogFiles&#x3D;5        -XX:GCLogFileSize&#x3D;20M</td></tr><tr><td align="left">-XX:StartFlightRecording&#x3D;delay&#x3D;1s,disk&#x3D;true,dumponexit&#x3D;true,filename&#x3D;.&#x2F;logs&#x2F;recording.jfr,maxsize&#x3D;1024m,maxage&#x3D;1d,path-to-gc-roots&#x3D;true-XX:FlightRecorderOptions&#x3D;stackdepth&#x3D;128</td><td align="left">jfr启动参数，具体参考 <a href="https://rq3nt70g815.feishu.cn/wiki/CtdmwY0yPiUkgKkXidecur63nVc">JFR</a></td><td align="left"></td></tr><tr><td align="left">-Xlog:safepoint&#x3D;debug:file&#x3D;.&#x2F;logs&#x2F;safepoint.log:utctime,level,tags:filecount&#x3D;50,filesize&#x3D;100M</td><td align="left">safepoint</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常规启动配置参数&quot;&gt;&lt;a href=&quot;#常规启动配置参数&quot; class=&quot;headerlink&quot; title=&quot;常规启动配置参数&quot;&gt;&lt;/a&gt;常规启动配置参数&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="参数" scheme="https://taeyang0126.github.io/tags/%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存相关的监控指标</title>
    <link href="https://taeyang0126.github.io/2025/02/09/jvm-nei-cun-xiang-guan-de-jian-kong-zhi-biao/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/jvm-nei-cun-xiang-guan-de-jian-kong-zhi-biao/posts/undefined/</id>
    <published>2025-02-09T05:53:30.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-memory.PNG" alt="jvm内存图片"></p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><blockquote><p>JVM Heap代表存放Java Objects的Heap</p></blockquote><h3 id="Non-Heap"><a href="#Non-Heap" class="headerlink" title="Non-Heap"></a>Non-Heap</h3><h4 id="1-SpringBoot的JVM-metrics埋点代码"><a href="#1-SpringBoot的JVM-metrics埋点代码" class="headerlink" title="1. SpringBoot的JVM metrics埋点代码"></a>1. SpringBoot的JVM metrics埋点代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过io.micrometer.core引入了JVMMemoryuMetrics这个埋点实现</span></span><br><span class="line"><span class="keyword">for</span> (MemoryPoolMXBean memoryPoolBean : ManagementFactory.getPlatformMXBeans(MemoryPoolMXBean.class)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> MemoryType.HEAP.equals(memoryPoolBean.getType()) ? <span class="string">&quot;heap&quot;</span> : <span class="string">&quot;nonheap&quot;</span>;</span><br><span class="line">    Iterable&lt;Tag&gt; tagsWithId = Tags.concat(tags, <span class="string">&quot;id&quot;</span>, memoryPoolBean.getName(), <span class="string">&quot;area&quot;</span>, area);</span><br><span class="line"></span><br><span class="line">    Gauge.builder(<span class="string">&quot;jvm.memory.used&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getUsed))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The amount of used memory&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line"></span><br><span class="line">    Gauge</span><br><span class="line">        .builder(<span class="string">&quot;jvm.memory.committed&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getCommitted))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The amount of memory in bytes that is committed for the Java virtual machine to use&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line"></span><br><span class="line">    Gauge.builder(<span class="string">&quot;jvm.memory.max&quot;</span>, memoryPoolBean, (mem) -&gt; getUsageValue(mem, MemoryUsage::getMax))</span><br><span class="line">        .tags(tagsWithId)</span><br><span class="line">        .description(<span class="string">&quot;The maximum amount of memory in bytes that can be used for memory management&quot;</span>)</span><br><span class="line">        .baseUnit(BaseUnits.BYTES)</span><br><span class="line">        .register(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MemoryPoolMXBean接口的实现类是sun.management.MemoryPoolImpl，该类通过native method得到JVM提供的内存使用信息</span></span><br><span class="line"><span class="comment">// Native VM support</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> MemoryUsage <span class="title function_">getUsage0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="2-JVM本身的代码"><a href="#2-JVM本身的代码" class="headerlink" title="2. JVM本身的代码"></a>2. JVM本身的代码</h4><blockquote><p>设置-XX:NativeMemoryTracking&#x3D;summary或者details，然后使用jcmd去查看</p></blockquote><ul><li>CodeCache</li><li>Metaspace</li><li>CompressedClassSpace</li><li>DirectBuffer</li><li>Thread Stacks</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-JVM里used内存很低，但是容器物理内存占用很高"><a href="#1-JVM里used内存很低，但是容器物理内存占用很高" class="headerlink" title="1. JVM里used内存很低，但是容器物理内存占用很高"></a>1. JVM里used内存很低，但是容器物理内存占用很高</h4><p>因为k8s不允许使用交换分区，所以这里不用考虑外存和内存的交换关系。</p><p>JVM申请内存的时候，会预先使用<strong>pretouch</strong>的方式声明去告知OS，期望使用多少size的内存，由于物理内存的分配（内核本身的虚拟内存-物理内存管理）时惰性的，所以声明要使用多少size，不代表物理内存就立刻分配多少。</p><p>比如JavaHeap声明了1G的内存需要使用，但实际使用过程中，物理内存也是逐步被分配的，由于JavaHeap的内存被JVM的GC管理，当Heap满时，JVM的GC会内部释放内存空间，很明显，GC的过程不会让OS感知，不会去释放物理内存，假如FGC后，JavaHeap实际used的内存（常驻在JavaHeap）中只有200M，但此时容器物理内存很可能是1G多。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/jvm-memory.PNG&quot; alt=&quot;jvm内存图片&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Heap&quot;&gt;&lt;a href=&quot;#Heap&quot; class=&quot;headerlink&quot; title=&quot;Heap&quot;&gt;&lt;/a&gt;Heap&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JVM Heap代表存放Java Objects的Heap&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway</title>
    <link href="https://taeyang0126.github.io/2025/02/09/spring-cloud-gateway/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/09/spring-cloud-gateway/posts/undefined/</id>
    <published>2025-02-09T05:25:22.000Z</published>
    <updated>2025-02-09T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><ol><li>GATEWAY_ORIGINAL_REQUEST_URL_ATTR</li></ol><ul><li>记录原始的url请求</li><li>错误重试时可以用原始URI重试</li><li>可以记录完整的请求转换链路</li><li>故障分析时可以知道请求的来源</li><li>在路由重写时需要更新此属性</li></ul><ol start="2"><li>GATEWAY_REQUEST_URL_ATTR</li></ol><ul><li>存储请求将要转发的目标URL</li><li>后续的过滤器和路由可以通过这个属性知道请求要被转发到哪里</li><li>在路由重写时需要更新此属性</li></ul><ol start="3"><li>PRESERVE_HOST_HEADER_ATTRIBUTE</li></ol><ul><li>控制是否保留原始请求的 Host 头</li><li>true: 转发请求时会保留客户端的原始 Host header</li><li>false: 会使用目标服务的 Host</li><li>使用场景：假设自定义的过滤器修改了host属性，如果没有开启此配置，那么后续的处理可能影响此属性，这时候需要开启此配置</li></ul><h2 id="重要过滤器"><a href="#重要过滤器" class="headerlink" title="重要过滤器"></a>重要过滤器</h2><ol><li><p>RetryGatewayFilterFactory</p><blockquote><p>重试过滤器</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: Retry #重试策略:目前只对提供者下线导致的连接异常重试，需持续观察异常情况</span><br><span class="line">  args: </span><br><span class="line">    retries: <span class="number">1</span></span><br><span class="line">    series: #不对http状态来判断是否进行重试</span><br><span class="line">    exceptions: io.netty.channel.AbstractChannel$AnnotatedConnectException</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重要属性&quot;&gt;&lt;a href=&quot;#重要属性&quot; class=&quot;headerlink&quot; title=&quot;重要属性&quot;&gt;&lt;/a&gt;重要属性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;GATEWAY_ORIGINAL_REQUEST_URL_ATTR&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;记录原始的url请求&lt;/li&gt;
&lt;li&gt;错误重试时可以用原始URI重试&lt;/li&gt;
&lt;li&gt;可以记录完整的请求转换链路&lt;/li&gt;
&lt;li&gt;故障分析时可以知道请求的来源&lt;/li&gt;
&lt;li&gt;在路由重写时需要更新此属性&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="网关" scheme="https://taeyang0126.github.io/categories/%E7%BD%91%E5%85%B3/"/>
    
    
    <category term="网关" scheme="https://taeyang0126.github.io/tags/%E7%BD%91%E5%85%B3/"/>
    
    <category term="spring cloud gateway" scheme="https://taeyang0126.github.io/tags/spring-cloud-gateway/"/>
    
    <category term="spring cloud" scheme="https://taeyang0126.github.io/tags/spring-cloud/"/>
    
  </entry>
  
</feed>
