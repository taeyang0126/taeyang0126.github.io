<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WL&#39;s blog</title>
  
  
  <link href="https://taeyang0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://taeyang0126.github.io/"/>
  <updated>2025-03-15T02:43:22.000Z</updated>
  <id>https://taeyang0126.github.io/</id>
  
  <author>
    <name>WU LEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpClient基准测试</title>
    <link href="https://taeyang0126.github.io/2025/03/15/java/httpclient-ji-zhun-ce-shi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/15/java/httpclient-ji-zhun-ce-shi/posts/undefined/</id>
    <published>2025-03-15T02:43:22.000Z</published>
    <updated>2025-03-15T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/taeyang0126/JavaForge/tree/main/src/main/java/com/lei/java/forge/http">case</a></li></ul><h2 id="使用-WireMockServer-测试"><a href="#使用-WireMockServer-测试" class="headerlink" title="使用 WireMockServer 测试"></a>使用 WireMockServer 测试</h2><hr><h3 id="自定义-WireMockServer"><a href="#自定义-WireMockServer" class="headerlink" title="自定义 WireMockServer"></a>自定义 WireMockServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWireMockServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WireMockServer mockServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomWireMockServer</span><span class="params">(<span class="type">int</span> fixedDelayMs)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">containerThreads</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 增加容器线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">responseThreads</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 增加响应线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">WireMockConfiguration</span> <span class="variable">options</span> <span class="operator">=</span> WireMockConfiguration.options()</span><br><span class="line">                .port(<span class="number">8080</span>)</span><br><span class="line">                .containerThreads(containerThreads)      <span class="comment">// 增加容器线程数</span></span><br><span class="line">                .jettyAcceptors(<span class="number">4</span>)                       <span class="comment">// 增加接收器数量</span></span><br><span class="line">                .jettyAcceptQueueSize(<span class="number">100</span>)               <span class="comment">// 增加接受队列大小</span></span><br><span class="line">                .asynchronousResponseEnabled(<span class="literal">true</span>)       <span class="comment">// 启用异步响应</span></span><br><span class="line">                .asynchronousResponseThreads(responseThreads); <span class="comment">// 设置异步响应线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.mockServer = <span class="keyword">new</span> <span class="title class_">WireMockServer</span>(options);</span><br><span class="line">        <span class="built_in">this</span>.mockServer.start();</span><br><span class="line"></span><br><span class="line">        mockServer.stubFor(get(urlEqualTo(<span class="string">&quot;/test&quot;</span>))</span><br><span class="line">                .willReturn(aResponse()</span><br><span class="line">                        .withFixedDelay(fixedDelayMs)</span><br><span class="line">                        .withStatus(<span class="number">200</span>)</span><br><span class="line">                        .withBody(<span class="string">&quot;Hello&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.url = mockServer.baseUrl() + <span class="string">&quot;/test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockServer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th>http client</th><th>测试条件</th><th>测试结果</th><th>说明</th><th>推荐指数</th></tr></thead><tbody><tr><td>jdk11之后提供的 <code>HttpClient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>0.5s</code><br/> requestCount&#x3D;10000 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>nio</code><br/>2. 在请求数量一定的情况下，总的耗时最少<br/>3. 耗时最少的原因是对于每个http请求都会建立一个连接，造成连接极大的浪费<br/>4. 会出现大量time_wait连接</td><td>⭐️⭐️⭐️</td></tr><tr><td><code>httpasyncclient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>nio</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr><tr><td><code>OkHttp</code></td><td>单个请求耗时0.1s</td><td>maxConnection&#x3D;1 &#x3D;&gt; <code>106s</code><br/>maxConnection&#x3D;5(default) &#x3D;&gt; <code>21s</code><br/>maxConnection&#x3D;100 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>bio</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 每条连接对应一个线程，线程数增长过快</td><td>⭐️⭐</td></tr><tr><td><code>SpringWebflux</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.4s</code></td><td>1. 底层使用<code>reactor</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr><tr><td><code>VertxWebClient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.3s</code></td><td>1. 底层使用<code>netty</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/taeyang0126/JavaForge/tree/main/src/main/java/com/lei/java/forge/http&quot;&gt;case&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用-WireMockServer-测试&quot;&gt;&lt;a href=&quot;#使用-WireMockServer-测试&quot; class=&quot;headerlink&quot; title=&quot;使用 WireMockServer 测试&quot;&gt;&lt;/a&gt;使用 WireMockServer 测试&lt;/h2&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="http client" scheme="https://taeyang0126.github.io/tags/http-client/"/>
    
    <category term="基准测试" scheme="https://taeyang0126.github.io/tags/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JMH基准测试</title>
    <link href="https://taeyang0126.github.io/2025/03/08/java/jmh-ji-zhun-ce-shi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/08/java/jmh-ji-zhun-ce-shi/posts/undefined/</id>
    <published>2025-03-08T02:43:22.000Z</published>
    <updated>2025-03-08T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/taeyang0126/JVMForge">github代码</a></li></ul><h2 id="什么是基准测试？"><a href="#什么是基准测试？" class="headerlink" title="什么是基准测试？"></a>什么是基准测试？</h2><hr><p>基准测试是测量和评估软件性能的过程。</p><ul><li>比较不同算法的性能</li><li>分析代码优化的效果</li><li>识别性能瓶颈</li><li>验证性能假设</li></ul><h2 id="为什么需要专业的基准测试工具？"><a href="#为什么需要专业的基准测试工具？" class="headerlink" title="为什么需要专业的基准测试工具？"></a>为什么需要专业的基准测试工具？</h2><hr><p>考虑这个简单的性能测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">method();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;执行时间: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方法存在严重问题:</p><ul><li>无法处理 <code>JVM</code> 预热和 <code>JIT</code> 编译优化</li><li><code>单次</code>测量没有<code>统计意义</code></li><li>容易受到外部因素干扰</li><li>无法控制 GC 影响</li></ul><h2 id="JMH：基本设置"><a href="#JMH：基本设置" class="headerlink" title="JMH：基本设置"></a>JMH：基本设置</h2><hr><h3 id="添加-JMH-依赖"><a href="#添加-JMH-依赖" class="headerlink" title="添加 JMH 依赖"></a>添加 JMH 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="比较字符串连接的两种不同方式"><a href="#比较字符串连接的两种不同方式" class="headerlink" title="比较字符串连接的两种不同方式"></a>比较字符串连接的两种不同方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 3, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1)</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcatBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param(&#123;&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringConcatenation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(StringConcatBenchmark.class.getSimpleName())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Benchmark                                      (length)  Mode  Cnt   Score    Error  Units</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder              10  avgt    5   0.040 ±  0.001  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder             100  avgt    5   0.225 ±  0.005  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder            1000  avgt    5   3.433 ±  0.104  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation        10  avgt    5   0.085 ±  0.002  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation       100  avgt    5   1.128 ±  0.085  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation      1000  avgt    5  44.292 ±  6.484  us/op</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明:</p><ul><li>对于小字符串(长度10)，两种方法差异很小</li><li>对于中等字符串(长度100)，StringBuilder 约快9倍</li><li>对于长字符串(长度1000)，StringBuilder 约快14倍</li></ul><h2 id="JMH基本概念"><a href="#JMH基本概念" class="headerlink" title="JMH基本概念"></a>JMH基本概念</h2><hr><h3 id="如何理解-State"><a href="#如何理解-State" class="headerlink" title="如何理解 @State"></a>如何理解 <code>@State</code></h3><blockquote><p><code>@State</code> 是 JMH 中管理测试状态（即测试数据和变量）的机制。</p></blockquote><h4 id="为什么需要-State？"><a href="#为什么需要-State？" class="headerlink" title="为什么需要 @State？"></a>为什么需要 @State？</h4><ol><li>避免 <code>DCE</code> (Dead Code Elimination)：如果在测试方法内直接创建变量，JVM 可能会发现这些变量没有被”外部使用”而优化掉，导致测试结果不准确。</li><li><code>管理对象生命周期</code>: 控制对象何时创建、共享和销毁。</li><li><code>支持不同的共享级别</code>：通过 Scope 参数控制状态对象如何在线程间共享</li></ol><h4 id="State-的-Scope-选项："><a href="#State-的-Scope-选项：" class="headerlink" title="@State 的 Scope 选项："></a>@State 的 <code>Scope</code> 选项：</h4><ul><li>Scope.Thread：每个测试线程有一个独立的状态实例（默认且最常用）</li><li>Scope.Benchmark：所有线程共享同一个状态实例（用于测试并发）</li><li>Scope.Group：同一个线程组内的线程共享同一个状态实例</li></ul><h3 id="为什么需要-Fork"><a href="#为什么需要-Fork" class="headerlink" title="为什么需要 @Fork"></a>为什么需要 <code>@Fork</code></h3><blockquote><p>@Fork 指定了基准测试应该在多少个独立的 JVM 进程中运行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fork(value = 3, warmups = 1)</span></span><br></pre></td></tr></table></figure><p>这表示：</p><ul><li>运行 3 个正式的测量进程</li><li>运行 1 个预热进程（不计入最终结果）</li></ul><h4 id="为什么-Fork-很重要？"><a href="#为什么-Fork-很重要？" class="headerlink" title="为什么 Fork 很重要？"></a>为什么 Fork 很重要？</h4><ol><li>隔离性：每个新的 JVM 实例都是干净的环境，没有之前测试的干扰，如 JIT 编译历史、类加载状态、内存状态等。</li><li>避免偏差：多个独立运行可以发现潜在的异常值或不稳定因素。</li><li>克服 JVM 适应性: JVM 会根据运行情况调整优化策略，Fork 可以避免这种”学习效应”影响测试。</li><li>模拟真实环境: 实际应用通常从冷启动开始，Fork 更接近这种情况。</li><li><code>设置JVM参数</code>: <code>@Fork(value = 3, jvmArgs = &#123;&quot;-Xms2G&quot;, &quot;-Xmx2G&quot;&#125;)</code></li></ol><h4 id="推荐设置："><a href="#推荐设置：" class="headerlink" title="推荐设置："></a>推荐设置：</h4><ul><li>开发阶段可以用 @Fork(1) 快速得到反馈</li><li>最终测试应该用 @Fork(3) 或更多以获得稳定结果</li></ul><h3 id="Setup-和-TearDown-注解来管理资源和初始化操作"><a href="#Setup-和-TearDown-注解来管理资源和初始化操作" class="headerlink" title="@Setup 和 @TearDown 注解来管理资源和初始化操作"></a>@Setup 和 @TearDown 注解来管理资源和初始化操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseBenchmarkState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement statement;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setup(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在整个测试开始前执行一次</span></span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:h2:mem:test&quot;</span>);</span><br><span class="line">        statement = connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setup(Level.Iteration)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupIteration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次迭代前执行</span></span><br><span class="line">        <span class="comment">// 例如重置计数器、准备新的测试数据等</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TearDown(Level.Iteration)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDownIteration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次迭代后执行</span></span><br><span class="line">        <span class="comment">// 例如清理临时数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TearDown(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在整个测试结束后执行一次</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level.Trial</code>：整个基准测试</li><li><code>Level.Iteration</code>：每次迭代（一组测量）</li><li><code>Level.Invocation</code>：每次方法调用（谨慎使用，会影响测量）</li></ul><h2 id="理解-JMH-的执行模型和优化陷阱"><a href="#理解-JMH-的执行模型和优化陷阱" class="headerlink" title="理解 JMH 的执行模型和优化陷阱"></a>理解 JMH 的执行模型和优化陷阱</h2><hr><h3 id="JMH-的线程模型"><a href="#JMH-的线程模型" class="headerlink" title="JMH 的线程模型"></a>JMH 的线程模型</h3><blockquote><p>JMH 的线程模型是理解 @State 的关键。</p></blockquote><h4 id="JMH-如何运行基准测试"><a href="#JMH-如何运行基准测试" class="headerlink" title="JMH 如何运行基准测试"></a>JMH 如何运行基准测试</h4><ol><li><strong>线程设置</strong>：JMH 默认启动多个线程来执行你的基准测试方法</li><li><strong>提高准确性</strong>：多线程运行能够更好地利用系统资源，获得更稳定的结果</li><li><strong>线程数量</strong>：默认情况下，JMH 会使用等同于 CPU 核心数的线程数</li></ol><h4 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h4><p>当运行一个简单基准测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JMH 可能会创建 4&#x2F;8&#x2F;16 个线程（取决于 <code>CPU</code> 核心数），<code>同时运行</code>这个测试方法。</p><h4 id="State-和线程的关系"><a href="#State-和线程的关系" class="headerlink" title="@State 和线程的关系"></a>@State 和线程的关系</h4><h5 id="Scope-Thread"><a href="#Scope-Thread" class="headerlink" title="Scope.Thread"></a>Scope.Thread</h5><ul><li>每个测试线程都会获得一个<code>独立的实例</code></li><li>线程之间不共享状态</li><li>适合测试<code>无共享</code>、<code>非并发</code>的代码</li><li>例如：字符串处理、算法计算等</li></ul><h5 id="Scope-Benchmark"><a href="#Scope-Benchmark" class="headerlink" title="Scope.Benchmark"></a>Scope.Benchmark</h5><ul><li>所有测试线程<code>共享同一个实例</code></li><li>适合测试并发性能</li><li>例如：线程安全集合、锁机制、原子操作等</li></ul><h3 id="JVM-优化陷阱"><a href="#JVM-优化陷阱" class="headerlink" title="JVM 优化陷阱"></a>JVM 优化陷阱</h3><blockquote><p>JVM 可能会发现变量没有被’外部使用’而优化掉，这涉及到 JVM 的一种优化技术称为 死代码消除 (Dead Code Elimination, DCE)。这个问题尤其在微基准测试中很关键。</p></blockquote><h4 id="死代码消除怎么发生"><a href="#死代码消除怎么发生" class="headerlink" title="死代码消除怎么发生"></a>死代码消除怎么发生</h4><p>假设有这样一个简单的基准测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sum变量在方法结束后没有被使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 JVM 来说，sum 变量的计算完全没有必要！因为：</p><ol><li>变量没有返回值</li><li>变量不会影响任何外部状态</li><li>变量只活在这个方法的栈空间里</li></ol><p>因此，优化后的代码可能变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 所有代码都被优化掉了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际测量的是一个”空方法”的性能，而不是计算过程的性能！</p><h4 id="如何解决-DCE-问题"><a href="#如何解决-DCE-问题" class="headerlink" title="如何解决 DCE 问题"></a>如何解决 DCE 问题</h4><ol><li>返回计算结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;  <span class="comment">// 返回结果防止优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 <code>Blackhole</code> 消费结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> sum += i;</span><br><span class="line"> &#125;</span><br><span class="line"> bh.consume(sum);  <span class="comment">// 告诉JVM这个值被使用了</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>通过 @State 对象存储结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyState</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(MyState state)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">state.result = sum;  <span class="comment">// 修改外部状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见基准测试陷阱"><a href="#常见基准测试陷阱" class="headerlink" title="常见基准测试陷阱"></a>常见基准测试陷阱</h3><h4 id="常量折叠-Constant-Folding"><a href="#常量折叠-Constant-Folding" class="headerlink" title="常量折叠 (Constant Folding)"></a>常量折叠 (Constant Folding)</h4><blockquote><p>编译器可能在编译时计算常量表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">badConstantFolding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 编译器可能直接返回 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使用 @State 变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">goodConstantFolding</span><span class="params">(MyState state)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.a + state.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环优化-Loop-Optimizations"><a href="#循环优化-Loop-Optimizations" class="headerlink" title="循环优化 (Loop Optimizations)"></a>循环优化 (Loop Optimizations)</h4><blockquote><p>JVM 可能优化循环，甚至完全消除它们</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">badLoopBenchmark</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果没有使用，循环可能被优化掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使用 Blackhole 或返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodLoopBenchmark</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    bh.consume(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法内联-Method-Inlining"><a href="#方法内联-Method-Inlining" class="headerlink" title="方法内联 (Method Inlining)"></a>方法内联 (Method Inlining)</h4><blockquote><p>JVM 可能内联小方法，改变测量结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureMethodCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addNumbers(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使测试目标足够复杂，或禁用特定优化</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/taeyang0126/JVMForge&quot;&gt;github代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是基准测试？&quot;&gt;&lt;a href=&quot;#什么是基准测试？&quot; class=&quot;headerlink&quot; title=&quot;什么是基准测试？&quot;&gt;&lt;/a&gt;什么是基准测试？&lt;/h2&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="基准测试" scheme="https://taeyang0126.github.io/tags/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
    <category term="JMH" scheme="https://taeyang0126.github.io/tags/JMH/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Statistics/Thread Allocation Statistics</title>
    <link href="https://taeyang0126.github.io/2025/03/04/jfr/9.jvm-yu-jfr-shi-jian-thread-allocation-statistics/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/04/jfr/9.jvm-yu-jfr-shi-jian-thread-allocation-statistics/posts/undefined/</id>
    <published>2025-03-04T14:01:52.000Z</published>
    <updated>2025-03-04T14:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ThreadAllocationStatistics</code></li><li>Label(Event Type，用于显示): Thread Allocation Statistics</li><li>Category(用于分类显示): Java Application，Statistics</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>定时事件</code>: 代表定时采集，没有线程栈信息，因为执行线程都是 <code>JFR Periodic Tasks</code> 线程，采集这个线程栈没有意义</li><li><code>JVM内部事件</code></li></ul></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>everyChunk<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>everyChunk<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>period 为 everyChunk，beginChunk，endChunk 分别是什么意思？</li><li><code>Chunk</code> 可以简单理解为本地文件满了之后换一个新的文件，每个文件就是一个 <code>Chunk</code>。可以通过 <code>-XX:FlightRecorderOptions=maxchunksize=128m</code> 设置是 <code>12M</code></li><li><code>beginChunk</code>: 在每个 Chunk 开始的时候执行</li><li><code>endChunk</code>: 在每个 Chunk 满了的时候执行</li><li>下一个 Chunk 的 beginChunk 与上一个 Chunk 的 endChunk 时间基本相同</li><li><code>everyChunk</code> 代表 beginChunk + endChunk（都会执行）</li><li><code>everyChunk</code> 利于单独拿出来 tmp 目录的一个 jfr 文件的时候，有开始和结束的值</li></ul><h3 id="采集原理"><a href="#采集原理" class="headerlink" title="采集原理"></a>采集原理</h3><ul><li>在每个 Chunk 开始和结束的时候，生成 <code>jdk.ThreadAllocationStatistics</code> 事件</li><li>即采集每个线程内部的分配对象大小统计数据 <code>_allocated_bytes</code> (这是每个线程私有的)</li></ul><h3 id="统计数据的更新时机"><a href="#统计数据的更新时机" class="headerlink" title="统计数据的更新时机"></a>统计数据的更新时机</h3><ul><li>如果启动了 <code>TLAB</code>（默认就是启用的）:<ul><li>在 TLAB 满了（其实是不足以分配对象，剩余空间小于最大浪费限制的时候），或者 GC 的时候 TLAB 回退堆的时候</li><li>将 TLAB 中占用的空间大小，加到 <code>_allocated_bytes</code></li><li>每次读取的时候，读取 <code>_allocated_bytes</code> 加上当前 TLAB 已使用空间大小</li></ul></li><li>如果没有启动 TLAB(应该不会有应用这么干)，每次分配的时候会将对象大小加到这个字段</li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li><code>Thread</code>: 统计的线程名称（这个无法统计虚拟线程的，只能统计平台线程）</li><li><code>allocated</code>: 这个线程当前累计分配了多大的对象（这个字段类似于 OpenTelemetry 中的 Gauge 类型字段，瞬时值）</li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadAllocationStatistics</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ThreadAllocationStatistics 事件，每秒采集一次</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>).with(<span class="string">&quot;period&quot;</span>, <span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚拟线程/平台线程</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">ofVirtual</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;test-virtual-&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        Thread.Builder.<span class="type">OfPlatform</span> <span class="variable">ofPlatform</span> <span class="operator">=</span> Thread.ofPlatform().name(<span class="string">&quot;test-platform-&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各启动5个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 分配一个随机大小的数组</span></span><br><span class="line">                    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[ThreadLocalRandom.current().nextInt(<span class="number">8</span>, <span class="number">1024</span> * <span class="number">1024</span>)];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ofVirtual.start(runnable);</span><br><span class="line">            ofPlatform.start(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束程序</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据线程进行分组 -&gt; 按照 Allocated 倒序<br><img data-src="/images/jfr/31.png" alt="img"></li><li>查看图表，在柱状图显示 allocated 总计，因为之前按照 Thread 分组，这里可以看到某个 thread 的 allocated 变化<br><img data-src="/images/jfr/32.png" alt="img"><br><img data-src="/images/jfr/33.png" alt="img"></li></ul><h3 id="其他方式查看-allocated"><a href="#其他方式查看-allocated" class="headerlink" title="其他方式查看 allocated"></a>其他方式查看 allocated</h3><ul><li>jstack -e <pid></li><li>jcmd <pid> Thread.print -e</li><li>以上两个效果一样，-e 代表输出线程额外信息，额外信息中包含 allocated&#x3D;…</li><li>代码中查看<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有活跃线程总共分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getTotalThreadAllocatedBytes();</span><br><span class="line"><span class="comment">// 获取当前调用线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getCurrentThreadAllocatedBytes();</span><br><span class="line"><span class="comment">// 获取线程ID为1的线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getThreadAllocatedBytes(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取线程ID为1、2、3的多个线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getThreadAllocatedBytes(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h3><ul><li>该事件默认开启，不需要进行调整</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ThreadAllocationStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Thread Allocation Statistics&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application，Statistics&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;定时事件&lt;/code&gt;: 代表定时采集，没有线程栈信息，因为执行线程都是 &lt;code&gt;JFR Periodic Tasks&lt;/code&gt; 线程，采集这个线程栈没有意义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="线程分配" scheme="https://taeyang0126.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 3.Java堆内存相关设计</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-java-dui-nei-cun-xiang-guan-she-ji/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-java-dui-nei-cun-xiang-guan-she-ji/posts/undefined/</id>
    <published>2025-03-01T09:46:30.000Z</published>
    <updated>2025-03-01T09:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析</p></blockquote><ul><li><a href="https://juejin.cn/post/7225874698906615864">Java 堆内存大小的确认</a></li><li><a href="https://juejin.cn/post/7225874698906714168">压缩对象指针相关机制</a></li><li><a href="https://juejin.cn/post/7225879698952470588">其他 Java 堆内存相关的特殊机制</a></li></ul><h3 id="通用初始化与扩展流程"><a href="#通用初始化与扩展流程" class="headerlink" title="通用初始化与扩展流程"></a>通用初始化与扩展流程</h3><hr><p>目前最新的 JVM，主要根据三个指标初始化堆以及扩展或缩小堆：</p><ul><li>最大堆大小</li><li>最小堆大小</li><li>初始堆大小</li></ul><p>不同的 GC 情况下，初始化以及扩展的流程可能在某些细节不太一样，但是，大体的思路都是：</p><ol><li>初始化阶段，<code>reserve</code> <code>最大堆</code>大小，并且 <code>commit</code> <code>初始堆</code>大小</li><li>在某些 GC 的某些阶段，根据上次 GC 的数据，动态扩展或者缩小堆大小，扩展就是 commit 更多，缩小就是 uncommit 一部分内存。但是，堆大小不会小于<code>最小堆大小</code>，也不会大于<code>最大堆大小</code></li></ol><h3 id="直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式"><a href="#直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式" class="headerlink" title="直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式"></a>直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式</h3><hr><p>这三个指标，直接对应的 JVM 参数是：</p><ul><li><strong>最大堆大小</strong>：<code>MaxHeapSize</code>，如果没有指定的话会有默认<strong>预设值</strong>用于指导 JVM 计算这些指标的大小，<code>预设值为 125MB 左右</code>（96M*13&#x2F;10）</li><li><strong>最小堆大小</strong>：<code>MinHeapSize</code>，默认为 0，0 代表让 JVM 自己计算</li><li><strong>初始堆大小</strong>：<code>InitialHeapSize</code>，默认为 0，0 代表让 JVM 自己计算</li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ScaleForWordSize(x) align_down((x) * 13 / 10, HeapWordSize)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, MaxHeapSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">96</span>*M),                \</span><br><span class="line">  <span class="string">&quot;Maximum heap size (in bytes)&quot;</span>)                                   \</span><br><span class="line">  <span class="built_in">constraint</span>(MaxHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, MinHeapSize, <span class="number">0</span>,                                     \</span><br><span class="line">  <span class="string">&quot;Minimum heap size (in bytes); zero means use ergonomics&quot;</span>)        \</span><br><span class="line">  <span class="built_in">constraint</span>(MinHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, InitialHeapSize, <span class="number">0</span>,                                 \</span><br><span class="line">  <span class="string">&quot;Initial heap size (in bytes); zero means use ergonomics&quot;</span>)        \</span><br><span class="line">  <span class="built_in">constraint</span>(InitialHeapSizeConstraintFunc,AfterErgo)               \</span><br></pre></td></tr></table></figure><p>我们可以通过类似于 <code>-XX:MaxHeapSize=1G</code> 这种启动参数对这三个指标进行设置，但是，我们经常看到的可能是 <code>Xmx</code> 以及 <code>Xms</code> 这两个参数设置这三个指标，这两个参数分别对应：</p><ul><li><code>Xmx</code>：对应 <strong>最大堆大小</strong> 等价于 <code>MaxHeapSize</code></li><li><code>Xms</code>: 相当于同时设置<strong>最小堆大小</strong> <code>MinHeapSize</code> 和<strong>初始堆大小</strong> <code>InitialHeapSize</code></li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/runtime/arguments.cpp">对应JVM源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果设置了 Xms</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-Xms&quot;</span>, &amp;tail)) &#123;</span><br><span class="line">  julong size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//解析 Xms 大小</span></span><br><span class="line">  ArgsRange errcode = <span class="built_in">parse_memory_size</span>(tail, &amp;size, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (errcode != arg_in_range) &#123;</span><br><span class="line">    <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">                <span class="string">&quot;Invalid initial heap size: %s\n&quot;</span>, option-&gt;optionString);</span><br><span class="line">    <span class="built_in">describe_range_error</span>(errcode);</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 MinHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(MinHeapSize, (<span class="type">size_t</span>)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 InitialHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(InitialHeapSize, (<span class="type">size_t</span>)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果设置了 Xmx</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-Xmx&quot;</span>, &amp;tail) || <span class="built_in">match_option</span>(option, <span class="string">&quot;-XX:MaxHeapSize=&quot;</span>, &amp;tail)) &#123;</span><br><span class="line">  julong long_max_heap_size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//解析 Xmx 大小</span></span><br><span class="line">  ArgsRange errcode = <span class="built_in">parse_memory_size</span>(tail, &amp;long_max_heap_size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (errcode != arg_in_range) &#123;</span><br><span class="line">    <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">                <span class="string">&quot;Invalid maximum heap size: %s\n&quot;</span>, option-&gt;optionString);</span><br><span class="line">    <span class="built_in">describe_range_error</span>(errcode);</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 MaxHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(MaxHeapSize, (<span class="type">size_t</span>)long_max_heap_size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的"><a href="#不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的" class="headerlink" title="不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的"></a>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</h3><hr><p>JVM 会读取 <strong>JVM 可用内存</strong>：首先 JVM 需要知道自己可用多少内存，我们称为可用内存。由此引入第一个 JVM 参数，<code>MaxRAM</code>，这个参数是用来明确指定 JVM 进程可用内存大小的，如果没有指定，JVM 会自己读取系统可用内存。这个可用内存用来指导 JVM 限制最大堆内存。后面我们会看到很多 JVM 参数与这个可用内存相关。</p><p>前面我们还提到了，就算没有指定 <code>MaxHeapSize</code> 或者 <code>Xmx</code>，<code>MaxHeapSize</code> 也有自己预设的一个参考值。源码中这个预设参考值为 125MB 左右（<code>96M*13/10</code>）。但是一般最后不会以这个参考值为准，JVM 初始化的时候会有很复杂的计算计算出合适的值。比如你可以在你的电脑上执行下下面的命令，可以看到类似下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version|grep MaxHeapSize</span><br><span class="line">   size_t MaxHeapSize                              = 17179869184                               &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">   size_t SoftMaxHeapSize                          = 17179869184                            &#123;manageable&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version &quot;21.0.4&quot; 2024-07-16 LTS</span><br><span class="line">OpenJDK Runtime Environment Temurin-21.0.4+7 (build 21.0.4+7-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM Temurin-21.0.4+7 (build 21.0.4+7-LTS, mixed mode)</span><br></pre></td></tr></table></figure><p>可以看到 <code>MaxHeapSize</code> 的大小，以及它的值是通过 <code>ergonomic</code> 决定的。也就是非人工指定而是 JVM 自己算出来的。</p><p>上面提到的那个 125MB 左右的初始参考值，一般用于 JVM 计算。我们接下来就会分析这个计算流程，首先是最大堆内存 MaxHeapSize 的计算流程：<br><img data-src="/images/jvm/memory/09.png" alt="img"><br>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p><ul><li><code>MinRAMPercentage</code>：注意不要被名字迷惑，这个参数是在可用内存比较小的时候生效，即最大堆内存占用为可用内存的这个参数指定的百分比，默认为 50，即 50%</li><li><code>MaxRAMPercentage</code>：注意不要被名字迷惑，这个参数是在可用内存比较大的时候生效，即最大堆内存占用为可用内存的这个参数指定的百分比，默认为 25，即 25%</li><li><code>ErgoHeapSizeLimit</code>：通过自动计算，计算出的最大堆内存大小不超过这个参数指定的大小，默认为 0 即不限制</li><li><code>MinRAMFraction</code>: 已过期，如果配置了会转化为 <code>MinRAMPercentage</code> 换算关系是：<code>MinRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>MinRAMFraction</code>，默认是 2</li><li><code>MaxRAMFraction</code>: 已过期，如果配置了会转化为 <code>MaxRAMPercentage</code> 换算关系是：<code>MaxRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>MaxRAMFraction</code>，默认是 4</li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, MinRAMPercentage, <span class="number">50.0</span>,                             \</span><br><span class="line">  <span class="string">&quot;Minimum percentage of real memory used for maximum heap&quot;</span>         \</span><br><span class="line">  <span class="string">&quot;size on systems with small physical memory size&quot;</span>)                \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, MaxRAMPercentage, <span class="number">25.0</span>,                             \</span><br><span class="line">  <span class="string">&quot;Maximum percentage of real memory used for maximum heap size&quot;</span>)   \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, ErgoHeapSizeLimit, <span class="number">0</span>,                               \</span><br><span class="line">  <span class="string">&quot;Maximum ergonomically set heap size (in bytes); zero means use &quot;</span> \</span><br><span class="line">  <span class="string">&quot;MaxRAM * MaxRAMPercentage / 100&quot;</span>)                                \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(uintx, MinRAMFraction, <span class="number">2</span>,                                   \</span><br><span class="line">  <span class="string">&quot;Minimum fraction (1/n) of real memory used for maximum heap &quot;</span>    \</span><br><span class="line">  <span class="string">&quot;size on systems with small physical memory size. &quot;</span>               \</span><br><span class="line">  <span class="string">&quot;Deprecated, use MinRAMPercentage instead&quot;</span>)                       \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(uintx, MaxRAMFraction, <span class="number">4</span>,                                   \</span><br><span class="line">  <span class="string">&quot;Maximum fraction (1/n) of real memory used for maximum heap &quot;</span>    \</span><br><span class="line">  <span class="string">&quot;size. &quot;</span>                                                          \</span><br><span class="line">  <span class="string">&quot;Deprecated, use MaxRAMPercentage instead&quot;</span>)                       \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br></pre></td></tr></table></figure><p>然后如果我们也没有设置 <code>MinHeapSize</code> 以及 <code>InitialHeapSize</code>，也会经过下面的计算过程计算出来：</p><p><img data-src="/images/jvm/memory/10.png" alt="img"></p><p>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p><ul><li><code>NewSize</code>：初始新生代大小，预设值为 1.3MB 左右（1*13&#x2F;10）</li><li><code>OldSize</code>：老年代大小，预设值为 5.2 MB 左右（4*13&#x2F;10）</li><li><code>InitialRAMPercentage</code>：初始堆内存为可用内存的这个参数指定的百分比，默认为 1.5625，即 1.5625%</li><li><code>InitialRAMFraction</code>: 已过期，如果配置了会转化为 <code>InitialRAMPercentage</code> 换算关系是：<code>InitialRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>InitialRAMFraction</code></li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, NewSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">1</span>*M),                     \</span><br><span class="line">  <span class="string">&quot;Initial new generation size (in bytes)&quot;</span>)                         \</span><br><span class="line">  <span class="built_in">constraint</span>(NewSizeConstraintFunc,AfterErgo)                       \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, OldSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">4</span>*M),                     \</span><br><span class="line">  <span class="string">&quot;Initial tenured generation size (in bytes)&quot;</span>)                     \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, InitialRAMPercentage, <span class="number">1.5625</span>,                       \</span><br><span class="line">  <span class="string">&quot;Percentage of real memory used for initial heap size&quot;</span>)           \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(uintx, InitialRAMFraction, <span class="number">64</span>,                              \</span><br><span class="line">  <span class="string">&quot;Fraction (1/n) of real memory used for initial heap size. &quot;</span>      \</span><br><span class="line">  <span class="string">&quot;Deprecated, use InitialRAMPercentage instead&quot;</span>)                   \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br></pre></td></tr></table></figure><h3 id="压缩对象指针相关机制-UseCompressedOops"><a href="#压缩对象指针相关机制-UseCompressedOops" class="headerlink" title="压缩对象指针相关机制 - UseCompressedOops"></a>压缩对象指针相关机制 - UseCompressedOops</h3><hr><h4 id="压缩对象指针存在的意义"><a href="#压缩对象指针存在的意义" class="headerlink" title="压缩对象指针存在的意义"></a>压缩对象指针存在的意义</h4><p>现代机器大部分是 64 位的，JVM 也从 <code>9</code> 开始仅提供 64 位的虚拟机。在 JVM 中，一个对象指针，对应进程存储这个对象的虚拟内存的起始位置，也是 64 位大小：</p><p>我们知道，对于 32 位寻址，最大仅支持 4GB 内存的寻址，这在现在的 JVM 很可能不够用，可能仅仅堆大小就超过 4GB。所以目前对象指针一般是 <code>64</code> 位大小来支持大内存。但是，这相对 32 位指针寻址来说，<code>性能上却有衰减</code>。我们知道，<code>CPU 仅能处理寄存器里面的数据</code>，寄存器与内存之间，有很多层 CPU 缓存，虽然内存越来越便宜也越来越大，但是 <code>CPU 缓存并没有变大</code>，这就导致如果使用 64 位的指针寻址，相对于之前 32 位的，<code>CPU 缓存能容纳的指针个数小了一倍</code>。</p><p>Java 是面向对象的语言，JVM 中最多的操作，就是对对象的操作，比如 load 一个对象的字段，store 一个对象的字段，<code>这些都离不开访问对象指针</code>。所以 JVM 想尽可能的优化对象指针，这就引入了<code>压缩对象指针</code>，让对象指针在条件满足的情况下保持原来的 32 位。</p><p>对于 32 位的指针，假设<code>每一个 1 代表 1 字节</code>（就是每一位数指向一个字节），那么可以描述 0~2^32-1 这 2^32 字节也就是 <code>4 GB</code>（2^10&#x3D;1024&#x3D;1KB 2^20&#x3D;1024<em>1024&#x3D;1MB 2^30&#x3D;1024</em>1024*1024&#x3D;1GB） 的虚拟内存。<br><img data-src="/images/jvm/memory/11.png" alt="img"></p><p>如果我让<code>每一个 1 代表 8 字节</code>呢？也就是让<code>这块虚拟内存是 8 字节对齐</code>，也就是我在使用这块内存时候，<code>最小的分配单元就是 8 字节</code>。对于 Java 堆内存，也就是一个对象占用的空间，<code>必须是 8 字节的整数倍</code>，不足的话会填充到 8 字节的整数倍用于保证对齐。这样最多可以描述 2^32 * 8 字节也就是 32 GB 的虚拟内存。<br><img data-src="/images/jvm/memory/12.png" alt="img"></p><p>这就是<code>压缩指针</code>的原理，上面提到的相关 JVM 参数是：<code>ObjectAlignmentInBytes</code>，这个 JVM 参数表示 <code>Java 堆中的每个对象，需要按照几字节对齐</code>，也就是堆按照几字节对齐，值范围是 8 ~ 256，必须是 2 的 n 次方，因为 2 的 n 次方能简化很多运算，例如对于 2 的 n 次方取余数就可以简化成对于 2 的 n 次方减一取与运算，乘法和除法可以简化移位。</p><p>如果配置最大堆内存超过 32 GB（当 JVM 是 8 字节对齐），那么压缩指针会失效（其实不是超过 32GB，会略小于 32GB 的时候就会失效，还有其他的因素影响，下一节会讲到）。 但是，这个 32 GB 是和字节对齐大小相关的，也就是 <code>-XX:ObjectAlignmentInBytes=8</code> 配置的大小(默认为8字节，也就是 Java 默认是 8 字节对齐)。如果你配置 <code>-XX:ObjectAlignmentInBytes=16</code>，那么最大堆内存超过 64 GB 压缩指针才会失效，如果你配置 <code>-XX:ObjectAlignmentInBytes=32</code>，那么最大堆内存超过 128 GB 压缩指针才会失效.</p><h4 id="压缩对象指针与压缩类指针的关系演进"><a href="#压缩对象指针与压缩类指针的关系演进" class="headerlink" title="压缩对象指针与压缩类指针的关系演进"></a>压缩对象指针与压缩类指针的关系演进</h4><p>老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是从 <strong>Java 15 Build 23</strong> 开始， <code>UseCompressedClassPointers</code> 已经不再依赖 <code>UseCompressedOops</code> 了，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。参考 <a href="https://link.juejin.cn/?target=https://bugs.openjdk.java.net/browse/JDK-8241825">JDK ISSUE</a></p><h4 id="压缩对象指针的不同模式与寻址优化机制"><a href="#压缩对象指针的不同模式与寻址优化机制" class="headerlink" title="压缩对象指针的不同模式与寻址优化机制"></a>压缩对象指针的不同模式与寻址优化机制</h4><p>JVM 需要从虚拟内存的某一点开始申请内存，并且，需要预留出足够多的空间，给可能的一些系统调用机制使用，比如前面我们 native memory tracking 中看到的一些 malloc 内存，其实某些就在这个预留空间中分配的。<code>JVM会首先确保在操作系统提供的内存空间中分配足够的内存给Java堆</code>，在确保Java堆内存需求后，JVM才会考虑为元空间、代码缓存等分配内存。</p><p>JVM 在 <code>Reserve</code> 分配 Java 堆空间的时候，会一下子 Reserve <code>最大 Java 堆空间的大小</code>，然后在此基础上 Reserve 分配其他的存储空间。之后分配 Java 对象，在 Reserve 的 Java 堆内存空间内 <code>Commit</code> 然后<code>写入数据映射物理内存</code>分配 Java 对象。根据前面说的 Java 堆大小的伸缩策略，决定继续 Commit 占用更多物理内存还是 UnCommit 释放物理内存：<br><img data-src="/images/jvm/memory/13.png" alt="img"></p><p>Java 是一个面向对象的语言，JVM 中执行最多的就是访问这些对象，<code>在 JVM 的各种机制中，必须无时无刻考虑怎么优化访问这些对象的速度</code>，对于压缩对象指针，JVM 就考虑了很多优化。如果我们要使用压缩对象指针，那么需要将这个 64 位的地址，转换为 32 位的地址。然后在读取压缩对象指针所指向的对象信息的时候，需要将这个 32 位的地址，解析为 64 位的地址之后寻址读取。这个转换公式，如下所示：</p><ol><li><code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>压缩对象指针 = (64 位地址 - 基址) &gt;&gt; 对象对齐偏移</code></li></ol><p>基址其实就是对象地址的开始，注意，<code>这个基址不一定是 Java 堆的开始地址</code>，我们后面就会看到。对象对齐偏移与前面提到的 <code>ObjectAlignmentInBytes</code> 相关，例如 <code>ObjectAlignmentInBytes=8</code> 的情况下，对象对齐偏移就是 3 （因为 8 是 2 的 3 次方）。我们针对这个公式进行优化：</p><p>首先，我们考虑把<code>基址和对象对齐偏移</code>去掉，那么压缩对象指针可以直接作为对象地址使用。什么情况下可以这样呢？那么就是对象地址从 0 开始算，并且<code>最大堆内存 + Java 堆起始位置不大于 4GB</code>。因为这种情况下，Java 堆中对象的最大地址不会超过 4GB，那么压缩对象指针的范围可以直接表示所有 Java 堆中的对象。可以直接使用压缩对象指针作为对象实际内存地址使用。这里为啥是最大堆内存 + Java 堆起始位置不大于 4GB？因为前面的分析，我们知道进程可以申请的空间，是原生堆空间。所以，Java 堆起始位置，肯定不会从 <code>0x0000 0000 0000 0000</code> 开始。<br><img data-src="/images/jvm/memory/14.png" alt="img"></p><p>如果最大堆内存 + Java 堆起始位置大于 4GB，第一种优化就不能用了，<code>对象地址偏移就无法避免了</code>。但是如果可以保证<code>最大堆内存 + Java 堆起始位置小于 32位 * ObjectAlignmentInBytes</code>，默认 <code>ObjectAlignmentInBytes=8</code> 的情况即 32GB，我们还是可以让基址等于 0（因为最大对象内存大小也不会超过32GB，所以相当于对象可以从0开始），这样 <code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/15.png" alt="img"></p><p>但是，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果最大堆内存太大，接近 32GB，想要保证最大堆内存 + Java 堆起始位置小于 32GB，那么 Java 堆起始位置其实就快接近 0 了，这显然不行。所以在最大堆内存接近 32GB 的时候，上面第二种优化也就失效了。但是我们可以让 Java 堆从一个与 <code>32GB 地址完全不相交的地址</code>开始（因为如果地址在32GB之内，由于系统需要一些虚拟内存，所以堆占用的内存肯定就小于32GB了，如果从完全不想交的地址开始，那么整个32GB都能用作堆内存，这样就不需要使用基址相加，而是取或即可），这样加法就可以优化为取或运算，即<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/16.png" alt="img"></p><p>最后，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，那么就无法优化了，只能 <code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/17.png" alt="img"></p><p>总结下，上面我们说的那四种模式，对应 JVM 中的压缩对象指针的四种模式（以下叙述基于 <code>ObjectAlignmentInBytes=8</code> 的情况，即默认情况）：</p><ol><li><code>32-bit</code> 压缩指针模式：最大堆内存 + Java 堆起始位置不大于 4GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = 压缩对象指针</code></li><li><code>Zero based</code> 压缩指针模式：最大堆内存 + Java 堆起始位置不大于 32GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>Non-zero disjoint</code> 压缩指针模式：<code>最大堆内存不大于 32GB</code>，由于要保证 Java 堆起始位置不能太小，最大堆内存 + Java 堆起始位置大于 32GB，<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>Non-zero based</code> 压缩指针模式：用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是<code>最大堆内存没有超过 32GB</code>，<code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li></ol><h3 id="为何预留第-0-页，压缩对象指针-null-判断擦除的实现"><a href="#为何预留第-0-页，压缩对象指针-null-判断擦除的实现" class="headerlink" title="为何预留第 0 页，压缩对象指针 null 判断擦除的实现"></a>为何预留第 0 页，压缩对象指针 null 判断擦除的实现</h3><hr><p>前面我们知道，JVM 中的压缩对象指针有四种模式。对于地址非从 0 开始的那两种，即 <code>Non-zero disjoint</code> 和 <code>Non-zero based</code> 这两种，堆的实际地址并不是从 <code>HeapBaseMinAddress</code> 开始，而是有一页预留下来，被称为第 0 页，这一页不映射实际内存，如果访问这一页内部的地址，会有 Segment Fault 异常。那么为什么要预留这一页呢？主要是为了 null 判断优化，实现 null 判断擦除。</p><p>要预留第 0 页，不映射内存，实际就是为了让对于基址进行访问可以触发 <code>Segment Fault</code>，JVM 会捕捉这个信号，查看触发这个信号的内存地址是否属于第一页，如果属于那么 JVM 就知道了这个是对象为 null 导致的。不过从前面看，我们其实只是为了不映射基址对应的地址，那为啥要保留一整页呢？这个是处于内存对齐与寻址访问速度的考量，里面映射物理内存都是以页为单位操作的，所以内存需要按页对齐。</p><h3 id="结合压缩对象指针与前面提到的堆内存限制的初始化的关系"><a href="#结合压缩对象指针与前面提到的堆内存限制的初始化的关系" class="headerlink" title="结合压缩对象指针与前面提到的堆内存限制的初始化的关系"></a>结合压缩对象指针与前面提到的堆内存限制的初始化的关系</h3><hr><p>前面我们说明了不手动指定三个指标的情况下，这三个指标 (MinHeapSize,MaxHeapSize,InitialHeapSize) 是如何计算的，但是没有涉及压缩对象指针。如果压缩对象指针开启，那么堆内存限制的初始化之后，会根据参数确定压缩对象指针是否开启：</p><ol><li>首先，确定 Java 堆的起始位置：<ol><li>第一步，在不同操作系统不同 CPU 环境下，<code>HeapBaseMinAddress</code> 的默认值不同，大部分环境下是 <code>2GB</code></li><li>将 <code>DefaultHeapBaseMinAddress</code> 设置为 <code>HeapBaseMinAddress</code> 的默认值，即 <code>2GB</code></li><li>如果用户在启动参数中指定了 <code>HeapBaseMinAddress</code>，如果 <code>HeapBaseMinAddress</code> 小于 <code>DefaultHeapBaseMinAddress</code>，将 <code>HeapBaseMinAddress</code> 设置为 <code>DefaultHeapBaseMinAddress</code></li></ol></li><li>计算压缩对象指针堆的最大堆大小:<ol><li>读取对象对齐大小 <code>ObjectAlignmentInBytes</code> 参数的值，默认为 8</li><li>对 <code>ObjectAlignmentInBytes</code> 取 2 的对数，记为 <code>LogMinObjAlignmentInBytes</code></li><li>将 32 位左移 <code>LogMinObjAlignmentInBytes</code> 得到 <code>OopEncodingHeapMax</code> 即不考虑预留区的最大堆大小</li><li>如果需要预留区，即 <code>Non-Zero Based Disjoint</code> 以及 <code>Non-Zero Based</code> 这两种模式下，需要刨除掉预留区即第 0 页的大小，即 <code>OopEncodingHeapMax</code> - 第 0 页的大小</li></ol></li><li>读取当前 JVM 配置的最大堆大小</li><li>如果 JVM 配置的最大堆小于压缩对象指针堆的最大堆大小，并且没有通过 JVM 启动参数明确关闭压缩对象指针，则开启压缩对象指针。否则，关闭压缩对象指针</li><li>如果压缩对象指针关闭，根据前面分析过的是否压缩类指针强依赖压缩对象指针，如果是，关闭压缩类指针</li></ol><h3 id="各种压缩指针模式的开启"><a href="#各种压缩指针模式的开启" class="headerlink" title="各种压缩指针模式的开启"></a>各种压缩指针模式的开启</h3><hr><h4 id="32-bit-压缩指针模式"><a href="#32-bit-压缩指针模式" class="headerlink" title="32-bit 压缩指针模式"></a>32-bit 压缩指针模式</h4><blockquote><p>最大堆内存 + Java 堆起始位置不大于 4GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = 压缩对象指针</code></p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li><code>maxHeapSize</code> &lt; <code>4GB</code> - <code>HeapBaseMinAddress</code> </li><li>eg: -Xmx32M</li><li><code>Java 堆会从界限减去最大堆大小的位置开始 reserve</code>，也就是在 <code>-Xmx32M</code> 下，堆的起始位置是 <code>0x0000 0000 fe00 0000</code> （0x0000 0000 fe00 0000 + 32M &#x3D; 4GB）</li></ol><h4 id="Zero-based-压缩指针模式"><a href="#Zero-based-压缩指针模式" class="headerlink" title="Zero based 压缩指针模式"></a>Zero based 压缩指针模式</h4><blockquote><p>最大堆内存 + Java 堆起始位置不大于 32GB（并且 Java 堆起始位置不能太小），64 位地址 &#x3D; （压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li><code>maxHeapSize</code> &gt; <code>4GB</code> - <code>HeapBaseMinAddress</code> </li><li><code>maxHeapSize</code> &lt; <code>32GB</code> - <code>HeapBaseMinAddress</code> </li><li>eg: -Xmx2050M</li></ol><h4 id="Non-zero-disjoint-压缩指针模式"><a href="#Non-zero-disjoint-压缩指针模式" class="headerlink" title="Non-zero disjoint 压缩指针模式"></a>Non-zero disjoint 压缩指针模式</h4><blockquote><p>最大堆内存不大于 32GB，由于要保证 Java 堆起始位置不能太小，最大堆内存 + Java 堆起始位置大于 32GB，64 位地址 &#x3D; 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li>java 堆起始位置与32GB完全不相交的地址(0x0000001000000000(64GB))，32GB地址&#x3D;0x0000000800000000</li><li>-Xmx31G</li></ol><h4 id="Non-zero-based-压缩指针模式"><a href="#Non-zero-based-压缩指针模式" class="headerlink" title="Non-zero based 压缩指针模式"></a>Non-zero based 压缩指针模式</h4><blockquote><p>用户通过 HeapBaseMinAddress 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，64 位地址 &#x3D; 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li>自己指定了 Java 堆开始的地址，并且与 32GB 地址相交 <code>-XX:HeapBaseMinAddress=2G</code></li><li>最大堆内存 + Java 堆起始位置大于 32GB <code>-Xmx31G</code></li></ol><h3 id="各模式选择条件总结"><a href="#各模式选择条件总结" class="headerlink" title="各模式选择条件总结"></a>各模式选择条件总结</h3><hr><table><thead><tr><th>模式</th><th>堆基址条件</th><th>最大堆限制</th><th>选择逻辑</th></tr></thead><tbody><tr><td>32-bit</td><td>堆空间完全在4GB范围内</td><td>&lt; 4GB - HeapBaseMinAddress</td><td>适用于堆需求较小的应用</td></tr><tr><td>Zero-based</td><td>任意堆基址</td><td>HeapBaseMinAddress + Xmx &gt; 4GB 且 &lt; 32GB</td><td>当堆总大小超过4GB但小于32GB时使用</td></tr><tr><td>Non-zero based</td><td>~2GB</td><td>&lt;32GB</td><td>平衡系统内存布局需求的通用模式</td></tr><tr><td>Non-zero disjoint</td><td><code>&gt;=32GB</code> (如64GB)</td><td>&lt;32GB</td><td>适用于特定的内存布局需求</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225874698906615864&quot;&gt;Java 堆内存大小的确认&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225874698906714168&quot;&gt;压缩对象指针相关机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225879698952470588&quot;&gt;其他 Java 堆内存相关的特殊机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;通用初始化与扩展流程&quot;&gt;&lt;a href=&quot;#通用初始化与扩展流程&quot; class=&quot;headerlink&quot; title=&quot;通用初始化与扩展流程&quot;&gt;&lt;/a&gt;通用初始化与扩展流程&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="堆内存" scheme="https://taeyang0126.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 2.JVM 内存申请与使用流程</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/</id>
    <published>2025-03-01T07:46:30.000Z</published>
    <updated>2025-03-01T07:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</p></blockquote><ul><li><a href="https://juejin.cn/post/7225875600644407357">JVM 内存申请与使用流程</a></li></ul><h2 id="Linux-下内存管理模型简述"><a href="#Linux-下内存管理模型简述" class="headerlink" title="Linux 下内存管理模型简述"></a>Linux 下内存管理模型简述</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21&key=d9f8952995f1859ec52d8f5d9e6ab4720ffabd5403c103322ee7ec6f45279c0d6ff004df4d91e603b8da30fc862da32560064a1680e06e498f1478dedf8d24cd54abfe5bbf80610ac6a1ecfcadeceb1ce74fd27e061bc962a5e9d18c369786619a9ac7ad030b16a0f350638aed32ec61ad2c47b2df53b2fffac6419c8a55feb1&ascene=2&uin=MTQxMDM0OTkyNA==&devicetype=Windows+11+x64&version=6308011a&exportkey=n_ChQIAhIQLReSAiPPBq/rjeEsvhWLGhLpAQIE97dBBAEAAAAAAPboBnzhWE0AAAAOpnltbLcz9gKNyK89dVj0LB8MByB+LnarvTJ9k5LjHnaHSiRCVUH6zSSXMnbZ9AQCusp6IDK5hwtnugd9Du4BG2pqPuJHPIkVIcUMia320lXFN61yM/+2MKyl86soaJUlu0zu8x69eop1Fbdi4YBaoocZrDbr+Buq4hsy+Kf6ElIQw+6gPfQqllJ5R86pa0DoVOjdnD2bi7ZuxdMyvcOPEu3pDa5H/BgY1A+DcifqtVZlp+5LoJKYNhtlZg1zOS06RY15Ry0DdonN38efMsG2Req/&acctmode=0&pass_ticket=ywhUvrTZ0ZCaWLuvLdidNGnNwyS7T41V+KEL2N0td3RvwmPJ+ZREM3Zc0lit4wDxNhALtKqF2gPCKD6sLdagzA==&wx_header=1&fontgear=2">bin神系列文章深入理解linux内存</a></li></ul><p>CPU 是通过寻址来访问内存的，目前大部分 CPU 都是 64 位的，即寻址范围是：<code>0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF</code>，即可以管理 16EB 的内存。但是，实际程序并不会直接通过 CPU 寻址访问到实际的物理内存，而是通过引入 <code>MMU</code>（Memory Management Unit 内存管理单元）与实际物理地址隔了一层虚拟内存的抽象。这样，程序申请以及访问的其实是<code>虚拟内存地址</code>，MMU 会将这个虚拟内存地址<code>映射</code>为实际的物理内存地址。同时，<code>为了减少内存碎片，以及增加内存分配效率</code>，在 MMU 的基础上 Linux 抽象了<code>内存分页（Paging）</code>的概念，将虚拟地址按固定大小分割成<code>页</code>（默认是 4K，如果平台支持更多更大的页大小 JVM 也是可以利用的，我们后面分析相关的 JVM 参数会看到），并在页被实际使用写入数据的时候，<code>映射同样大小的实际的物理内存</code>（页帧，Page Frame），或者是在物理内存不足的时候，将某些不常用的页<code>转移到其他存储设备比如磁盘上</code>。</p><p>一般系统中会有多个进程使用内存，每个进程都有自己独立的虚拟内存空间，假设我们这里有三个进程，进程 A 访问的虚拟地址可以与进程 B 和进程 C 的虚拟地址相同，那么操作系统如何区分呢？即操作系统如何将这些虚拟地址转换为物理内存。这就需要页表了，页表也是每个进程独立的，操作系统会在给进程映射物理内存用来保存用户数据的时候，将物理内存保存到进程的页表里面。然后，进程访问虚拟内存空间的时候，通过页表找到物理内存：<br><img data-src="/images/jvm/memory/01.png" alt="img"></p><p>页表如何将一个虚拟内存地址（我们需要注意一点，目前虚拟内存地址，用户空间与内核空间可以使用从 <code>0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF</code> 的地址，即 256TB），转化为物理内存的呢？下面我们举一个在 x86，64 位环境下四级页表的结构视图：<br><img data-src="/images/jvm/memory/02.png" alt="img"></p><p>在这里，页表分为四个级别：PGD（Page Global Directory），PUD（Page Upper Directory），PMD（Page Middle Directory），PTE（Page Table Entry）。每个页表，里面的页表项，保存了指向下一个级别的页表的引用，除了最后一层的 PTE 里面的页表项保存的是指向用户数据内存的指针。如何将虚拟内存地址通过页表找到对应用户数据内存从而读取数据，过程是：<br><img data-src="/images/jvm/memory/03.png" alt="img"></p><ol><li>取虚拟地址的 <code>39 ~ 47</code> 位（因为用户空间与内核空间可以使用从 0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF 的地址，即 47 位以下的地址）作为 offset，在<code>唯一</code>的 PGD 页面根据 offset 定位到 PGD 页表项 <code>pgd_t</code></li><li>使用 <code>pgd_t</code> 定位到具体的 PUD 页面</li><li>取虚拟地址的 <code>30 ~ 38</code> 位作为 offset，在对应的 PUD 页面根据 offset 定位到 PUD 页表项 <code>pud_t</code></li><li>使用 <code>pud_t</code> 定位到具体的 PMD 页面</li><li>取虚拟地址的 <code>21 ~ 29</code> 位作为 offset，在对应的 PMD 页面根据 offset 定位到 PMD 页表项 <code>pmd_t</code></li><li>使用 <code>pmd_t</code> 定位到具体的 PTE 页面</li><li>取虚拟地址的 <code>12 ~ 20</code> 位作为 offset，在对应的 PTE 页面根据 offset 定位到 PTE 页表项 <code>pte_t</code></li><li>使用 <code>pte_t</code> 定位到具体的用户数据物理内存页面</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset</li></ol><p>如果每次访问虚拟内存，都需要访问这个页表翻译成实际物理内存的话，性能太差。所以一般 CPU 里面都有一个 <code>TLB</code>（Translation Lookaside Buffer，翻译后备缓冲）存在，一般它属于 CPU 的 MMU 的一部分。<code>TLB 负责缓存虚拟内存与实际物理内存的映射关系</code>，一般 TLB 容量很小。每次访问虚拟内存，先查看 TLB 中是否有缓存，如果没有才会去页表查询。<br><img data-src="/images/jvm/memory/04.png" alt="img"><br>默认情况下，TLB 缓存的 key 为地址的 <code>12 ~ 47</code> 位，value 是实际的物理内存页面。这样前面从<code>第 1 到第 7 步</code>就可以被替换成访问 TLB 了：</p><ol><li>取虚拟地址的 <code>12 ~ 47</code> 位作为 key，访问 TLB，定位到具体的用户数据物理内存页面。</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset。<br><img data-src="/images/jvm/memory/05.png" alt="img"></li></ol><p>TLB 整体可以容纳个数不多；页大小越大，TLB 能容纳的个数越少。但是整体看，TLB 能容纳的页大小还是增多的（比如 Nehalem 的 iTLB，页大小 4K 的时候，一共可以容纳 128 * 4 &#x3D; 512K 的内存，页大小 2M 的时候，一共可以容纳 2 * 7 &#x3D; 14M 的内存）</p><p>JVM 中很多地方需要知道页大小，JVM 在初始化的时候，通过系统调用 <code>sysconf(_SC_PAGESIZE)</code> 读取出页大小，并保存下来以供后续使用。参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp">https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置全局默认页大小，通过 Linux::page_size() 可以获取全局默认页大小</span></span><br><span class="line">Linux::<span class="built_in">set_page_size</span>(<span class="built_in">sysconf</span>(_SC_PAGESIZE));</span><br><span class="line"><span class="keyword">if</span> (Linux::<span class="built_in">page_size</span>() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;</span>,</span><br><span class="line">      os::<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将默认页大小加入可选的页大小列表，在涉及大页分配的时候有用</span></span><br><span class="line">_page_sizes.<span class="built_in">add</span>(Linux::<span class="built_in">page_size</span>());</span><br></pre></td></tr></table></figure><h2 id="JVM-主要内存申请分配流程"><a href="#JVM-主要内存申请分配流程" class="headerlink" title="JVM 主要内存申请分配流程"></a>JVM 主要内存申请分配流程</h2><h3 id="每个子系统-Reserve-内存"><a href="#每个子系统-Reserve-内存" class="headerlink" title="每个子系统 Reserve 内存"></a>每个子系统 <code>Reserve</code> 内存</h3><p><strong>第一步，JVM 的每个子系统</strong>（例如 Java 堆，元空间，JIT 代码缓存，GC 等等等等），<strong>如果需要的话，在初始化的时候首先 <code>Reserve</code> 要分配区域的最大限制大小的内存</strong>（这个最大大小，需要按照<code>页大小对齐</code>（即是页大小的整数倍），默认页大小是前面提到的 <code>Linux::page_size()</code>），例如对于 Java 堆，就是最大堆大小（通过 <code>-Xmx</code> 或者 <code>-XX:MaxHeapSize</code>限制），还有对于代码缓存，也是最大代码缓存大小（通过 <code>-XX:ReservedCodeCacheSize</code> 限制）。Reserve 的目的是在虚拟内存空间划出一块内存专门给某个区域使用，这样做的好处是：</p><ol><li>隔离每个 JVM 子系统使用的内存的<code>虚拟空间</code>，这样在 JVM 代码有 bug 的时候（例如发生 Segment Fault 异常），通过报错中的<code>虚拟内存地址</code>可以快速定位到是哪个子系统出了问题。</li><li>可以很方便的限制这个区域使用的最大内存大小。</li><li>便于管理，<code>Reserve 不会触发操作系统分配映射实际物理内存</code>，这个区域可以在 Reserve 的区域内按需伸缩。</li><li>便于一些 JIT 优化，例如我们故意将这个区域保留起来但是故意不将这个区域的虚拟内存映射物理内存，访问这块内存会造成 Segment Fault 异常。JVM 会预设 Segment Fault 异常的处理器，在处理器里面检查发生 Segment Fault 异常的内存地址属于哪个子系统的 Reserve 的区域，判断要做什么操作。后面我们会看到，null 检查抛出 <code>NullPointerException</code> 异常的优化，全局安全点，抛出 <code>StackOverflowError</code> 的实现，都和这个机制有关。</li></ol><p>在 Linux 的环境下，Reserve 通过  <code>mmap(2)</code> 系统调用实现，参数传入 <code>prot = PROT_NONE</code>，<code>PROT_NONE</code> 代表不会使用，即<code>不能做任何操作，包括读和写</code>。如果 JVM 使用这块内存，会发生 Segment Fault 异常。</p><h3 id="每个子系统按照各自策略向操作系统申请映射物理内存"><a href="#每个子系统按照各自策略向操作系统申请映射物理内存" class="headerlink" title="每个子系统按照各自策略向操作系统申请映射物理内存"></a>每个子系统按照各自策略向操作系统申请映射物理内存</h3><p><strong>第二步，JVM 的每个子系统，按照各自的策略，通过 <code>Commit</code> 第一步 Reserve 的区域的<code>一部分扩展内存</code>（大小也一般页大小对齐的），从而<code>向操作系统申请映射物理内存</code>，通过 <code>Uncommit</code> 已经 Commit 的内存来释放物理内存给操作系统</strong></p><p>Commit 内存之后，<code>并不是操作系统会立刻分配物理内存</code>，而是在向 <code>Commit 的内存里面写入数据的时候，操作系统才会实际映射内存</code>，JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数。</p><h3 id="JVM-commit-的内存与实际占用内存的差异"><a href="#JVM-commit-的内存与实际占用内存的差异" class="headerlink" title="JVM commit 的内存与实际占用内存的差异"></a>JVM commit 的内存与实际占用内存的差异</h3><p>前面一节我们知道了，JVM 中大块内存，基本都是先 <code>reserve</code> 一大块，之后 <code>commit</code> 其中需要的一小块，然后开始读写处理内存，在 Linux 环境下，底层基于 <code>mmap(2)</code> 实现。但是需要注意一点的是，commit 之后，内存并不是立刻被分配了物理内存，而是真正往内存中 <code>store</code> 东西的时候，才会真正映射物理内存，如果是 load 读取也是可能不映射物理内存的。</p><p>这其实是可能你平常看到但是忽略的现象，如果你使用的是 SerialGC，ParallelGC 或者 CMS GC，老年代的内存在有对象晋升到老年代之前，可能是不会映射物理内存的，虽然这块内存已经被 commit 了。并且年轻代可能也是随着使用才会映射物理内存。如果你用的是 ZGC，G1GC，或者 ShenandoahGC，那么内存用的会更激进些（主要因为分区算法划分导致内存被写入），<code>这是你在换 GC 之后看到物理内存内存快速上涨的原因之一</code>。JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数，这个参数我们后面会详细分析以及历史版本存在的缺陷。还有的差异，主要来源于在 uncommit 之后，系统可能还没有来的及将这块物理内存真正回收。</p><p>所以，JVM 认为自己 commit 的内存，与实际系统分配的物理内存，<code>可能是有差异的</code>，可能 JVM 认为自己 commit 的内存比系统分配的物理内存多，也可能少。这就是为啥 <code>Native Memory Tracking（JVM 认为自己 commit 的内存）与实际其他系统监控中体现的物理内存使用指标对不上的原因</code>。</p><h2 id="大页分配-UseLargePages"><a href="#大页分配-UseLargePages" class="headerlink" title="大页分配 UseLargePages"></a>大页分配 UseLargePages</h2><p>前面提到了虚拟内存需要映射物理内存才能使用，这个映射关系被保存在内存中的<code>页表（Page Table）</code>。现代 CPU 架构中一般有 <code>TLB</code> （Translation Lookaside Buffer，翻译后备缓冲，也称为页表寄存器缓冲）存在，在里面保存了经常使用的页表映射项。TLB 的大小有限，一般 TLB 如果只能容纳小于 100 个页表映射项。 我们能让程序的虚拟内存对应的页表映射项都处于 TLB 中，那么能大大提升程序性能，这就要尽量减少页表映射项的个数：<code>页表项个数 = 程序所需内存大小 / 页大小</code>。我们要么缩小程序所需内存，要么增大页大小。我们一般会考虑<code>增加页大小</code>，这就大页分配的由来，JVM 对于堆内存分配也支持大页分配，用于优化大堆内存的分配。那么 Linux 环境中有哪些大页分配的方式呢？</p><h3 id="Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs"><a href="#Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs" class="headerlink" title="Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)"></a>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">相关的 Linux 内核文档</a></p><p>这是出现的比较早的大页分配方式，其实就是在之前提到的页表映射上面做文章：</p><p><strong>默认 4K 页大小</strong>：<br><img data-src="/images/jvm/memory/03.png" alt="img"></p><p><strong>PMD 直接映射实际物理页面，页面大小为 <code>4K * 2^9 = 2M</code></strong>：<br><img data-src="/images/jvm/memory/06.png" alt="img"></p><p><strong>PUD 直接映射实际物理页面，页面大小为 <code>2M * 2^9 = 1G</code></strong>：<br><img data-src="/images/jvm/memory/07.png" alt="img"></p><p>但是，要想使用这个特性，需要操作系统构建的时候开启 <code>CONFIG_HUGETLBFS</code> 以及 <code>CONFIG_HUGETLB_PAGE</code>。之后，大的页面通常是通过系统管理控制预先分配并放入池里面的。然后，可以通过 <code>mmap</code> 系统调用或者 <code>shmget,shmat</code> 这些 SysV 的共享内存系统调用使用大页分配方式从池中申请内存。</p><p>这种大页分配的方式，需要系统预设开启大页，预分配大页之外，对于代码也是有一定侵入性的，在灵活性上面查一些。但是带来的好处就是，性能表现上更加可控。另一种灵活性很强的 Transparent Huge Pages (THP) 方式，总是可能在性能表现上有一些意想不到的情况。</p><h3 id="Linux-大页分配方式-Transparent-Huge-Pages-THP"><a href="#Linux-大页分配方式-Transparent-Huge-Pages-THP" class="headerlink" title="Linux 大页分配方式 - Transparent Huge Pages (THP)"></a>Linux 大页分配方式 - Transparent Huge Pages (THP)</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">相关的 Linux 内核文档</a></p><p>THP 是一种使用大页的第二种方法，它支持页面大小的自动升级和降级，这样对于用户使用代码基本没有侵入性，非常灵活。但是，前面也提到过，这种系统自己去做页面大小的升级降级，并且系统一般考虑通用性，所以在某些情况下会出现意想不到的性能瓶颈。</p><h3 id="JVM-大页分配相关参数与机制"><a href="#JVM-大页分配相关参数与机制" class="headerlink" title="JVM 大页分配相关参数与机制"></a>JVM 大页分配相关参数与机制</h3><p>相关的参数如下：</p><ul><li><code>UseLargePages</code>：明确指定是否开启大页分配，如果关闭，那么下面的参数就都不生效。<code>在 linux 下默认为 false</code>。</li><li><code>UseHugeTLBFS</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>mmap</code> 系统调用分配内存。在 linux 下默认为 false。</li><li><code>UseSHM</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>shmget,shmat</code> 系统调用分配内存。在 linux 下默认为 false。</li><li><code>UseTransparentHugePages</code>：明确指定是否使用前面第二种大页分配方式 THP。在 linux 下默认为 false。</li><li><code>LargePageSizeInBytes</code>：指定明确的大页的大小，仅适用于前面第一种大页分配方式 hugetlbfs，并且必须属于操作系统支持的页大小否则不生效。默认为 0，即不指定</li></ul><p>首先，需要对以上参数做一个简单的判断：如果没有指定 <code>UseLargePages</code>，那么使用对应系统的默认 <code>UseLargePages</code> 的值，在 linux 下是 false，那么就不会启用大页分配。如果启动参数明确指定 <code>UseLargePages</code> 不启用，那么也不会启用大页分配。如果读取 <code>/proc/meminfo</code> 获取默认大页大小读取不到或者为 0，则代表系统也不支大页分配，大页分配也不启用。</p><p>那么如果大页分配启用的话，我们需要初始化并验证大页分配参数可行性，流程是：<br><img data-src="/images/jvm/memory/08.png" alt="img"></p><p>首先，JVM 会读取根据当前所处的平台与系统环境读取支持的页的大小，当然，这个是针对前面第一种大页分配方式 <code>hugetlbfs</code> 的。在 Linux 环境下，JVM 会从 <code>/proc/meminfo</code> 读取默认的 <strong><code>Hugepagesize</code></strong>，从 <code>/sys/kernel/mm/hugepages</code> 目录下检索<strong>所有支持的大页大小</strong>，这块可以参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp%E3%80%82">https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp。</a><br>有关这些文件或者目录的详细信息，请参考前面章节提到的 Linux 内核文档：<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p><p>如果操作系统开启了 hugetlbfs，<code>/sys/kernel/mm/hugepages</code> 目录下的结构类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tree /sys/kernel/mm/hugepages</span><br><span class="line">/sys/kernel/mm/hugepages</span><br><span class="line">├── hugepages-1048576kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">├── hugepages-2048kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">├── hugepages-32768kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">└── hugepages-64kB</span><br><span class="line">    ├── free_hugepages</span><br><span class="line">    ├── nr_hugepages</span><br><span class="line">    ├── nr_hugepages_mempolicy</span><br><span class="line">    ├── nr_overcommit_hugepages</span><br><span class="line">    ├── resv_hugepages</span><br><span class="line">    └── surplus_hugepages</span><br></pre></td></tr></table></figure><p>这个 <code>hugepages-1048576kB</code> 就代表支持大小为 <code>1GB</code> 的页，<code>hugepages-2048kB</code> 就代表支持大小为 2MB 的页。</p><p>如果没有设置 <code>UseHugeTLBFS</code>，也没有设置 <code>UseSHM</code>，也没有设置 <code>UseTransparentHugePages</code>，那么其实就是走默认的，默认使用 <code>hugetlbfs</code> 方式，不使用 <code>THP</code> 方式，因为如前所述， THP 在某些场景下有意想不到的性能瓶颈表现，在大型应用中，稳定性优先于峰值性能。之后，默认优先尝试 <code>UseHugeTLBFS</code>（即使用 <code>mmap</code> 系统调用通过 hugetlbfs 方式大页分配），不行的话再尝试 <code>UseSHM</code>（即使用 <code>shmget</code> 系统调用通过 hugetlbfs 方式大页分配）。这里只是验证下这些大页内存的分配方式是否可用，只有可用后面真正分配内存的时候才会采用那种可用的大页内存分配方式。</p><h2 id="JVM内存申请与分配机制分析"><a href="#JVM内存申请与分配机制分析" class="headerlink" title="JVM内存申请与分配机制分析"></a>JVM内存申请与分配机制分析</h2><h3 id="内存管理的多级层次"><a href="#内存管理的多级层次" class="headerlink" title="内存管理的多级层次"></a>内存管理的多级层次</h3><p><strong><code>Reserve</code></strong> (预留) → <strong><code>Commit</code></strong> (提交) → <strong><code>Physical Allocation</code></strong> (物理分配)</p><ol><li>Reserve阶段：<ul><li>JVM向操作系统预留一块连续的虚拟地址空间</li><li>此时仅分配地址空间，不分配物理内存或交换空间</li><li>对应参数如 -Xmx 设置的最大堆内存</li></ul></li><li>Commit阶段：<ul><li>JVM向操作系统提交请求，准备使用之前预留的部分虚拟空间</li><li>操作系统标记这部分空间为”已提交”，准备关联物理内存</li><li>对应初始堆大小，如 -Xms 设置的内存</li></ul></li><li>物理分配阶段:<ul><li>当JVM实际写入数据到已提交的内存时，操作系统才分配物理内存页</li><li>这符合现代操作系统的”按需分页”(demand paging)机制</li><li>因此，已提交内存不等于实际使用的物理内存</li></ul></li></ol><h3 id="内存监控与差异"><a href="#内存监控与差异" class="headerlink" title="内存监控与差异"></a>内存监控与差异</h3><p><code>NMT(Native Memory Tracking)</code>显示的提交内存与进程实际使用的物理内存确实存在差异。</p><ol><li>NMT观察到的内存：<ul><li>显示已提交(committed)的内存量</li><li>包括已向操作系统申请但可能尚未使用的内存</li><li>命令: jcmd <pid> VM.native_memory</li></ul></li><li>实际物理内存使用<ul><li>通过 &#x2F;proc&#x2F;<pid>&#x2F;smaps_rollup 中的 PSS(Proportional Set Size)查看</li><li>PSS比VSS和RSS更准确地反映进程实际的物理内存使用</li><li>PSS &#x3D; 私有内存 + 按比例分摊的共享内存</li></ul></li></ol><h3 id="内存监控的最佳实践"><a href="#内存监控的最佳实践" class="headerlink" title="内存监控的最佳实践"></a>内存监控的最佳实践</h3><ol><li>JVM层面<ul><li>NMT: jcmd <pid> VM.native_memory</li><li>JConsole&#x2F;VisualVM可视化监控</li></ul></li><li>OS层面<ul><li>&#x2F;proc&#x2F;<pid>&#x2F;smaps_rollup中的PSS</li><li>top&#x2F;htop命令的RES&#x2F;RSS列</li><li>numastat -p <pid>查看NUMA内存分布</li></ul></li><li>高级监控<ul><li>perf工具分析内存访问模式</li><li>BPF&#x2F;eBPF工具追踪内存分配</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225875600644407357&quot;&gt;JVM 内存申请与使用流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Linux-下内存管理模型简述&quot;&gt;&lt;a href=&quot;#Linux-下内存管理模型简述&quot; class=&quot;headerlink&quot; title=&quot;Linux 下内存管理模型简述&quot;&gt;&lt;/a&gt;Linux 下内存管理模型简述&lt;/h2&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="linux内存" scheme="https://taeyang0126.github.io/tags/linux%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Statistics/Class Loading Statistics</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/</id>
    <published>2025-03-01T03:01:52.000Z</published>
    <updated>2025-03-01T03:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ClassLoadingStatistics</code></li><li>Label(Event Type，用于显示): Class Loading Statistics</li><li>Category(用于分类显示): Java Application，Statistics</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>定时事件</code>: 代表定时采集，没有线程栈信息，因为执行线程都是 <code>JFR Periodic Tasks</code> 线程，采集这个线程栈没有意义</li><li><code>JVM内部事件</code></li></ul></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li><code>Loaded Class Count</code>: 加载类的个数 _class_loaded_count + _shard_classes_loaded_count</li><li><code>UnLoaded Class Count</code>: 卸载类的个数 _class_unloaded_count + _shard_classes_unloaded_count</li><li>这两个字段都是类似于 <code>OpenTelemetry</code> 中的 <code>Gauge</code> 类型字段，瞬时值</li><li>由此可以推测出，当前 JVM 内存中有多少个类 &#x3D; <code>Loaded Class Count - UnLoaded Class Count</code></li></ul><h3 id="采集原理"><a href="#采集原理" class="headerlink" title="采集原理"></a>采集原理</h3><ul><li>每隔 1000ms（默认配置），生成 <code>jdk.ClassLoadingStatistics</code> 事件</li><li>即在 JVM 层面，读取 <code>ClassLoadingService</code> 中的统计数据:<ul><li>加载类的个数: _class_loaded_count + _shard_classes_loaded_count</li><li>卸载类的个数: _class_unloaded_count + _shard_classes_unloaded_count</li></ul></li></ul><h3 id="统计数据的更新时机"><a href="#统计数据的更新时机" class="headerlink" title="统计数据的更新时机"></a>统计数据的更新时机</h3><ul><li>_classes_loaded_count: 每次通过非 CDS 方式加载一个类的时候 +1</li><li>_shard_classes_loaded_count: 每次通过 CDS 方式加载一个类的时候 +1</li><li>_class_unloaded_count: 每次卸载一个非 CDS 类的时候 +1</li><li>_shard_classes_unloaded_count: 每次卸载一个 CDS 类的时候 +1</li></ul><h3 id="什么是-CDS（Class-Data-Sharing）"><a href="#什么是-CDS（Class-Data-Sharing）" class="headerlink" title="什么是 CDS（Class Data Sharing）"></a>什么是 CDS（Class Data Sharing）</h3><ul><li><a href="https://openjdk.org/jeps/310">CDS</a></li><li>Java 10 引入，允许多个 Java 应用程序共享相同的类数据，这样可以减少内存占用</li><li>在启动时，JVM 可以从共享的类数据存储中加载类元数据，而不是每次都从 JAR 文件或类文件中读取</li></ul><h3 id="jfr事件观察"><a href="#jfr事件观察" class="headerlink" title="jfr事件观察"></a>jfr事件观察</h3><blockquote><p>使用 <code>spring-petclinic</code> 项目测试</p></blockquote><ul><li><img data-src="/images/jfr/27.png" alt="img"></li><li>使用图表类型，将两个指标放在折线图中，同时将默认的柱状图隐藏</li></ul><h3 id="还有哪些地方能看到这个事件相同的指标数据？"><a href="#还有哪些地方能看到这个事件相同的指标数据？" class="headerlink" title="还有哪些地方能看到这个事件相同的指标数据？"></a>还有哪些地方能看到这个事件相同的指标数据？</h3><ul><li>_classes_loaded_count，_shard_classes_loaded_count，_classes_unloaded_count，_shard_classes_unloaded_count 这四个在 JVM内部<br>都是通过 <code>PerfDataManager</code> 实现</li><li>所有 <code>PerfDataManager</code> 的数据，JVM 通过下面的虚拟文件暴露出来了<ul><li>默认位置: 临时文件目录 <code>/hsperfdata_用户/进程号</code><br><img data-src="/images/jfr/28.png" alt="img"></li></ul></li><li>很多 JVM 监控工具，比如 Jvisualvm，JConsole 等等，都会访问这个虚拟文件拿实时指标</li><li>Jstat 类加载数据也是读取这个<br><img data-src="/images/jfr/29.png" alt="img"></li><li>Java Mbean 里面也是读取的这些指标<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ManagementFactory.getClassLoadingMXBean().getTotalLoadedClassCount(); <span class="comment">// 等同于事件中的 loadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount(); <span class="comment">// 等同于事件中的 unloadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getLoadedClassCount(); <span class="comment">// 即 loadedClassCount - unloadedClassCount</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h3><ul><li>该事件默认开启，1s采集一次，消耗很小很小，是读取一个现成的 JVM 内部指标，不是通过遍历某个数据结构计数实现。</li><li>使用下面的视图，可以发现类加载和类卸载急剧变化的时候<br><img data-src="/images/jfr/27.png" alt="img"></li><li>一般用来定位：<ol><li>异常大量类加载的问题: 一些反序列化框架，例如老版本 fastjson，利用ASM 定义类加速反序列化，但是由于缓存设计有问题，导致某些情况<br>反序列化会加载大量的类</li><li>大量类的反复加载与卸载的性能问题: 有大量这样的类: 同一个类，一会加载，一会卸载。一般发生在使用大量 lambda 表达式的时候。</li></ol></li><li>需要结合哪些东西一起定位:<ul><li>由于这个事件只能找到变化大的时间段</li><li>具体要定位是哪些类，可以:<ul><li>添加类加载和类卸载日志: <code>-Xlog:class+load,class+unload</code> 这两个，默认的 info 级别就够<br><img data-src="/images/jfr/30.png" alt="img"></li><li>结合其他类加载相关 JFR 事件一起</li></ul></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ClassLoadingStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Class Loading Statistics&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application，Statistics&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;定时事件&lt;/code&gt;: 代表定时采集，没有线程栈信息，因为执行线程都是 &lt;code&gt;JFR Periodic Tasks&lt;/code&gt; 线程，采集这个线程栈没有意义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="类加载" scheme="https://taeyang0126.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Z Allocation Stall</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/</id>
    <published>2025-03-01T02:01:52.000Z</published>
    <updated>2025-03-01T02:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ZAllocationStall</code></li><li>Label(Event Type，用于显示): Z Allocation Stall</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java15</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>ZGC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足</li><li><code>ZGC</code> 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，<br>不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 <code>Allocation Stall</code>（从而被<code>Z Allocation Stall</code>这个事件采集到），<br>但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>ZGC</code></li><li>在 GC 速度跟不上应用线程分配对象的速度时，应用线程尝试分配内存但是内存不足以分配的时候，该线程遇到 <code>Allocation Stall</code>，从而触发这个事件</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Duration</code>: 线程因 Allocation Stall 被阻塞等待 GC 回收足够内存的时间</li><li><code>Size</code>: 触发事件的分配大小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li><code>Type</code>: 从哪个区域分配（不同区域的分配策略，以及扫描回收的策略不一样）<ul><li>small: 小对象在这个区域分配</li><li>medium: 如果最大堆内存大于一定程度，就没必须有 medium。大于一定程度的堆内存，需要在 small 和 large 之间再增加一个区域粒度进行分配和管理</li><li>large: 大对象在这个区域分配</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）<br>启动参数使用 ZGC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// -Xmx32m</span></span><br><span class="line">      <span class="comment">// jdk 23</span></span><br><span class="line">      <span class="comment">// -XX:+UseZGC</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件和 JavaErrorThrow 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">      <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// jfr 启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个 8 * 1G 的数组（ZGC无法使用压缩指针），超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">        Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Z Allocation Stall</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/25.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz();</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM();</span><br><span class="line">  </span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">      T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">            objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">            <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">              objects.clear();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/26.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>保持打开这个事件的采集<ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 Allocation Stall 基本就能采集到，针对大对象，大概率可以采集到，如果对象大小大于 Java 堆内存，必定可以采集到</li><li>对于持续小对象的内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，看到的噪声比较多。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ZAllocationStall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Z Allocation Stall&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java15&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;ZGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZGC&lt;/code&gt; 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，&lt;br&gt;不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 &lt;code&gt;Allocation Stall&lt;/code&gt;（从而被&lt;code&gt;Z Allocation Stall&lt;/code&gt;这个事件采集到），&lt;br&gt;但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Allocation Requiring GC</title>
    <link href="https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/</id>
    <published>2025-02-24T12:55:52.000Z</published>
    <updated>2025-02-24T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.AllocationRequiringGC</code></li><li>Label(Event Type，用于显示): Allocation Requiring GC</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>触发<a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程-路径四</a>分配，<code>在 GC 之前</code>，会触发这个事件的采集</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Pending GC Identifier</code>: 即将触发的 GC ID(每次发生垃圾回收时，JVM 会生成一个全局自增 GC ID，以便于跟踪和分析不同的垃圾回收事件)</li><li>Size: 触发事件的分配发小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// -Xmx32m</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件和 JavaErrorThrow 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line">        <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jfr 启动</span></span><br><span class="line">        recording.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分配一个 4 * 1G 的数组，超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">            <span class="comment">// 为什么这里分配1g的数组，实际对象有4g呢？</span></span><br><span class="line">            <span class="comment">// 1. 如果对象引用启用了压缩指针，那么是4字节</span></span><br><span class="line">            <span class="comment">// 2. 如果使用的是ZGC，由于ZGC没法使用压缩指针，所以是8字节</span></span><br><span class="line">            <span class="comment">// 3. 如果超过32g的内存，也是没法使用压缩指针的，因为四字节就不够用了(无法寻址)</span></span><br><span class="line">            Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                    <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                            + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                            + ProcessHandle.current().pid()</span><br><span class="line">                            + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">            ).toPath();</span><br><span class="line">            recording.dump(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Allocation Requiring GC</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/23.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/24.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>默认没有打开，<code>非常建议打开这个事件的采集</code><ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 GC <code>基本就能采集到</code>，针对大对象，大概率可以采集到。如果对象大小<br>大于 Java 对象堆内存，必定可以采集到</li><li>对于持续小对象内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，会看到噪声比较多。</li></ul></li><li>该事件适合定位的问题<ul><li><code>大对象分配</code>：适合度<code>80%</code>。无论是否分配成功，只要触发了 GC 就都会上报这个事件。对于由于分配大对象导致的<br>OufOfMemoryError（比如一不小心执行了一个扫描全表的 SQL 返回数据的时候），特别合适</li><li><code>Java 堆对象内存泄漏</code>：适合度<code>60%</code>。对于大对象直接导致的 OufOfMemoryError 比较好定位。对于较大对象堆积导致的内存泄漏最终触发 OufOfMemoryError，<br>也比较合适，因为大概率会被采集到。但是对于持续小对象的内存泄漏，这个事件的适合度就比较低了，可能被正常分配导致 GC 的事件覆盖掉了。</li><li><code>GC 过于频繁</code>：适合度<code>50%</code>。对于 GC 过于频繁（比如 GC 暂停时间占应用运行时间的比例超过的一定比例），可以通过这个事件的上报，找到是哪个对象触发导致的<br>GC过于频繁，一般触发的对象比较大或者某一类对象出现的过于频繁，就可以考虑优化这个调用栈去减少 GC。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.AllocationRequiringGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Allocation Requiring GC&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;SerialGC，ParallelGC 或者 G1GC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>java在容器中运行的脚本解析</title>
    <link href="https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/</id>
    <published>2025-02-23T09:46:30.000Z</published>
    <updated>2025-02-23T09:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/files/java/run.sh">run.sh</a></li></ul><h3 id="基础运行命令"><a href="#基础运行命令" class="headerlink" title="基础运行命令"></a>基础运行命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./run.sh           # 直接运行Java应用</span><br><span class="line">./run.sh run       # 同上</span><br><span class="line">./run.sh options   # 打印可用的Java选项</span><br></pre></td></tr></table></figure><h3 id="通过环境变量启用的功能"><a href="#通过环境变量启用的功能" class="headerlink" title="通过环境变量启用的功能"></a>通过环境变量启用的功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试相关</span></span><br><span class="line">export JAVA_ENABLE_DEBUG=true    # 启用远程调试</span><br><span class="line">export JAVA_DEBUG_PORT=5005      # 设置调试端口(默认5005)</span><br><span class="line">export JAVA_DEBUG_SUSPEND=y      # 启动时暂停等待调试器连接</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存相关</span></span><br><span class="line">export JAVA_MAX_MEM_RATIO=80     # 设置最大堆内存占比(默认50%)</span><br><span class="line">export JAVA_INIT_MEM_RATIO=25    # 设置初始堆内存占比</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">诊断相关</span></span><br><span class="line">export JAVA_DIAGNOSTICS=true     # 启用诊断功能</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">效果：启用GC日志、内存跟踪等</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代理相关</span></span><br><span class="line">export HTTP_PROXY=&quot;http://proxy:8080&quot;    # 设置HTTP代理</span><br><span class="line">export HTTPS_PROXY=&quot;https://proxy:8080&quot;   # 设置HTTPS代理</span><br><span class="line">export NO_PROXY=&quot;localhost,127.0.0.1&quot;     # 设置不使用代理的地址</span><br><span class="line"></span><br><span class="line">export JAVA_APP_NAME=&quot;myapp&quot;    # 设置进程名称</span><br><span class="line">export JAVA_MAIN_CLASS=&quot;com.example.Main&quot;  # 指定主类</span><br><span class="line">export JAVA_APP_JAR=&quot;app.jar&quot;   # 指定JAR包</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">===================================================================================</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个用于在容器中运行Java应用的通用启动脚本</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Usage:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="comment"># 可以直接运行Java应用:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh 参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#    # 可以获取Java选项:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh options</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This script will pick up either a <span class="string">&#x27;fat&#x27;</span> jar <span class="built_in">which</span> can be run with <span class="string">&quot;-jar&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or you can sepcify a JAVA_MAIN_CLASS.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 脚本来自于以下项目:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at https://github.com/fabric8io-images/run-java-sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Env-variables evaluated in this script:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># JAVA_OPTIONS: Checked for already set options(设置java参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_MAX_MEM_RATIO: Ratio use to calculate a default maximum Memory, <span class="keyword">in</span> percent.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    用于计算默认最大内存的比例 容器内存*JAVA_MAX_MEM_RATIO=-Xmx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    默认情况下容器内存&lt;300，设置为25，超过则设置为50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    For a good overviews what tuning options are available --&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://youtu.be/Vt4G-pHXfs4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://www.youtube.com/watch?v=w1rZOY5gbvk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://vimeo.com/album/4133413/video/181900266</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还请注意，堆只是 JVM 使用的内存的一小部分。还有很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他内存区域（元数据、线程、代码缓存等），这会增加整体</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大小。当您的容器因 OOM 而终止时，您应该调整</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绝对值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_INIT_MEM_RATIO：用于计算默认初始堆内存的比例（百分比）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下未设置此值。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 以下变量将暴露给您的 Java 应用程序：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># CONTAINER_MAX_MEMORY：容器的最大内存（如果在容器内运行）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAX_CORE_LIMIT：容器可用的内核数（如果在容器内运行）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">==========================================================</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fail on a single failed <span class="built_in">command</span> <span class="keyword">in</span> a pipeline (<span class="keyword">if</span> supported)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查并启用pipefail选项(如果支持) - 使管道中任一命令失败时整个管道都失败</span></span><br><span class="line">(set -o | grep -q pipefail) &amp;&amp; set -o pipefail</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遇到错误就终止执行，使用未定义变量时报错</span></span><br><span class="line">set -eu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存所有传入的参数到ARGS变量</span></span><br><span class="line">ARGS=&quot;$@&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否在ksh环境</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是,将<span class="built_in">local</span>命令别名为<span class="built_in">typeset</span>(ksh使用<span class="built_in">typeset</span>声明局部变量)</span></span><br><span class="line">if [ -n &quot;$&#123;KSH_VERSION:-&#125;&quot; ]; then</span><br><span class="line">  alias local=typeset</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Error is indicated with a prefix <span class="keyword">in</span> the <span class="built_in">return</span> value 错误检查函数</span></span><br><span class="line">check_error() &#123;</span><br><span class="line">  local error_msg=&quot;$1&quot;</span><br><span class="line">  if echo &quot;$&#123;error_msg&#125;&quot; | grep -q &quot;^ERROR:&quot;; then</span><br><span class="line">    echo &quot;$&#123;error_msg&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The full qualified directory <span class="built_in">where</span> this script is located <span class="keyword">in</span> 获取脚本所在目录</span></span><br><span class="line">script_dir() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Default is current directory</span></span><br><span class="line">  local dir=$(dirname &quot;$0&quot;)</span><br><span class="line">  local full_dir=$(cd &quot;$&#123;dir&#125;&quot; &amp;&amp; pwd)</span><br><span class="line">  echo $&#123;full_dir&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Try hard to find a sane default jar-file</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动检测JAR文件</span></span><br><span class="line">auto_detect_jar_file() &#123;</span><br><span class="line">  local dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Filter out temporary jars from the shade plugin <span class="built_in">which</span> start with <span class="string">&#x27;original-&#x27;</span></span></span><br><span class="line">  local old_dir=&quot;$(pwd)&quot;</span><br><span class="line">  cd $&#123;dir&#125;</span><br><span class="line">  if [ $? = 0 ]; then</span><br><span class="line">    # NB: Find both (single) JAR *or* WAR &lt;https://github.com/fabric8io-images/run-java-sh/issues/79&gt;</span><br><span class="line">    local nr_jars=&quot;$(ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27; | wc -l | awk &#x27;&#123;print $1&#125;&#x27;)&quot;</span><br><span class="line">    if [ &quot;$&#123;nr_jars&#125;&quot; = 1 ]; then</span><br><span class="line">      ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27;</span><br><span class="line">      exit 0</span><br><span class="line">    fi</span><br><span class="line">    cd &quot;$&#123;old_dir&#125;&quot;</span><br><span class="line">    echo &quot;ERROR: Neither JAVA_MAIN_CLASS nor JAVA_APP_JAR is set and $&#123;nr_jars&#125; found in $&#123;dir&#125; (1 expected)&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;ERROR: No directory $&#123;dir&#125; found for auto detection&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check directories (arg 2...n) <span class="keyword">for</span> a jar file (arg 1) 在指定目录中查找jar文件</span></span><br><span class="line">find_jar_file() &#123;</span><br><span class="line">  local jar=&quot;$1&quot;</span><br><span class="line">  shift;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Absolute path check <span class="keyword">if</span> jar specifies an absolute path</span></span><br><span class="line">  if [ &quot;$&#123;jar&#125;&quot; != $&#123;jar#/&#125; ]; then</span><br><span class="line">    if [ -f &quot;$&#123;jar&#125;&quot; ]; then</span><br><span class="line">      echo &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;ERROR: No such file $&#123;jar&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    for dir in $*; do</span><br><span class="line">      if [ -f &quot;$&#123;dir&#125;/$jar&quot; ]; then</span><br><span class="line">        echo &quot;$&#123;dir&#125;/$jar&quot;</span><br><span class="line">        return</span><br><span class="line">      fi</span><br><span class="line">    done</span><br><span class="line">    echo &quot;ERROR: No $&#123;jar&#125; found in $*&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generic formula evaluation based on awk 数学计算函数</span></span><br><span class="line">calc() &#123;</span><br><span class="line">  local formula=&quot;$1&quot;</span><br><span class="line">  shift</span><br><span class="line">  echo &quot;$@&quot; | awk &#x27;</span><br><span class="line">    function ceil(x) &#123;</span><br><span class="line">      return x % 1 ? int(x) + 1 : x</span><br><span class="line">    &#125;</span><br><span class="line">    function log2(x) &#123;</span><br><span class="line">      return log(x)/log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    function max2(x, y) &#123;</span><br><span class="line">      return x &gt; y ? x : y</span><br><span class="line">    &#125;</span><br><span class="line">    function round(x) &#123;</span><br><span class="line">      return int(x + 0.5)</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;print &#x27;&quot;int($&#123;formula&#125;)&quot;&#x27;&#125;</span><br><span class="line">  &#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Based on the cgroup limits, figure out the max number of core we should utilize</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算容器的CPU核心限制</span></span><br><span class="line">core_limit() &#123;</span><br><span class="line">  local cpu_period_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;</span><br><span class="line">  local cpu_quota_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;</span><br><span class="line">  if [ -r &quot;$&#123;cpu_period_file&#125;&quot; ]; then</span><br><span class="line">    local cpu_period=&quot;$(cat $&#123;cpu_period_file&#125;)&quot;</span><br><span class="line"></span><br><span class="line">    if [ -r &quot;$&#123;cpu_quota_file&#125;&quot; ]; then</span><br><span class="line">      local cpu_quota=&quot;$(cat $&#123;cpu_quota_file&#125;)&quot;</span><br><span class="line">      # cfs_quota_us == -1 --&gt; no restrictions</span><br><span class="line">      if [ $&#123;cpu_quota:-0&#125; -ne -1 ]; then</span><br><span class="line">        echo $(calc &#x27;ceil($1/$2)&#x27; &quot;$&#123;cpu_quota&#125;&quot; &quot;$&#123;cpu_period&#125;&quot;)</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确定容器的最大内存限制</span></span><br><span class="line">max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">High number <span class="built_in">which</span> is the max <span class="built_in">limit</span> <span class="keyword">until</span> <span class="built_in">which</span> memory is supposed to be</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">unbounded.</span></span><br><span class="line">  local mem_file=&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</span><br><span class="line">  if [ -r &quot;$&#123;mem_file&#125;&quot; ]; then</span><br><span class="line">    local max_mem_cgroup=&quot;$(cat $&#123;mem_file&#125;)&quot;</span><br><span class="line">    local max_mem_meminfo_kb=&quot;$(cat /proc/meminfo | awk &#x27;/MemTotal/ &#123;print $2&#125;&#x27;)&quot;</span><br><span class="line">    local max_mem_meminfo=&quot;$(expr $max_mem_meminfo_kb \* 1024)&quot;</span><br><span class="line">    if [ $&#123;max_mem_cgroup:-0&#125; != -1 ] &amp;&amp; [ $&#123;max_mem_cgroup:-0&#125; -lt $&#123;max_mem_meminfo:-0&#125; ]</span><br><span class="line">    then</span><br><span class="line">      echo &quot;$&#123;max_mem_cgroup&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化容器限制相关的环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取并设置CPU核心限制，获取并设置内存限制，这些变量后续会被Java应用使用</span></span><br><span class="line">init_limit_env_vars() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Read <span class="keyword">in</span> container limits and <span class="built_in">export</span> the as environment variables</span></span><br><span class="line">  local core_limit=&quot;$(core_limit)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;core_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_CORE_LIMIT=&quot;$&#123;core_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local mem_limit=&quot;$(max_memory)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;mem_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_MAX_MEMORY=&quot;$&#123;mem_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取Java主版本号</span></span><br><span class="line">init_java_major_version() &#123;</span><br><span class="line">    # Initialize JAVA_MAJOR_VERSION variable if missing</span><br><span class="line">    if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ]; then</span><br><span class="line">        local full_version=&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Parse JAVA_VERSION variable available in containers</span><br><span class="line">        if [ -n &quot;$&#123;JAVA_VERSION:-&#125;&quot; ]; then</span><br><span class="line">            full_version=&quot;$JAVA_VERSION&quot;</span><br><span class="line">        elif [ -n &quot;$&#123;JAVA_HOME:-&#125;&quot; ] &amp;&amp; [ -r &quot;$&#123;JAVA_HOME&#125;/release&quot; ]; then</span><br><span class="line">            full_version=&quot;$(grep -e &#x27;^JAVA_VERSION=&#x27; $&#123;JAVA_HOME&#125;/release | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)&quot;</span><br><span class="line">        else</span><br><span class="line">            full_version=$(java -version 2&gt;&amp;1 | head -1 | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)</span><br><span class="line">        fi</span><br><span class="line">        export JAVA_MAJOR_VERSION=$(echo $full_version | sed -e &#x27;s/[^0-9]*\(1\.\)\&#123;0,1\&#125;\([0-9]\&#123;1,\&#125;\).*/\2/&#x27;)</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载环境配置</span></span><br><span class="line">load_env() &#123;</span><br><span class="line">  local script_dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Configuration stuff is <span class="built_in">read</span> from this file</span></span><br><span class="line">  local run_env_sh=&quot;run-env.sh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Load default default config</span></span><br><span class="line">  if [ -f &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Check also <span class="variable">$JAVA_APP_DIR</span>. Overrides other defaults</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">It<span class="string">&#x27;s valid to set the app dir in the default script</span></span></span><br><span class="line">  JAVA_APP_DIR=&quot;$&#123;JAVA_APP_DIR:-$&#123;script_dir&#125;&#125;&quot;</span><br><span class="line">  if [ -f &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  export JAVA_APP_DIR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JAVA_LIB_DIR defaults to JAVA_APP_DIR</span></span></span><br><span class="line">  export JAVA_LIB_DIR=&quot;$&#123;JAVA_LIB_DIR:-$&#123;JAVA_APP_DIR&#125;&#125;&quot;</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] &amp;&amp; [ -z &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    JAVA_APP_JAR=&quot;$(auto_detect_jar_file $&#123;JAVA_APP_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    local jar=&quot;$(find_jar_file $&#123;JAVA_APP_JAR&#125; $&#123;JAVA_APP_DIR&#125; $&#123;JAVA_LIB_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    export JAVA_APP_JAR=&quot;$&#123;jar&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    export JAVA_MAIN_CLASS</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for standard /opt/run-java-options first, fallback to run-java-options in the path if not existing</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">获取Java运行选项(优先 /opt/run-java-options)</span></span></span><br><span class="line">run_java_options() &#123;</span><br><span class="line">  if [ -f &quot;/opt/run-java-options&quot; ]; then</span><br><span class="line">    echo &quot;$(. /opt/run-java-options)&quot;</span><br><span class="line">  else</span><br><span class="line">    which run-java-options &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    if [ $? = 0 ]; then</span><br><span class="line">      echo &quot;$(run-java-options)&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置java debug，远程debug</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">JAVA_ENABLE_DEBUG = true</span></span></span><br><span class="line">debug_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_ENABLE_DEBUG:-&#125;&quot; ] || [ -n &quot;$&#123;JAVA_DEBUG_ENABLE:-&#125;&quot; ] ||  [ -n &quot;$&#123;JAVA_DEBUG:-&#125;&quot; ]; then</span><br><span class="line">  local debug_port=&quot;$&#123;JAVA_DEBUG_PORT:-5005&#125;&quot;</span><br><span class="line">    local suspend_mode=&quot;n&quot;</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_DEBUG_SUSPEND:-&#125;&quot; ]; then</span><br><span class="line">      if ! echo &quot;$&#123;JAVA_DEBUG_SUSPEND&#125;&quot; | grep -q -e &#x27;^\(false\|n\|no\|0\)$&#x27;; then</span><br><span class="line">        suspend_mode=&quot;y&quot;</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local address_prefix=&quot;&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;9&quot; ]; then</span><br><span class="line">      address_prefix=&quot;*:&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=$&#123;suspend_mode&#125;,address=$&#123;address_prefix&#125;$&#123;debug_port&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read in a classpath either from a file with a single line, colon separated</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">or given line-by-line in separate lines</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Arg 1: path to claspath (must exist), optional arg2: application jar, which is stripped from the classpath in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">multi line arrangements</span></span></span><br><span class="line">format_classpath() &#123;</span><br><span class="line">  local cp_file=&quot;$1&quot;</span><br><span class="line">  local app_jar=&quot;$&#123;2:-&#125;&quot;</span><br><span class="line"></span><br><span class="line">  local wc_out=&quot;$(wc -l $1 2&gt;&amp;1)&quot;</span><br><span class="line">  if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;Cannot read lines in $&#123;cp_file&#125;: $wc_out&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local nr_lines=$(echo $wc_out | awk &#x27;&#123; print $1 &#125;&#x27;)</span><br><span class="line">  if [ $&#123;nr_lines&#125; -gt 1 ]; then</span><br><span class="line">    local sep=&quot;&quot;</span><br><span class="line">    local classpath=&quot;&quot;</span><br><span class="line">    while read file; do</span><br><span class="line">      local full_path=&quot;$&#123;JAVA_LIB_DIR&#125;/$&#123;file&#125;&quot;</span><br><span class="line">      # Don&#x27;t include app jar if include in list</span><br><span class="line">      if [ &quot;$&#123;app_jar&#125;&quot; != &quot;$&#123;full_path&#125;&quot; ]; then</span><br><span class="line">        classpath=&quot;$&#123;classpath&#125;$&#123;sep&#125;$&#123;full_path&#125;&quot;</span><br><span class="line">      fi</span><br><span class="line">      sep=&quot;:&quot;</span><br><span class="line">    done &lt; &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">    echo &quot;$&#123;classpath&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    # Supposed to be a single line, colon separated classpath file</span><br><span class="line">    cat &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==========================================================================</span></span></span><br><span class="line"></span><br><span class="line">memory_options() &#123;</span><br><span class="line">  echo &quot;$(calc_init_memory) $(calc_max_memory)&quot;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set max heap size if needed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">根据不同条件自动计算并设置JVM的最大堆内存(-Xmx参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">主要逻辑：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">优先级判断：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已在JAVA_OPTIONS中设置了-Xmx，则保持用户设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果没有设置容器最大内存(CONTAINER_MAX_MEMORY)，则不进行设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">堆内存计算规则(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果设置了JAVA_MAX_MEM_RATIO：使用指定比例计算</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果是Java 10+且未设置JAVA_MAX_MEM_RATIO：不设置最大内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 ≤ 300MB：设为容器内存的25%</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 &gt; 300MB：设为容器内存的50%</span></span></span><br><span class="line">calc_max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xmx is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xmx&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check for the &#x27;</span>real memory size<span class="string">&#x27; and calculate Xmx from the ratio</span></span></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAX_MEM_RATIO:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">      # Explicitely switched off</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; &quot;mx&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">When JAVA_MAX_MEM_RATIO not set and JVM &gt;= 10 no max_memory</span></span></span><br><span class="line">  elif [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  elif [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">    # Restore the one-fourth default heap size instead of the one-half below 300MB threshold</span><br><span class="line">    # See https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;25&quot; &quot;mx&quot;</span><br><span class="line">  else</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;50&quot; &quot;mx&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set initial heap size if requested</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">calc_init_memory 的核心功能：计算并设置JVM的初始堆内存大小(-Xms参数)。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断逻辑(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS中已有-Xms，使用用户设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果未设置JAVA_INIT_MEM_RATIO或容器内存，不设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果设置了上述参数，用公式计算：初始堆内存 = 容器内存 × (JAVA_INIT_MEM_RATIO/100)</span></span></span><br><span class="line">calc_init_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xms is already given in JAVA_OPTIONS.</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xms&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check if value set</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_INIT_MEM_RATIO:-&#125;&quot; ] || [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ] || [ &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Calculate Xms from the ratio given</span></span></span><br><span class="line">  calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; &quot;ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xmx -Xms</span></span></span><br><span class="line">calc_mem_opt() &#123;</span><br><span class="line">  local max_mem=&quot;$1&quot;</span><br><span class="line">  local fraction=&quot;$2&quot;</span><br><span class="line">  local mem_opt=&quot;$3&quot;</span><br><span class="line"></span><br><span class="line">  local val=$(calc &#x27;round($1*$2/100/1048576)&#x27; &quot;$&#123;max_mem&#125;&quot; &quot;$&#123;fraction&#125;&quot;)</span><br><span class="line">  echo &quot;-X$&#123;mem_opt&#125;$&#123;val&#125;m&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">当容器内存 ≤ 300MB (314572800字节) 时，禁用C2编译器</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">其他情况启用</span></span></span><br><span class="line">c2_disabled() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    # Disable C2 compiler when container memory &lt;=300MB</span><br><span class="line">    if [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">      echo true</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo false</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">jit_options 函数决定JVM的即时编译器(JIT)级别：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断流程：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS已有TieredStopAtLevel配置则用用户配置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">内存≤300MB时，返回 -XX:TieredStopAtLevel=1，只用C1编译器节省内存</span></span></span><br><span class="line">jit_options() &#123;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -XX:TieredStopAtLevel is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:TieredStopAtLevel&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line">  if [ $(c2_disabled) = true ]; then</span><br><span class="line">    echo &quot;-XX:TieredStopAtLevel=1&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Switch on diagnostics except when switched off</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11+版本：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xlog:gc*:stdout:time            // 统一日志格式输出GC日志</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGC                      // 打印GC信息</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCDateStamps           // 打印GC时间戳</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCTimeStamps           // 打印GC耗时</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line">diagnostics_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_DIAGNOSTICS:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;11&quot; ]; then</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -Xlog:gc*:stdout:time -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Replicate thread ergonomics for tiered compilation.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This could ideally be skipped when tiered compilation is disabled.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The algorithm is taken from:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">OpenJDK / jdk8u / jdk8u / hotspot</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">src/share/vm/runtime/advancedThresholdPolicy.cpp</span></span></span><br><span class="line">ci_compiler_count() &#123;</span><br><span class="line">  local core_limit=&quot;$1&quot;</span><br><span class="line">  local log_cpu=$(calc &#x27;log2($1)&#x27; &quot;$core_limit&quot;)</span><br><span class="line">  local loglog_cpu=$(calc &#x27;log2(max2($1,1))&#x27; &quot;$log_cpu&quot;)</span><br><span class="line">  local count=$(calc &#x27;max2($1*$2,1)*3/2&#x27; &quot;$log_cpu&quot; &quot;$loglog_cpu&quot;)</span><br><span class="line">  local c1_count=$(calc &#x27;max2($1/3,1)&#x27; &quot;$count&quot;)</span><br><span class="line">  local c2_count=$(calc &#x27;max2($1-$2,1)&#x27; &quot;$count&quot; &quot;$c1_count&quot;)</span><br><span class="line">  [ $(c2_disabled) = true ] &amp;&amp; echo &quot;$c1_count&quot; || echo $(calc &#x27;$1+$2&#x27; &quot;$c1_count&quot; &quot;$c2_count&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理(因为能自动识别容器CPU限制)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">当设置了容器CPU限制时，配置以下参数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ParallelGCThreads=核心数     // 并行GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ConcGCThreads=核心数        // 并发GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-Djava.util.concurrent.ForkJoinPool.common.parallelism=核心数  // ForkJoin池线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:CICompilerCount=动态计算值   // JIT编译器线程数</span></span></span><br><span class="line">cpu_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JVMs &gt;= 10 know about CPU limits</span></span></span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local core_limit=&quot;$&#123;JAVA_CORE_LIMIT:-&#125;&quot;</span><br><span class="line">  if [ &quot;$core_limit&quot; = &quot;0&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_CORE_LIMIT:-&#125;&quot; ]; then</span><br><span class="line">    if [ -z $&#123;core_limit&#125; ]; then</span><br><span class="line">      core_limit=&quot;$&#123;CONTAINER_CORE_LIMIT&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;-XX:ParallelGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:ConcGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-Djava.util.concurrent.ForkJoinPool.common.parallelism=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:CICompilerCount=$(ci_compiler_count $core_limit)&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MinHeapFreeRatio=20  These parameters tell the heap to shrink aggressively and to grow conservatively.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MaxHeapFreeRatio=40  Thereby optimizing the amount of memory available to the operating system.</span></span></span><br><span class="line">heap_ratio() &#123;</span><br><span class="line">  echo &quot;-XX:MinHeapFreeRatio=20 -XX:MaxHeapFreeRatio=40&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">These parameters are necessary when running parallel GC if you want to use the Min and Max Heap Free ratios.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Skip setting gc_options if any other GC is set in JAVA_OPTIONS.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已配置GC(比如-XX:UseG1GC)则不处理</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">对Java 10以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UseParallelGC                  # 使用并行GC</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4                   # GC时间占比不超过20%</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90     # GC自适应策略权重</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">$(heap_ratio)                       # 堆内存比例配置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">非Java7版本 -XX:+ExitOnOutOfMemoryError        # OOM时直接退出JVM</span></span></span><br><span class="line">gc_options() &#123;</span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:.*Use.*GC&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local opts=&quot;&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">for JVMs &lt; 10 set GC settings</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -lt &quot;10&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+UseParallelGC -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90 $(heap_ratio)&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; != &quot;7&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+ExitOnOutOfMemoryError&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo $opts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_default_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Echo options, trimming trailing and multiple spaces</span></span></span><br><span class="line">  echo &quot;$(memory_options) $(jit_options) $(diagnostics_options) $(cpu_options) $(gc_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">parse the URL</span></span></span><br><span class="line">parse_url() &#123;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="string">[scheme://][user[:password]@]host[:port][/path][?params]</span></span></span><br><span class="line">  echo &quot;$1&quot; | sed -e &quot;s+^\(\([^:]*\)://\)\?\(\([^:@]*\)\(:\([^@]*\)\)\?@\)\?\([^:/?]*\)\(:\([^/?]*\)\)\?.*$+ local scheme=&#x27;\2&#x27; username=&#x27;\4&#x27; password=&#x27;\6&#x27; hostname=&#x27;\7&#x27; port=&#x27;\9&#x27;+&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_proxy_options() &#123;</span><br><span class="line">  local url=&quot;$1&quot;</span><br><span class="line">  local transport=&quot;$2&quot;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$url&quot; ] ; then</span><br><span class="line">    eval $(parse_url &quot;$url&quot;)</span><br><span class="line">    if [ -n &quot;$hostname&quot; ] ; then</span><br><span class="line">      ret=&quot;-D$&#123;transport&#125;.proxyHost=$&#123;hostname&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$port&quot; ] ; then</span><br><span class="line">      ret=&quot;$ret -D$&#123;transport&#125;.proxyPort=$&#123;port&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$username&quot; -o -n &quot;$password&quot; ] ; then</span><br><span class="line">      echo &quot;WARNING: Proxy URL for $&#123;transport&#125; contains authentication credentials, these are not supported by java&quot; &gt;&amp;2</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for proxy options and echo if enabled.</span></span></span><br><span class="line">proxy_options() &#123;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line">  ret=&quot;$(java_proxy_options &quot;$&#123;https_proxy:-$&#123;HTTPS_PROXY:-&#125;&#125;&quot; https)&quot;</span><br><span class="line">  ret=&quot;$ret $(java_proxy_options &quot;$&#123;http_proxy:-$&#123;HTTP_PROXY:-&#125;&#125;&quot; http)&quot;</span><br><span class="line"></span><br><span class="line">  local noProxy=&quot;$&#123;no_proxy:-$&#123;NO_PROXY:-&#125;&#125;&quot;</span><br><span class="line">  if [ -n &quot;$noProxy&quot; ] ; then</span><br><span class="line">    ret=&quot;$ret -Dhttp.nonProxyHosts=$(echo &quot;|$noProxy&quot; | sed -e &#x27;s/,[[:space:]]*/|/g&#x27; | sed -e &#x27;s/[[:space:]]//g&#x27; | sed -e &#x27;s/|\./|\*\./g&#x27; | cut -c 2-)&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set process name if possible</span></span></span><br><span class="line">exec_args() &#123;</span><br><span class="line">  EXEC_ARGS=&quot;&quot;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_NAME:-&#125;&quot; ]; then</span><br><span class="line">    # Not all shells support the &#x27;exec -a newname&#x27; syntax..</span><br><span class="line">    if $(exec -a test true 2&gt;/dev/null); then</span><br><span class="line">      echo &quot;-a &#x27;$&#123;JAVA_APP_NAME&#125;&#x27;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Combine all java options</span></span></span><br><span class="line">java_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Normalize spaces with awk (i.e. trim and elimate double spaces)</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">See e.g. https://www.physicsforums.com/threads/awk-1-1-1-file-txt.658865/ for an explanation</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">of this awk idiom</span></span></span><br><span class="line">  echo &quot;$&#123;JAVA_OPTIONS:-&#125; $(run_java_options) $(debug_options) $(proxy_options) $(java_default_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fetch classpath from env or from a local &quot;run-classpath&quot; file</span></span></span><br><span class="line">classpath() &#123;</span><br><span class="line">  local cp_path=&quot;.&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_LIB_DIR&#125;&quot; != &quot;$&#123;JAVA_APP_DIR&#125;&quot; ]; then</span><br><span class="line">    cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_LIB_DIR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ] &amp;&amp; [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ]; then</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -f &quot;$&#123;JAVA_LIB_DIR&#125;/classpath&quot; ]; then</span><br><span class="line">      # Classpath is pre-created and stored in a &#x27;run-classpath&#x27; file</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$(format_classpath $&#123;JAVA_LIB_DIR&#125;/classpath $&#123;JAVA_APP_JAR:-&#125;)&quot;</span><br><span class="line">    else</span><br><span class="line">      # No order implied</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_DIR&#125;/*&quot;</span><br><span class="line">    fi</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ]; then</span><br><span class="line">    # Given from the outside</span><br><span class="line">    cp_path=&quot;$&#123;JAVA_CLASSPATH&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$&#123;cp_path&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Checks if a flag is present in the arguments.</span></span></span><br><span class="line">hasflag() &#123;</span><br><span class="line">    local filters=&quot;$@&quot;</span><br><span class="line">    for var in $ARGS; do</span><br><span class="line">        for filter in $filters; do</span><br><span class="line">          if [ &quot;$var&quot; = &quot;$filter&quot; ]; then</span><br><span class="line">              echo &#x27;true&#x27;</span><br><span class="line">              return</span><br><span class="line">          fi</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">开启对应的配置</span></span></span><br><span class="line">options() &#123;</span><br><span class="line">    if [ -z $&#123;1:-&#125; ]; then</span><br><span class="line">      java_options</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local ret=&quot;&quot;</span><br><span class="line">    if [ $(hasflag --debug) ]; then</span><br><span class="line">      ret=&quot;$ret $(debug_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --proxy) ]; then</span><br><span class="line">      ret=&quot;$ret $(proxy_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --java-default) ]; then</span><br><span class="line">      ret=&quot;$ret $(java_default_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --memory) ]; then</span><br><span class="line">      ret=&quot;$ret $(memory_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --jit) ]; then</span><br><span class="line">      ret=&quot;$ret $(jit_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --diagnostics) ]; then</span><br><span class="line">      ret=&quot;$ret $(diagnostics_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --cpu) ]; then</span><br><span class="line">      ret=&quot;$ret $(cpu_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --gc) ]; then</span><br><span class="line">      ret=&quot;$ret $(gc_options)&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo $ret | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Start JVM</span></span></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Initialize environment</span></span></span><br><span class="line">  load_env $(script_dir)</span><br><span class="line"></span><br><span class="line">  local args</span><br><span class="line">  cd $&#123;JAVA_APP_DIR&#125;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] ; then</span><br><span class="line">     args=&quot;$&#123;JAVA_MAIN_CLASS&#125;&quot;</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">     args=&quot;-jar $&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">     echo &quot;Either JAVA_MAIN_CLASS or JAVA_APP_JAR needs to be given&quot;</span><br><span class="line">     exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != 1 ] &amp;&amp; [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != true ]; then</span><br><span class="line">    echo exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Don&#x27;</span>t put <span class="variable">$&#123;args&#125;</span> <span class="keyword">in</span> quotes, otherwise it would be interpreted as a single arg.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">However it could be two args (see above). zsh doesn<span class="string">&#x27;t like this btw, but zsh is not</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">supported anyway.</span></span></span><br><span class="line">  exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">=============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fire up</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Initialize JAVA_MAJOR_VERSION variable if missing</span></span></span><br><span class="line">init_java_major_version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set env vars reflecting limits</span></span></span><br><span class="line">init_limit_env_vars</span><br><span class="line"></span><br><span class="line">first_arg=$&#123;1:-&#125;</span><br><span class="line">if [ &quot;$&#123;first_arg&#125;&quot; = &quot;options&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Print out options only</span></span></span><br><span class="line">  shift</span><br><span class="line">  options $@</span><br><span class="line">  exit 0</span><br><span class="line">elif [ &quot;$&#123;first_arg&#125;&quot; = &quot;run&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Run is the default command, but can be given to allow &quot;options&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">as first argument to your</span></span></span><br><span class="line">  shift</span><br><span class="line">fi</span><br><span class="line">run &quot;$@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/files/java/run.sh&quot;&gt;run.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础运行命令&quot;&gt;&lt;a href=&quot;#基础运行命令&quot; class=&quot;headerlink&quot; title=&quot;基础运行命令&quot;&gt;&lt;/a&gt;基础运行命令&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./run.sh           # 直接运行Java应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh run       # 同上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh options   # 打印可用的Java选项&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="run.sh" scheme="https://taeyang0126.github.io/tags/run-sh/"/>
    
    <category term="运行脚本" scheme="https://taeyang0126.github.io/tags/%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 1.Native Memory Tracking</title>
    <link href="https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/</id>
    <published>2025-02-23T01:46:30.000Z</published>
    <updated>2025-02-23T01:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</p></blockquote><ul><li><a href="https://juejin.cn/post/7225871227743043644">Native Memory Tracking</a></li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>Native Memory Tracking 主要是用来通过在 <code>JVM 向系统申请内存的时候进行埋点实现的</code>。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是有不小消耗的，这个 Native Memory Tracking 默认是不开启的，并且<code>无法动态开启</code>（因为这是埋点采集统计的，如果可以动态开启那么没开启的时候的内存分配没有记录无法知晓，所以无法动态开启），目前只能通过在启动 JVM 的时候通过启动参数开启。即通过 <code>-XX:NativeMemoryTracking</code> 开启:</p><ul><li><code>-XX:NativeMemoryTracking=off</code>:这是默认值，即关闭 Native Memory Tracking</li><li><code>-XX:NativeMemoryTracking=summary</code>: 开启 Native Memory Tracking，但是仅仅按照各个 JVM 子系统去统计内存占用情况</li><li><code>-XX:NativeMemoryTracking=detail</code>: 开启 Native Memory Tracking，从每次 JVM 中申请内存的不同调用路径的维度去统计内存占用情况。注意，开启 detail 比开启 summary 的消耗要大不少，因为 detail 每次都要解析 CallSite 分辨调用位置。我们一般用不到这么详细的内容，除非是 JVM 开发。</li></ul><p>开启之后，我们可以通过 jcmd 命令去查看 Native Memory Tracking 的信息，即<code>jcmd &lt;pid&gt; VM.native_memory</code>：</p><ul><li><code>jcmd &lt;pid&gt; VM.native_memory</code>或者<code>jcmd &lt;pid&gt; VM.native_memory summary</code>：两者是等价的，即查看 Native Memory Tracking 的 summary 信息。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory summary scale&#x3D;MB</li><li><code>jcmd &lt;pid&gt; VM.native_memory detail</code>：查看 Native Memory Tracking 的 detail 信息，包括 summary 信息，以及按照虚拟内存映射分组的内存使用信息，还有按照不同 CallSite 调用分组的内存使用情况。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory detail scale&#x3D;MB</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>我们只关心并且查看 Native Memory Tracking 的 summary 信息即可，detail 信息一般是供 JVM 开发人员使用的，我们不用太关心</p></blockquote><p>一般地，只有遇到问题的时候，我们才会考虑开启 Native Memory Tracking，并且在定位出问题后，我们想把它关闭，可以通过 <code>jcmd &lt;pid&gt; VM.native_memory shutdown</code> 进行关闭并清理掉之前 Native Memory tracking 使用的埋点以及占用的内存。如前面所述，我们无法动态开启 Native Memory tracking，所以只要动态关闭了，这个进程就无法再开启了。</p><p>jcmd 本身提供了简单的对比功能，例如：</p><ol><li>使用 <code>jcmd &lt;pid&gt; VM.native_memory baseline</code> 记录当前内存占用信息</li><li>之后过一段时间 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 会输出当前 Native Memory Tracking 的 summary 信息，如果与第一步 baseline 的有差异，会在对应位将差异输出</li></ol><p>但是这个工具本身比较粗糙，我们有时候并不知道何时调用 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 合适，因为我们不确定什么时候会有我们想看到的内存使用过大的问题。所以我们一般做成一种持续监控的方式</p><h3 id="summary-信息每部分含义"><a href="#summary-信息每部分含义" class="headerlink" title="summary 信息每部分含义"></a>summary 信息每部分含义</h3><p>以下是一个 Native Memory Tracking 的示例输出：</p><ol><li>压测 <a href="https://github.com/spring-projects/spring-petclinic.git">spring-petclinic</a> 项目</li><li>jdk21</li><li>vm options</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">(Omitting categories weighting less than 1KB)</span><br><span class="line"></span><br><span class="line">Total: reserved=1751414KB, committed=470662KB</span><br><span class="line">       malloc: 104634KB #545587</span><br><span class="line">       mmap:   reserved=1646780KB, committed=366028KB</span><br><span class="line"></span><br><span class="line">-                 Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">                            (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">                            (classes #21948)</span><br><span class="line">                            (  instance classes #20377, array classes #1571)</span><br><span class="line">                            (malloc=1935KB #58688) (peak=1999KB #58351) </span><br><span class="line">                            (mmap: reserved=1048576KB, committed=15232KB, at peak) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=131072KB, committed=91072KB)</span><br><span class="line">                            (    used=90300KB)</span><br><span class="line">                            (    waste=772KB =0.85%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=14704KB)</span><br><span class="line">                            (    waste=528KB =3.46%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">                            (threads #58)</span><br><span class="line">                            (stack: reserved=117420KB, committed=117420KB, peak=117420KB)</span><br><span class="line">                            (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">                            (arena=67KB #114) (peak=3010KB #121)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">                            (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">                            (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=33KB #1)</span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">                            (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">                            (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br><span class="line"> </span><br><span class="line">-                 GCCardSet (reserved=70KB, committed=70KB)</span><br><span class="line">                            (malloc=70KB #778) (peak=483KB #1344) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=230KB, committed=230KB)</span><br><span class="line">                            (malloc=100KB #711) (peak=142KB #1118) </span><br><span class="line">                            (arena=130KB #2) (peak=10244KB #9)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">                            (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=108KB, committed=108KB)</span><br><span class="line">                            (malloc=108KB #18) (peak=130KB #20) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">                            (malloc=33100KB #285200) (peak=33111KB #284967) </span><br><span class="line">                            (arena=6017KB #1) (at peak)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                            (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                            (tracking overhead=8525KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">                            (malloc=199KB #306) (peak=16383KB #630) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">                            (malloc=21522KB #12431) (at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=32KB #1)</span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=0KB, committed=0KB)</span><br><span class="line">                            (malloc=0KB #2) (peak=6KB #4) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=276KB, committed=276KB)</span><br><span class="line">                            (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-           Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                            (malloc=3462KB #66139) (peak=3479KB #66484) </span><br><span class="line"> </span><br><span class="line">-            Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                            (malloc=2837KB #33552) (peak=2850KB #33877) </span><br><span class="line"> </span><br><span class="line">-                 Metaspace (reserved=131503KB, committed=91503KB)</span><br><span class="line">                            (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">                            (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br><span class="line"> </span><br><span class="line">-      String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #8) (at peak) </span><br><span class="line"> </span><br><span class="line">-           Object Monitors (reserved=24KB, committed=24KB)</span><br><span class="line">                            (malloc=24KB #116) (peak=162KB #798) </span><br><span class="line"> </span><br><span class="line">-                   Unknown (reserved=0KB, committed=0KB)</span><br><span class="line">                            (mmap: reserved=0KB, committed=0KB, peak=32KB) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Java堆内存-Java-Heap"><a href="#Java堆内存-Java-Heap" class="headerlink" title="Java堆内存(Java Heap)"></a>Java堆内存(Java Heap)</h4><blockquote><p>所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 堆内存占用，reserve 了 262144KB=256M，当前 commit 了 82944KB(81M) 用于实际使用</span><br><span class="line">// 发现 申请的内存大小正好等于=-Xmx256m，预留内存空间（不实际分配物理内存），只是为了让操作系统选择地址，预留大小。commit才是实际使用的物理内存</span><br><span class="line">Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">    // 堆内存都是通过 mmap 系统调用方式分配的，peak=最大使用量</span><br><span class="line">    (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br></pre></td></tr></table></figure><h4 id="元空间-Class"><a href="#元空间-Class" class="headerlink" title="元空间(Class)"></a>元空间(Class)</h4><blockquote><p>JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。对应的 Java 反射类 Class 还是在堆内存空间中</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Class 是类元空间总占用，reserve 了 1050511KB(1025M)，当前 commit 了 17167KB(16MB) 用于实际使用</span><br><span class="line">// 总共 reserved 1050511KB = mmap reserved 1048576KB(1024) + malloc 1935KB(1.8)</span><br><span class="line">// 总共 committed 17167KB = mmap committed 15232KB + malloc 1999KB</span><br><span class="line"> Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">        (classes #21948) //一共加载了 21948 个类</span><br><span class="line">        (  instance classes #20377, array classes #1571)    //其中 20377 个实体类，1571 个数组类</span><br><span class="line">        (malloc=1935KB #58688) (peak=1999KB #58351)  //通过 malloc 系统调用方式一共分配了 1935KB，一共调用了 58688 次 malloc</span><br><span class="line">        (mmap: reserved=1048576KB, committed=15232KB, at peak)  //通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 15232KB 用于实际使用</span><br><span class="line">        (  Metadata:   ) //注意，MetaData 这块不属于类元空间，属于数据元空间</span><br><span class="line">        (    reserved=131072KB, committed=91072KB) //数据元空间当前 reserve 了 131072KB，commit 了 91072KB 用于实际使用</span><br><span class="line">        (    used=90300KB) //但是实际从 MetaChunk 的角度去看使用，只有 90300KB 用于实际数据的分配，有 772KB 的浪费</span><br><span class="line">        (    waste=772KB =0.85%)</span><br><span class="line">        (  Class space:)</span><br><span class="line">        (    reserved=1048576KB, committed=15232KB) //类元空间当前 reserve 了 1048576KB，commit 了 15232KB 用于实际使用 </span><br><span class="line">        (    used=14704KB)  //但是实际从 MetaChunk 的角度去看使用，只有 14704KB 用于实际数据的分配，有 528KB 的浪费</span><br><span class="line">        (    waste=528KB =3.46%)</span><br><span class="line">Module (reserved=276KB, committed=276KB) //加载并记录模块占用空间，当前 reserve 了 276KB，commit 了 276KB 用于实际使用</span><br><span class="line">        (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line">Metaspace (reserved=131503KB, committed=91503KB) //等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 131503KB，commit 了 91503KB 用于实际使用</span><br><span class="line">        (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">        (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="C-字符串即符号-Symbol-占用空间"><a href="#C-字符串即符号-Symbol-占用空间" class="headerlink" title="C++ 字符串即符号(Symbol)占用空间"></a>C++ 字符串即符号(Symbol)占用空间</h4><blockquote><p>前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复。所以统一放入符号表(Symbol table)复用。元空间中保存的是针对符号表中符号的引用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">        (malloc=33100KB #285200) (peak=33111KB #284967)  //通过 malloc 系统调用方式一共分配了 33100KB，一共调用了 285200 次 malloc</span><br><span class="line">        (arena=6017KB #1) (at peak) //通过 arena 系统调用方式一共分配了 6017KB，一共调用了 1 次 arena</span><br></pre></td></tr></table></figure><h4 id="线程占用内存-Thread"><a href="#线程占用内存-Thread" class="headerlink" title="线程占用内存(Thread)"></a>线程占用内存(Thread)</h4><blockquote><p>主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 总共 reserve 了 117590KB(114M)，commit 了 117590KB(114M)</span><br><span class="line">Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">    (threads #58) //当前线程数量是 58</span><br><span class="line">    (stack: reserved=117420KB, committed=117420KB, peak=117420KB) //线程栈占用的空间: 每个线程实际占用 ≈ 1MB(栈) + 2MB(Guard Pages) 58个线程总占用 ≈ 58 * (1MB + 2MB) ≈ 174MB，实际看到117MB比理论值小，因为Guard Pages可能共享</span><br><span class="line">    (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">    (arena=67KB #114) (peak=3010KB #121)</span><br></pre></td></tr></table></figure><h4 id="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code"><a href="#JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code" class="headerlink" title="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)"></a>JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">    (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">    (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">    (arena=0KB #0) (peak=33KB #1)</span><br></pre></td></tr></table></figure><h4 id="Arena-数据结构占用空间-Arena-Chunk"><a href="#Arena-数据结构占用空间-Arena-Chunk" class="headerlink" title="Arena 数据结构占用空间(Arena Chunk)"></a>Arena 数据结构占用空间(Arena Chunk)</h4><blockquote><p> Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">            (malloc=199KB #306) (peak=16383KB #630) </span><br></pre></td></tr></table></figure><h4 id="JVM-Tracing-占用内存"><a href="#JVM-Tracing-占用内存" class="headerlink" title="JVM Tracing 占用内存"></a>JVM Tracing 占用内存</h4><blockquote><p>包括 JVM perf 以及 JFR 占用的空间。其中 JFR 占用的空间可能会比较大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">    (malloc=21522KB #12431) (at peak) </span><br><span class="line">    (arena=0KB #0) (peak=32KB #1)</span><br></pre></td></tr></table></figure><h4 id="写-JVM-日志占用的内存-Logging"><a href="#写-JVM-日志占用的内存-Logging" class="headerlink" title="写 JVM 日志占用的内存(Logging)"></a>写 JVM 日志占用的内存(Logging)</h4><blockquote><p>-Xlog 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志-Xlog:async，异步日志所需的 buffer 也在这里</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logging (reserved=0KB, committed=0KB)</span><br><span class="line">        (malloc=0KB #2) (peak=6KB #4) </span><br></pre></td></tr></table></figure><h4 id="JVM-参数占用内存-Arguments"><a href="#JVM-参数占用内存-Arguments" class="headerlink" title="JVM 参数占用内存(Arguments)"></a>JVM 参数占用内存(Arguments)</h4><blockquote><p>我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">(malloc=31KB #90) </span><br></pre></td></tr></table></figure><h4 id="JVM-安全点占用内存-Safepoint"><a href="#JVM-安全点占用内存-Safepoint" class="headerlink" title="JVM 安全点占用内存(Safepoint)"></a>JVM 安全点占用内存(Safepoint)</h4><blockquote><p>是固定的两页内存（我这里是一页是 16KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">           (mmap: reserved=32KB, committed=32KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="Java-同步机制-Synchronization"><a href="#Java-同步机制-Synchronization" class="headerlink" title="Java 同步机制(Synchronization)"></a>Java 同步机制(Synchronization)</h4><blockquote><p>例如 synchronized，还有 AQS 的基础 LockSupport 底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                (malloc=3462KB #66139) (peak=3479KB #66484) </span><br></pre></td></tr></table></figure><h4 id="JVM-TI-相关内存-Serviceability"><a href="#JVM-TI-相关内存-Serviceability" class="headerlink" title="JVM TI 相关内存(Serviceability)"></a>JVM TI 相关内存(Serviceability)</h4><blockquote><p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏检测工具等等。这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                (malloc=2837KB #33552) (peak=2850KB #33877) </span><br></pre></td></tr></table></figure><h4 id="Java-字符串去重占用内存-String-Deduplication"><a href="#Java-字符串去重占用内存-String-Deduplication" class="headerlink" title="Java 字符串去重占用内存(String Deduplication)"></a>Java 字符串去重占用内存(String Deduplication)</h4><blockquote><p>Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 <code>G1GC</code> 以及 <code>ZGC</code> 中，所以默认是关闭的，可以通过 <code>-XX:+UseStringDeduplication</code> 来启用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                    (malloc=1KB #8) (at peak) </span><br></pre></td></tr></table></figure><h4 id="JVM-GC需要的数据结构与记录信息占用的空间-GC"><a href="#JVM-GC需要的数据结构与记录信息占用的空间-GC" class="headerlink" title="JVM GC需要的数据结构与记录信息占用的空间(GC)"></a>JVM GC需要的数据结构与记录信息占用的空间(GC)</h4><blockquote><p>这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 <code>ZGC</code>。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">    (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">    (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br></pre></td></tr></table></figure><h4 id="JVM内部与其他占用"><a href="#JVM内部与其他占用" class="headerlink" title="JVM内部与其他占用"></a>JVM内部与其他占用</h4><blockquote><p>JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">        (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">        (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"></span><br><span class="line"> Other (reserved=108KB, committed=108KB)</span><br><span class="line">        (malloc=108KB #18) (peak=130KB #20) </span><br></pre></td></tr></table></figure><h4 id="开启-Native-Memory-Tracking-本身消耗的内存"><a href="#开启-Native-Memory-Tracking-本身消耗的内存" class="headerlink" title="开启 Native Memory Tracking 本身消耗的内存"></a>开启 Native Memory Tracking 本身消耗的内存</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                    (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                    (tracking overhead=8525KB)</span><br></pre></td></tr></table></figure><h3 id="Native-Memory-Tracking-的-summary-信息的持续监控"><a href="#Native-Memory-Tracking-的-summary-信息的持续监控" class="headerlink" title="Native Memory Tracking 的 summary 信息的持续监控"></a>Native Memory Tracking 的 summary 信息的持续监控</h3><p>现在 JVM 一般大部分部署在 k8s 这种云容器编排的环境中，每个 JVM 进程内存是受限的。如果超过限制，那么会触发 OOMKiller 将这个 JVM 进程杀掉。我们一般都是由于自己的 JVM 进程被 OOMKiller杀掉，才会考虑打开 <code>NativeMemoryTracking</code> 去看看哪块内存占用比较多以及如何调整的。</p><p><code>OOMKiller 是积分制</code>，并不是你的 JVM 进程一超过限制就立刻会被杀掉，而是超过的话会累积分，累积到一定程度，就可能会被 OOMKiller 杀掉。所以，我们可以通过<code>定时输出</code> Native Memory Tracking的 summary 信息，从而抓到超过内存限制的点进行分析</p><p>但是，我们不能仅通过 Native Memory Tracking 的数据就判断 JVM 占用的内存，因为在后面的 JVM 内存申请与使用流程的分析我们会看到，<code>JVM 通过 mmap 分配的大量内存都是先 reserve 再 commit 之后实际往里面写入数据的时候，才会真正分配物理内存</code>。同时，JVM 还会动态释放一些内存，这些内存可能不会立刻被操作系统回收。<code>Native Memory Tracking 是 JVM 认为自己向操作系统申请的内存，与实际操作系统分配的内存是有所差距的</code>，所以我们不能只查看 Native Memory Tracking 去判断，我们还需要查看能体现真正内存占用指标。这里可以查看 linux 进程监控文件 smaps_rollup 看出具体的内存占用，例如 (一般不看 Rss，因为如果涉及多个虚拟地址映射同一个物理地址的话会有不准确，所以主要关注 <code>Pss</code> 即可，但是 Pss 更新不是实时的，但也差不多，这就可以理解为进程占用的实际物理内存)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/1/smaps_rollup </span><br><span class="line">f8000000-ffffe5c27000 ---p 00000000 00:00 0                              [rollup]</span><br><span class="line">Rss:              198904 kB</span><br><span class="line">Pss:              197331 kB</span><br><span class="line">Pss_Dirty:        181900 kB</span><br><span class="line">Pss_Anon:         181880 kB</span><br><span class="line">Pss_File:          15451 kB</span><br><span class="line">Pss_Shmem:             0 kB</span><br><span class="line">Shared_Clean:       1864 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:     15140 kB</span><br><span class="line">Private_Dirty:    181900 kB</span><br><span class="line">Referenced:       198904 kB</span><br><span class="line">Anonymous:        181880 kB</span><br><span class="line">KSM:                   0 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FilePmdMapped:         0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure><p>通过在每个 Spring Cloud 微服务进程加入下面的代码，来实现定时的进程内存监控，主要通过 <code>smaps_rollup</code> 查看实际的物理内存占用找到内存超限的时间点，Native Memory Tracking 查看 JVM 每块内存占用的多少，用于指导优化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.bootstrap.BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorMemoryRSS</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">INITIALIZED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBootstrapContext(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (INITIALIZED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZED.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取 smaps_rollup</span></span><br><span class="line">                    List&lt;String&gt; strings = FileUtils.readLines(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/smaps_rollup&quot;</span>));</span><br><span class="line">                    log.info(<span class="string">&quot;MonitorMemoryRSS, smaps_rollup: &#123;&#125;&quot;</span>, strings.stream().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    <span class="comment">//读取 Native Memory Tracking 信息</span></span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;jcmd&quot;</span>, pid + <span class="string">&quot;&quot;</span>, <span class="string">&quot;VM.native_memory&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()))) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;MonitorMemoryRSS, native_memory: &#123;&#125;&quot;</span>, reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            INITIALIZED.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBootstrapContext</span><span class="params">(ApplicationReadyEvent applicationEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationEvent.getApplicationContext().getEnvironment().getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225871227743043644&quot;&gt;Native Memory Tracking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开启&quot;&gt;&lt;a href=&quot;#开启&quot; class=&quot;headerlink&quot; title=&quot;开启&quot;&gt;&lt;/a&gt;开启&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="NMT" scheme="https://taeyang0126.github.io/tags/NMT/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Sample</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/</id>
    <published>2025-02-22T12:55:52.000Z</published>
    <updated>2025-02-22T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationSample</code></li><li>Label(Event Type，用于显示): Object Allocation Sample</li><li>Category(用于分类显示): Java Application</li><li>事件从<code>Java16</code>引入(目的是想有一个采集消耗不像 <code>ObjectAllocationInNewTLAB</code> 这么大的事件)</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二、路径三、路径四</code></li><li><code>路径二、路径三</code> 分配一定进入采样中，<code>路径四</code> 分配失败不会进入采样中</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>150/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>300/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二、三、四分配然后被采集到的线程的名称</li><li>Object Class：发生路径二、三、四分配然后被采集到的对象大小类型</li><li><code>Sample Weight</code><ul><li>采样到的采样权重</li><li>每个线程都有一个采样数据记录了分配了多少对象，对象的总大小</li><li>这个采样权重就是这个线程当前分配对象总大小减去上次这个线程被采样到的时候的分配对象的总大小</li><li>其实就是近似的任务，这个线程这个期间分配的对象都是 Object Class 类型，大小是采样权重这么大</li><li>单独一个 Object Allocation Sample 事件的 weight 仅代表当前这个线程上次触发 Object Allocation Sample 之后，<br>这个线程分配的对象大小，所以<code>单独看一个事件的这个值没有参考意义</code></li><li><code>它的参考意义主要在于</code>，按照线程和 Object Class 分组，将所有 weight 相加，统计这个线程分配的对象的总大小，这个值可以<br>用于分析这个线程在这段时间的分配压力，以及这个线程的分配对象的类型分布情况</li></ul></li><li>线程栈：发生路径二、三、四分配然后被采集到的线程栈，默认是采集的</li></ul><h3 id="事件采集原理"><a href="#事件采集原理" class="headerlink" title="事件采集原理"></a>事件采集原理</h3><pre><code class="mermaid">%%{init: {&#39;theme&#39;: &#39;default&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#2B6CB0&#39; }}}%%flowchart TD    A1[当前分配的对象触发申请新的 TLAB 分配并且成功分配后-路径二]    A2[当前分配的对象触发 TLAB 外分配并且分配成功后-路径三]    B[生成 Object Allocation Sample 事件]    C[设置事件的 objectClass 为分配对象的 class]    A1 --&gt; B    A2 --&gt; |重复n次，n &#x3D; 分配的对象大小除以 TLAB 大小，用于让大对象更容易生成 Object Allocation Sample-更容易被采集到| B    B --&gt; C    C --&gt; D[设置事件的 weight 为当前线程已经分配的总内存减去上次触发 Object Allocation Sample 事件当前线程已经分配的总内存]    D --&gt; E[记录当前线程已经分配的总内存用于下次计算 weight]</code></pre><h3 id="编写测试代码-使用虚拟线程"><a href="#编写测试代码-使用虚拟线程" class="headerlink" title="编写测试代码(使用虚拟线程)"></a>编写测试代码(使用虚拟线程)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 和 ObjectAllocationOutsideTLAB 事件，用于对比</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;150/s&quot;</span>);</span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object Allocation Sample 定位可能的内存泄漏，并不是太合适，容易被热点对象吞没<br><img data-src="/images/jfr/15.png" alt="img"></li><li>Object Allocation Sample <code>非常适合定位热点分配对象中有没有哪些意料之外的频繁对象分配</code>，从而优化性能<ul><li>以 Object Allocation Sample 创建新的标签页<br><img data-src="/images/jfr/16.png" alt="img"></li><li>在标签页，首页按照线程分组<br><img data-src="/images/jfr/17.png" alt="img"></li><li>在上个分组基础上按照对象类型分组<br><img data-src="/images/jfr/18.png" alt="img"></li></ul></li><li>从JFR可以看出，<code>.values</code>遍历数组每次都会新创建一个数组对象，造成非常频繁的对象分配，影响性能(jdk21)<br><img data-src="/images/jfr/19.png" alt="img"></li><li>jdk23下，发现Object分配比Enum还多，这是个奇特的点！<br><img data-src="/images/jfr/20.png" alt="img"></li><li>将 Object Allocation Sample 的 throttle 改为 1&#x2F;s，效果如下(jdk21)<br><img data-src="/images/jfr/21.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>建议维持打开 Object Allocation Sample</li><li>但是 throttle 设置为 1&#x2F;s ~ 5&#x2F;s 即可，基本可以定位到分配热点以及意想不到的分配，进行代码优化</li><li>这个事件适合定位什么问题？<ul><li>大对象分配：适合度50%。这个只会采集分配成功的对象，对于大对象分配，如果触发 OutOfMemoryError 代表分配失败，那采集不到。</li><li>意想不到大量对象分配：适合度 90% 。通过 weight 统计，可以找到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。<br>在做定期性能优化的时候，可以经常看看。</li><li>Java 堆对象内存泄漏：适合度 10% 。仅仅可以定位热点分配的对象类型和堆栈，但是内存泄漏如果不是热点对象导致的，就不太好定位了。</li><li>GC 过于频繁：适合度 100% 。可以定位到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationSample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Sample&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java16&lt;/code&gt;引入(目的是想有一个采集消耗不像 &lt;code&gt;ObjectAllocationInNewTLAB&lt;/code&gt; 这么大的事件)&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径二、路径三、路径四&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;路径二、路径三&lt;/code&gt; 分配一定进入采样中，&lt;code&gt;路径四&lt;/code&gt; 分配失败不会进入采样中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>画图工具</title>
    <link href="https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/</id>
    <published>2025-02-22T11:55:52.000Z</published>
    <updated>2025-02-22T11:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mermaid-live.nodejs.cn/">mermaid在线画图</a></li><li><a href="https://www.min2k.com/tools/mermaid/">中文mermaid在线画图</a></li><li><a href="https://mermaid.nodejs.cn/intro/">mermaid中文网</a></li><li><a href="https://excalidraw.com/">手绘风格画图</a></li><li><a href="https://fskpf.github.io/">svg图片转手绘风格</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mermaid-live.nodejs.cn/&quot;&gt;mermaid在线画图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.min2k.com/tools/mermaid/&quot;&gt;中文mermaid在线画图&lt;/a&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="画图" scheme="https://taeyang0126.github.io/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-你可能没必要 Heap Dump</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/</id>
    <published>2025-02-22T07:25:52.000Z</published>
    <updated>2025-02-22T07:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><blockquote><p>很多情况会导致 Java 应用抛出 <code>OutOfMemoryError</code> <a href="https://zhuanlan.zhihu.com/p/265039643">参考 StackOverflowError 与 OutOfMemoryError</a></p></blockquote><h4 id="会触发HeapDumpOnOutOfMemoryError"><a href="#会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="会触发HeapDumpOnOutOfMemoryError"></a>会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><code>OutOfMemoryError: Java heap space</code> 和 <code>OutOfMemoryError: GC overhead limit exceeded</code> ：这两个都是 Java 对象堆内存不够了，一个是分配的时候发现剩余空间不足，一个是到达某一界限</li><li><code>OutOfMemoryError: Requested array size exceeds VM limit</code> ：当申请的数组大小超过堆内存限制，就会抛出这个异常</li><li><code>OutOfMemoryError: Compressed class space</code> 和 <code>OutOfMemoryError: Metaspace</code> ：这两个都和元空间相关（<a href="https://juejin.cn/post/7225879724545835045">底层原理</a>）</li><li><code>Shenandoah</code> 分配区域位图，内存的时候，触发的 OutOfMemoryError</li></ul><h4 id="不会触发HeapDumpOnOutOfMemoryError"><a href="#不会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="不会触发HeapDumpOnOutOfMemoryError"></a>不会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><strong>OutOfMemoryError: unable to create native thread</strong> ：无法创建新的平台线程</li><li><strong>OutOfMemoryError: Cannot reserve xxx bytes of direct buffer memory (allocated: xxx, limit: xxx)</strong> ：在 DirectByteBuffer 中，首先向 Bits 类申请额度， Bits 类有一个全局的 totalCapacity 变量，记录着全部DirectByteBuffer 的总大小，每次申请，都先看看是否超限，可用 <code>-XX:MaxDirectMemorySize</code> 限制（未指定默认与-Xmx相同）</li><li><strong>OutOfMemoryError: map failed</strong> ：这个是 File MMAP （文件映射内存）时，如果系统内存不足，就会抛出这个异常</li><li>OutOfMemoryError: Native heap allocation failed ，这个 Message 可能不同操作系统不一样，但是一般都有 native heap 。这个就和 Java 对象堆一般没关系，而是其他块内存无法申请导致的</li></ul><h3 id="为什么不建议打开HeapDumpOnOutOfMemoryError"><a href="#为什么不建议打开HeapDumpOnOutOfMemoryError" class="headerlink" title="为什么不建议打开HeapDumpOnOutOfMemoryError"></a>为什么不建议打开<code>HeapDumpOnOutOfMemoryError</code></h3><h4 id="HeapDumpOnOutOfMemoryError-的原理"><a href="#HeapDumpOnOutOfMemoryError-的原理" class="headerlink" title="HeapDumpOnOutOfMemoryError 的原理"></a><code>HeapDumpOnOutOfMemoryError</code> 的原理</h4><ul><li>进入安全点，所有应用线程暂停，针对 HeapDumpOnOutOfMemoryError，单线程（如果是 jcmd jmap 可以多线程）dump 堆为线程个数个文件。退出安全点。</li><li>将上面的多个文件，合并为一个，压缩。</li></ul><h4 id="HeapDumpOnOutOfMemoryError-的瓶颈"><a href="#HeapDumpOnOutOfMemoryError-的瓶颈" class="headerlink" title="HeapDumpOnOutOfMemoryError 的瓶颈"></a><code>HeapDumpOnOutOfMemoryError</code> 的瓶颈</h4><blockquote><p>这里的瓶颈主要在于第一步写入，并且，主要瓶颈在磁盘 IO</p></blockquote><ul><li><a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html">AWS EFS （普通存储）</a></li><li><a href="https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html">AWS EBS （对标 SSD ）</a></li><li>对于一个 4G 大小的 Java 对象堆内存，如果是 EFS ，对标的应该是 100G 以内的磁盘，写入最少<br>也需要大概 4 * 1024 &#x2F; 300 &#x3D; 13.65 秒（注意，这个是峰值性能），如果当时峰值性能被用完了，那<br>么需要： 4 * 1024 &#x2F; 15 &#x3D; 273 秒。如果用 EBS ，那么也需要 4 * 1024 &#x2F; 1000 &#x3D; 4 秒。注意，这个<br>计算的时间，是应用线程个完全处于安全点（即 Stop-the-world ）的时间，还没有考虑一个<br>机器上部署多个容器实例的情况，考虑成本我们也不能堆每个微服务都使用 AWS EBS 这种（对标<br>SSD ）。所以，建议还是不要打开 <code>HeapDumpOnOutOfMemoryError</code></li></ul><h3 id="为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？"><a href="#为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？" class="headerlink" title="为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？"></a>为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？</h3><h4 id="jfr配置"><a href="#jfr配置" class="headerlink" title="jfr配置"></a>jfr配置</h4><ul><li>jfc配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>5/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ObjectAllocationOutsideTLAB：TLAB外的分配</li><li>ObjectAllocationSample：TLAB外的以及申请新的TLAB的采样</li><li>AllocationRequiringGC：某个对象分配失败导致gc采集，针对serial、parallel、G1 gc</li><li>ZAllocationStall：ZGC中使用，当一个线程分配对象发现内存不够了，就会阻塞，从而生成此事件。”threshold”&gt;0 阻塞0ms以上都采集<br>ZGC Allocation Stall事件为啥看不到触发内存溢出的业务代码呢？jdk23才可以</li><li>JVM参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stackdepth=256 是为了演示效果，一般不需要这么大</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxchunksize=128m 是为了演示效果，一般不需要这么大</span></span><br><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br></pre></td></tr></table></figure></li></ul><h4 id="大对象分配导致的问题"><a href="#大对象分配导致的问题" class="headerlink" title="大对象分配导致的问题"></a>大对象分配导致的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote><p>某个请求有 bug，导致全表扫描，冲爆了 Java 对象堆内存。抛出了 OutOfMemoryError ，但是这是异常情况，可能无法输出堆栈日志，在茫茫众多的请求中很难找到这个请求</p></blockquote><ul><li>模拟了一个方法，从db返回结果非常大，直接导致OOM，输出的jfr如下</li><li><img data-src="/images/jfr/08.png" alt="img"></li><li><img data-src="/images/jfr/09.png" alt="img"></li><li>ZGC查看如下图<br><img data-src="/images/jfr/10.png" alt="img"></li></ul><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote><p>用户累计订单量随着你的系统成熟越来越多，大历史订单量的用户越来越多。之前的代码有 bug ，用户订单列表实际是拉取每个用户的所有订单 内存分页。可能两个大历史订单量的用户同时查询的时候就会抛出 OutOfMemoryError ，就算不抛出也会频繁 GC 影响性能。</p></blockquote><ul><li>模拟了一个方法，多个大订单量的用户并发查询，可能没有导致OOM，但是会频繁的GC，输出的jfr如下</li><li><img data-src="/images/jfr/11.png" alt="img"></li><li><img data-src="/images/jfr/12.png" alt="img"></li></ul><h4 id="小对象分配导致的问题"><a href="#小对象分配导致的问题" class="headerlink" title="小对象分配导致的问题"></a>小对象分配导致的问题</h4><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote><p>某个请求会触发分配一个小对象放入类似于缓存的地方，但是这个小对象一直没有被回收，日积月累导致 FullGC 越来越频繁，最后<br>OutOfMemoryError</p></blockquote><ul><li>这种情况，可能导致 JFR 事件丢失，但是大概率不影响我们定位问题，因为是一连串的趋势可以看出来</li><li><img data-src="/images/jfr/13.png" alt="img"></li><li><img data-src="/images/jfr/14.png" alt="img"></li></ul><h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote><p>由于虚拟线程的引入，原来进程内处理请求的数量一定程度受限于 IO 以及线程数量，现在则是受限于 Java 对象堆内存大小，如何识别这种<code>背压</code>问题。</p></blockquote><h3 id="为什么抛出-OutOfMemoryError-的微服务最好下线重启？"><a href="#为什么抛出-OutOfMemoryError-的微服务最好下线重启？" class="headerlink" title="为什么抛出 OutOfMemoryError 的微服务最好下线重启？"></a>为什么抛出 OutOfMemoryError 的微服务最好下线重启？</h3><ul><li>因为包括 JDK 的源码在内，都没有在每一个分配内存的代码的地方考虑会出现 OutOfMemoryError ，这样会导致代码<br>状态不一致，例如 hashmap 的 rehash ，如果里面某行抛出 OutOfMemoryError ，前面更新的状态就不对了。</li><li>还有其他很多库，就不用说了，都很少有 catch Throwable 的，大部分是 catch Exception 的。并且，在每一个分配内<br>存的代码的地方考虑会出现 OutOfMemoryError 也是不现实的，所以为了防止 OutOfMemoryError 带来意想不到的<br>一致性问题，还是下线重启比较好。</li></ul><h3 id="如何实现抛出-OutOfMemoryError-的微服务下线重启？"><a href="#如何实现抛出-OutOfMemoryError-的微服务下线重启？" class="headerlink" title="如何实现抛出 OutOfMemoryError 的微服务下线重启？"></a>如何实现抛出 OutOfMemoryError 的微服务下线重启？</h3><ul><li>一般通过 -XX:OnOutOfMemoryError&#x3D;”&#x2F;path&#x2F;to&#x2F;script.sh” 指定脚本，脚本执行<ul><li>微服务的下线</li><li>微服务的重启(可以依赖k8s)</li></ul></li><li>针对 spring boot ，可以考虑开启允许本地访问 &#x2F;actuator&#x2F;shutdown 来关闭微服务（有群友反应抛出<br>OutOfMemoryError 的时候调用这个会卡死，这是因为前面说的原因，你可能开启了<br>HeapDumpOnOutOfMemoryError 导致的）， k8s 会自动拉起一个新的。<ul><li>因为<code>HeapDump</code>需要进入安全点，所有线程都 STW 了，导致k8s健康检查失败，从而k8s会自动拉起一个新的，导致dump失败</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;OutOfMemoryError&quot;&gt;&lt;a href=&quot;#OutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;OutOfMemoryError&quot;&gt;&lt;/a&gt;OutOfMemoryError&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多情况会导致 Java 应用抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/265039643&quot;&gt;参考 StackOverflowError 与 OutOfMemoryError&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="OOM" scheme="https://taeyang0126.github.io/tags/OOM/"/>
    
    <category term="Heap Dump" scheme="https://taeyang0126.github.io/tags/Heap-Dump/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Outside TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/</id>
    <published>2025-02-22T06:25:52.000Z</published>
    <updated>2025-02-22T06:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationOutsideTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation Outside TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径三</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径三分配的线程的名称</li><li>Allocation Size：触发路径三分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径三分配的对象类型</li><li>线程栈：发生路径三的线程栈，默认是采集的<br><img data-src="/images/jfr/07.png" alt="img"></li></ul><h3 id="编写代码模拟内存泄漏业务"><a href="#编写代码模拟内存泄漏业务" class="headerlink" title="编写代码模拟内存泄漏业务"></a>编写代码模拟内存泄漏业务</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocOutsideTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，三个线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">bizRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">              <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                  objects.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;biz-&quot;</span> + i)</span><br><span class="line">                      .unstarted(bizRunnable);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(bizRunnable);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                  threads[i].interrupt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">oomRun</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">              map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;oom-&quot;</span> + i)</span><br><span class="line">                      .unstarted(oomRun);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(oomRun);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否建议开启这个事件的采集"><a href="#是否建议开启这个事件的采集" class="headerlink" title="是否建议开启这个事件的采集"></a>是否建议开启这个事件的采集</h3><ul><li>建议开启<ul><li>上面提到的Java内存分配路径，对于一般的JVM应用，<code>TLAB</code>内分配的量远大于申请新的TLAB分配的量，同时申请新的TLAB的量又远大于在TLAB外分配的量。除非你的应用分配大量的大对象，否则这个事件发生的应该比较少</li><li>对于一般的JVM应用，建议还是开启这个事件的采集，这样能采集到在你应用的所有大对象分配。只要你的应用不是大对象分配过多，这个事件的采集对于性能的影响应该是可以接受的。</li><li>路径三分配一般会包含核心问题点：<ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li></ul></li><li>与其他哪些事件是否有重合<ul><li><code>Object Allocation Sample</code>: 虽然 Object Allocation Sample 官方默认开启，但是对于大部分小对象朝生夕死的应用，其实更应该开启 Object Allocation Outside TLAB，而不是Object Allocation Sample。大部分应用，采集到的 Object Allocation Outside TLAB 会比默认的 Object Allocation Sample 少很多很多，性能消耗小很多很多。建议将 Object Allocation Sample 的采样率调很低，主要用于看意向不到的对象分配。</li><li><code>Allocation Requiring GC 以及 ZAllocation Stall</code>: 后续分析这些事件我们会看到，有内存泄漏嫌疑的对象分配相关的对象分配路径，基本上很少会被这两个事件以及 Object Allocation Outside TLAB 采集到</li></ul></li></ul><h3 id="这个事件适合定位什么问题？"><a href="#这个事件适合定位什么问题？" class="headerlink" title="这个事件适合定位什么问题？"></a>这个事件适合定位什么问题？</h3><ul><li>大对象分配：适合度70%<ul><li>对于大于TLAB大小的对象，如果分配成功一定可以采集到</li><li>对于大于TLAB最大浪费比例的对象，分配成功有概率可以采集到，因为有一部分在TLAB内分配成功</li><li>这个<code>只会采集分配成功</code>的对象，对于大对象分配，如果触发 <code>OutOfMemoryError</code> 代表分配失败，那采集不到</li><li>比如前面的代码示例，可以看到 HashMap 不断扩容，但是如果扩容触发 OutOfMemoryError，那这次就采集不到，但是通过前面的事件也能推测出来</li></ul></li><li>Java 堆对象内存泄漏: 适合度50%。针对不断分配小对象并且不释放的场景比较合适。比如多线程不断向一个 ConcurrentHashMap 塞入对象，但是不释放，这个事件可以采集 ConcurrentHashMap 在不断扩容。</li><li><code>意想不到的大对象分配</code>: 适合度100%。可以定期回顾下这个事件的采集，看看有没有意想不到的大对象分配，以及是否可以优化，或者有利于加深对于JDK的理解</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationOutsideTLAB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Outside TLAB&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从哪个版本引入？&lt;ul&gt;
&lt;li&gt;Java11：即一开始就存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径三&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation In New TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/</id>
    <published>2025-02-22T06:20:52.000Z</published>
    <updated>2025-02-22T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><p><img data-src="/images/jfr/04.png" alt="img"><br><img data-src="/images/jfr/05.png" alt="img"></p><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationInNewTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation In New TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二分配的线程的名称</li><li>Allocation Size：触发路径二分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径二分配的对象类型</li><li>TLAB Size：触发路径二分配，申请新的TLAB的大小</li><li>线程栈：发生路径二的线程栈，默认是采集的<br><img data-src="/images/jfr/06.png" alt="img"></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocInNewTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于字节数组对象头占用16字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_ARRAY_OVERHEAD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 测试的对象大小是KB</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OBJECT_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 字节数组对象名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BYTE_ARRAY_CLASS_NAME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>].getClass().getName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[] 会被全部省略，只剩最后一次的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小1KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 强制 fullgc 回收所以 TLAB</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小100KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE * <span class="number">100</span> - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">      <span class="comment">// 统计事件类型</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf1KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf100KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 读取文件中的所有 JFR 事件</span></span><br><span class="line">      <span class="keyword">for</span> (RecordedEvent event : RecordingFile.readAllEvents(path)) &#123;</span><br><span class="line">          <span class="comment">// 获取分配的对象类型</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> event.getString(<span class="string">&quot;objectClass.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确保分配类型是byte</span></span><br><span class="line">          <span class="keyword">if</span> (BYTE_ARRAY_CLASS_NAME.equals(className)) &#123;</span><br><span class="line">              <span class="type">RecordedFrame</span> <span class="variable">recordedFrame</span> <span class="operator">=</span> event.getStackTrace().getFrames().get(<span class="number">0</span>);</span><br><span class="line">              <span class="comment">// 同时必须是main方法分配的对象，并且是java堆栈中的main方法</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                      recordedFrame.isJavaFrame()</span><br><span class="line">                              &amp;&amp; <span class="string">&quot;main&quot;</span>.equalsIgnoreCase(recordedFrame.getMethod().getName())</span><br><span class="line">              ) &#123;</span><br><span class="line">                  <span class="comment">// 获取分配对象大小</span></span><br><span class="line">                  <span class="type">long</span> <span class="variable">allocationSize</span> <span class="operator">=</span> event.getLong(<span class="string">&quot;allocationSize&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (EVENT_TYPE.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (allocationSize == OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf1KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allocationSize == <span class="number">100</span> * OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf100KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unexpected size of TLAB event&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(event);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;countOf1KBObjectAllocationInNewTLAB: &quot;</span> + countOf1KBObjectAllocationInNewTLAB);</span><br><span class="line">      System.out.println(<span class="string">&quot;countOf100KBObjectAllocationInNewTLAB: &quot;</span> + countOf100KBObjectAllocationInNewTLAB);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么针对大部分应用不建议开启这个事件的采集"><a href="#为什么针对大部分应用不建议开启这个事件的采集" class="headerlink" title="为什么针对大部分应用不建议开启这个事件的采集?"></a>为什么针对大部分应用不建议开启这个事件的采集?</h3><ul><li><code>路径二分配一般不是核心问题点</code><ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li><li><code>对于大部分应用，没有啥必要性</code><ul><li>重新申请 TLAB 分配，对于热点线程来说，虽然不如TLAB内分配那么多，但是也是比较频繁的</li><li>如果重新申请 TLAB 分配的次数，和 TLAB 内分配的次数差不多，这才会是问题</li><li>但是 TLAB 的大小是根据线程的分配情况动态调整的，所以 TLAB 内的分配的次数会比较多，而重新申请 TLAB 分配的次数会比较少</li><li>所以这个事件的采集，对于大部分的应用来说，并不是很有必要</li></ul></li><li><code>性能损耗</code><ul><li>这个事件的采集，会捕获堆栈信息，堆栈信息是比较耗性能的，如果开启这个事件的采集，会导致性能损耗比较大。并且这个事件的采集也相对频繁</li></ul></li></ul><h3 id="哪种情况下才会考虑开启这个事件的采集"><a href="#哪种情况下才会考虑开启这个事件的采集" class="headerlink" title="哪种情况下才会考虑开启这个事件的采集?"></a>哪种情况下才会考虑开启这个事件的采集?</h3><ul><li>正常的应用场景下，不需要调整TLAB的配置参数。一般情况下，JVM会根据应用的情况自动调整TLAB的大小</li><li>如果确实怀疑TLAB的配置参数有问题，第一步是开启 Java Application -&gt; Allocation In New TLAB(jdk.ObjectAllocationInNewTLAB) 和 Java Application -&gt;  Allocation outside TLAB(jdk.ObjectAllocationOutsideTLAB)</li><li>确认有大量的 Object Allocation Outside TLAB 事件发生（一般在应用稳定之后，如果很多线程的 Object Allocation Outside TLAB 相对于 Allocation In New TLAB 大于 5%以上就需要调整 TLAB 相关参数了），然后再考虑是否需要调整 TLAB 的配置参数。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/jfr/04.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;/images/jfr/05.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>Java对象分配过程</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/</id>
    <published>2025-02-22T06:13:52.000Z</published>
    <updated>2024-02-24T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路径一-TLAB-内分配"><a href="#路径一-TLAB-内分配" class="headerlink" title="路径一 TLAB 内分配"></a>路径一 TLAB 内分配</h3><ul><li>需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配</li><li>这是大多数对象的分配路径</li></ul><h3 id="路径二-申请新的-TLAB-分配"><a href="#路径二-申请新的-TLAB-分配" class="headerlink" title="路径二 申请新的 TLAB 分配"></a>路径二 申请新的 TLAB 分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间</li><li>重新分配一个 TLAB，然后在新的 TLAB 中分配</li></ul><h3 id="路径三-TLAB-外分配"><a href="#路径三-TLAB-外分配" class="headerlink" title="路径三 TLAB 外分配"></a>路径三 TLAB 外分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间</li><li>或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小</li><li>或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁</li><li>以上三种情况都会直接在堆上分配</li></ul><h3 id="路径四-分配前触发GC或者等待GC"><a href="#路径四-分配前触发GC或者等待GC" class="headerlink" title="路径四 分配前触发GC或者等待GC"></a>路径四 分配前触发GC或者等待GC</h3><ul><li>路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁</li><li>这种情况下，会 <code>触发GC</code>(serial&#x2F;parallel&#x2F;G1 GC) 或者<code>等待GC释放对象</code>(ZGC)</li><li>路基四如果太多，那其实可能是整体 Java 堆内存就设置的太小了，需要考虑扩容</li><li>如果用的是 SerialGC，ParallelGC，G1GC，那么路径四会产生 <code>Allocation Requiring GC</code></li><li>如果使用的是 ZGC，那么路径四会产生 <code>Z Allocation Stall</code></li><li>如果用的是 ShenandoahGC，路径四会导致 Degenerated GC，这个目前没有对应的 JFR 事件，可以通过 GC 相关的时间看到，但是目前看不到是哪个对象触发</li></ul><h3 id="为什么有个最大浪费空间？？"><a href="#为什么有个最大浪费空间？？" class="headerlink" title="为什么有个最大浪费空间？？"></a>为什么有个最大浪费空间？？</h3><ul><li>这是为了避免更有效的利用空间</li><li>假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择<ul><li>丢弃掉当前这个TLAB，去申请一个新的</li><li>不在当前这个TLAB上配置，去堆上分配</li><li>最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><ul><li>TLAB 是动态的，一般分配频繁的线程TLAB&#x3D;2M</li><li>每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;路径一-TLAB-内分配&quot;&gt;&lt;a href=&quot;#路径一-TLAB-内分配&quot; class=&quot;headerlink&quot; title=&quot;路径一 TLAB 内分配&quot;&gt;&lt;/a&gt;路径一 TLAB 内分配&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配&lt;/li&gt;
&lt;li&gt;这是大多数对象的分配路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;路径二-申请新的-TLAB-分配&quot;&gt;&lt;a href=&quot;#路径二-申请新的-TLAB-分配&quot; class=&quot;headerlink&quot; title=&quot;路径二 申请新的 TLAB 分配&quot;&gt;&lt;/a&gt;路径二 申请新的 TLAB 分配&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-准备工作</title>
    <link href="https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/</id>
    <published>2025-02-20T06:13:52.000Z</published>
    <updated>2025-02-20T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h2 id="为什么需要JFR"><a href="#为什么需要JFR" class="headerlink" title="为什么需要JFR?"></a>为什么需要JFR?</h2><h3 id="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式"><a href="#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式" class="headerlink" title="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式"></a>我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 <code>OpenTelemetry</code> 标准的监控方式</h3><ul><li>arthas: 主要用于实时定位问题，必须有问题线程，必须复现才能定位，没法事后定位，如果有应用问题也可能挂载不上。<br>JFR可以实现从JVM启动开始一直持续采集监控与事后定位，即使应用有问题卡住，也基本能通过JFR定位。</li><li>APM 框架: 例如 micrometer，open-telemetry，Skywalking 等等，大部分基于 <code>Java Agent</code> 和侵入代码的方式结合实现，<br>这些对于JFR来说：<ul><li>这些框架没办法采集JVM层面的指标</li><li>JVM协调安全点，JVM卡住，Java应用有问题，CPU吃满等等，这些框架会受很大影响</li></ul></li></ul><h3 id="结合学习-JVM-JDK-的最佳方式"><a href="#结合学习-JVM-JDK-的最佳方式" class="headerlink" title="结合学习 JVM + JDK 的最佳方式"></a>结合学习 JVM + JDK 的最佳方式</h3><ul><li>JFR 有哪些事件，为啥要采集这些事件</li><li>采集这些事件的机制</li><li>搞懂上面的问题，基本从 JVM 到 JDK 的任意一个细节都搞懂了，比如：<ul><li>JVM GC 的时候有哪些阶段，每个阶段耗时与做了什么？看 GC 相关 JFR 事件</li><li>JVM Safepoint 是啥，有啥原因会进入 safePoint？看 Safepoint 相关 JFR 事件</li><li>JDK 中的 AQS 究竟基于啥，实现原理是啥？看 Thread Park 事件属性与对应线程栈</li></ul></li></ul><h2 id="JFR-如何实现高效"><a href="#JFR-如何实现高效" class="headerlink" title="JFR 如何实现高效"></a>JFR 如何实现高效</h2><ul><li><img data-src="/images/jfr/01.png" alt="img"></li></ul><h2 id="JFR-如何从-JVM-启动一开始监控到任意时候"><a href="#JFR-如何从-JVM-启动一开始监控到任意时候" class="headerlink" title="JFR 如何从 JVM 启动一开始监控到任意时候"></a>JFR 如何从 JVM 启动一开始监控到任意时候</h2><blockquote><p>突破 JFR 本身限制，不用 dumponexit，不用主动 dump</p></blockquote><ul><li>JFR 写入磁盘的 Data Chunk，默认在临时目录(<code>java.io.tmpdir</code>)，这个可以通过<br>JFR 配置限制<ul><li><code>maxage</code>：限制保留的 JFR 事件的最早时间</li><li><code>maxsize</code>：限制保留在本地磁盘临时文件的最大总大小</li></ul></li><li>Java 14开始，增加了 JFR Event Streaming 机制<ul><li>写入的临时文件不再是.part，而是.jfr，这样即使JMC无法解析，也可以使用jfr命令解析</li><li>java 14 引入定时任务定时（默认1s）执行 JFR Flush 将元数据刷入本地文件 Data Chunk，这样大概率最新的文件就是数据完整的，即可以被JMC解析</li></ul></li></ul><h3 id="k8s环境下怎么监控jfr"><a href="#k8s环境下怎么监控jfr" class="headerlink" title="k8s环境下怎么监控jfr"></a>k8s环境下怎么监控jfr</h3><blockquote><p>JFR 与日志是同等定位，其实就是简单结构化的日志。先通过 Grafana 看 Metrics 指标，之后通过少量上报 span 大概定位时间段以及出问题的实例，最后看对应时段的 JFR</p></blockquote><p>升级了 SpringBoot 3.x，升级后，全面改造了原来的 Sleuth 以及 Micrometer 监控，最新的 io.micrometer.observation.Observation 抽象将链路追踪以及指标监控（opentracing 和 opentelemetry 两个标准）结合，这样，我们就可以在链路追踪中，同时记录指标监控数据了。<br>并且，在此基础上，我们还加入了全局的 io.micrometer.observation.ObservationHandler，用于在 Observation start 的时候，生成 JFR 事件，在 stop 的时候 commit JFR 事件。这样我们就实现了通过一个 Observation：</p><ul><li>暴露指标监控数据到 &#x2F;actuator&#x2F;prometheus，供 Prometheus 采集，Grafana 展示</li><li>上报链路追踪数据到 Grafana Tempo</li><li>生成 JFR 事件，供 JDK Mission Control 分析</li></ul><p>为什么要这么做呢？</p><ul><li>指标数据是统计数据，是聚合数据，是一段时间内的数据，而链路追踪数据是实时数据，是每个请求的数据</li><li>但是像是链路追踪上报在生产上肯定不能 100% 上报（上报性能，还有成本考虑，以及查询的存储性能有限，成本不能太高），而是采样上报，这样就会导致链路追数据不全</li><li>JFR 是保留详细数据的好选择，保留在本地，只有发生问题需要排查的时候，事后按需获取就行。</li><li>这样，既节约了成本，又能及时报警，又能容易通过 Tempo 通过链路追踪数据定位出问题的实例和时间段，然后通过获取对应实例的 JFR 事件定位详细问题。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Java-17-以上的-JDK"><a href="#Java-17-以上的-JDK" class="headerlink" title="Java 17 以上的 JDK"></a>Java 17 以上的 JDK</h3><blockquote><p>Azul、Corretto、OpenJdk随意</p></blockquote><h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><blockquote><p>下载最新版本即可，即 JMC 9</p></blockquote><h3 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h3><blockquote><p><code>WhiteBox API</code> 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的API暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解JVM并调优参数</p></blockquote><ul><li>编译 WhiteBox API<ol><li>拉取 openjdk 源码</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 --filter=blob:none --sparse https://github.com/openjdk/jdk</span><br><span class="line">cd jdk</span><br><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout set test/lib/jdk/test/whitebox</span><br></pre></td></tr></table></figure><ol start="2"><li>新建 maven 空项目，将刚刚拉取的代码复制进去，执行 <code>maven package</code> 即可</li><li>将编译的 jar 包放在项目根目录，通过 maven 本地 system 依赖的方式将 jar 包加入依赖<br><img data-src="/images/jfr/02.png" alt="img"></li><li>不想自己构建可以使用 <a href="/files/jfr/whitebox-1.0-SNAPSHOT.jar">whitebox-1.0-SNAPSHOT.jar</a></li><li>编写测试代码<ul><li>代码</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWhiteBox</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            主要用于添加WhiteBox测试API的jar包，这个jar必须通过引导类加载器加载，因为它需要访问JVM内部功能，/a 表示append，将指定的jar追加到引导类路径末尾</span></span><br><span class="line"><span class="comment">            -Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            解锁JVM诊断选项，启用一些默认被禁用的诊断/调试选项，这是使用WhiteBox API的前提条件</span></span><br><span class="line"><span class="comment">            -XX:+UnlockDiagnosticVMOptions</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            启用WhiteBox测试API，WhiteBox API提供了访问JVM内部状态的能力</span></span><br><span class="line"><span class="comment">            -XX:+WhiteBoxAPI</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            开启GC日志记录，输出带有gc标签的日志</span></span><br><span class="line"><span class="comment">            -Xlog:gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 获取 ReservedCodeCacheSize 这个 JVM flag 的值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">reservedCodeCacheSize</span> <span class="operator">=</span> whiteBox.getUintxVMFlag(<span class="string">&quot;ReservedCodeCacheSize&quot;</span>);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        <span class="comment">// 打印内存各项指标</span></span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        <span class="comment">// 执行 full GC</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        <span class="comment">// 保持进程不退出，打印完整日志</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动VM Options</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure><ul><li>执行结果，出现 NoSuchMethodError 错误没关系，因为打包的是最新的 whitebox，使用的jdk版本可能没有某些最新的api<br><img data-src="/images/jfr/03.png" alt="img"></li></ul></li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么需要JFR&quot;&gt;&lt;a href=&quot;#为什么需要JFR&quot; class=&quot;headerlink&quot; title=&quot;为什么需要JFR?&quot;&gt;&lt;/a&gt;为什么需要JFR?&lt;/h2&gt;&lt;h3 id=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot;&gt;&lt;a href=&quot;#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot; class=&quot;headerlink&quot; title=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式&quot;&gt;&lt;/a&gt;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 &lt;code&gt;OpenTelemetry&lt;/code&gt; 标准的监控方式&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 单元测试最佳实践</title>
    <link href="https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/</id>
    <published>2025-02-19T15:55:22.000Z</published>
    <updated>2025-02-19T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>标题党，各位大佬手下留情<del>_</del></p></blockquote><p>单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)</p><blockquote><p>!! 笔者使用的是 2.6.6 版本</p></blockquote><p><img data-src="/images/spring/boot/01.png" alt="image.png"></p><blockquote><p>SpringBoot 常规单元测试</p></blockquote><p>常规的单元测试如下图所示，这样会将整个容器启动起来，需要加载各种各样的外部化配置，耗时时间长且容易失败；大部分场景下我们只是测试某个功能，只需加载部分组件即可</p><p><img data-src="/images/spring/boot/02.png" alt="image.png"></p><blockquote><p>SpringBoot 单元测试指定加载配置</p></blockquote><p>为了解决以上问题，我们可以指定配置进行加载，避免加载整个容器；如下图所示，只会加载基础的Spring容器以及IdGenerator，大大提升了单测的效率</p><p><code>推荐学习</code><a href="https://github.com/chanjarster/spring-test-examples">spring-test-examples</a></p><p><img data-src="/images/spring/boot/03.png" alt="image.png"></p><blockquote><p>SprongBoot 固定组件单元测试</p></blockquote><p>以上指定配置加载已经基本满足了我们的需求(加载部分组件)；但在日常开发中，要求每次单测都指定加载的配置本身就是个伪命题，一是因为本身开发可能对于需要加载的配置不太熟悉，二是因为这种重复的工作过于啰嗦；那么我们该怎么优化这个流程呢？</p><ol><li>要简化配置，第一步就是禁用所有自动加载的配置</li></ol><ul><li>仿造<code>SpringBootTest</code>的注解，构建一个元注解，禁用所有自动加载的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(EmptyTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(EmptyTypeExcludeFilter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestEmptyEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTestContextBootstrapper</span> <span class="keyword">extends</span> <span class="title class_">SpringBootTestContextBootstrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getProperties(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestEmptyEnvironment</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">        <span class="keyword">return</span> (annotation != <span class="literal">null</span>) ? annotation.properties() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTypeExcludeFilter</span> <span class="keyword">extends</span> <span class="title class_">AnnotationCustomizableTypeExcludeFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEmptyEnvironment annotation;</span><br><span class="line"></span><br><span class="line">    EmptyTypeExcludeFilter(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ComponentScan.Filter[] getFilters(<span class="keyword">final</span> FilterType type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> INCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.includeFilters();</span><br><span class="line">            <span class="keyword">case</span> EXCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.excludeFilters();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported type &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation.useDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getDefaultIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getComponentIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>TestEmptyEnvironment</strong>: 禁用所有自动配置，只加载最基础的spring容器</li><li><strong>EmptyTestContextBootstrapper</strong>: 重写properties加载方法，将TestEmptyEnvironment注解中的properties属性加载到容器中</li><li><strong>EmptyTypeExcludeFilter</strong>: 容器过滤</li><li><strong>@OverrideAutoConfiguration(enabled &#x3D; false)</strong>: 禁用自动配置加载，如果是boot2.2.x之前的版本，此配置不会生效，可以使用 @ContextConfiguration(classes &#x3D; EmptyConfiguration.class) 替代，其中 EmptyConfiguration 表示空的配置</li></ul><ol start="2"><li>要简化单测的流程，就需要将重复的工作声明化，即使用注解完成自动配置的大部分工作；具体需要如何处理呢，我们可以将常用单测注解进行声明化处理，编写单测时只需引入对应组件的注解即可</li></ol><ul><li><strong>service</strong> 仅对service进行单测，可声明以下注解，构建一个简单的spring容器即可，需要测试哪个service，直接Import加载即可；若此service中有其他注解，可进行mock处理，这里不再赘述mock的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TestService</span></span><br><span class="line"><span class="comment">// 若是boot2.2.x之后这里不再需要，因为元注解中已经增加了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// @RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;</span></span><br><span class="line"><span class="meta">        LabelService.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LabelService labelService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>redis</strong> 对redis进行单测，需要引入redis相关的自动配置，如下代码中的 RedisTestAutoConfiguration 类，不同项目使用的框架不同，自动装配也不相同，这里需要根据项目进行个性化设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        RedisTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRedis &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        LettuceAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRedis</span></span><br><span class="line"><span class="comment">// 优先级最高，可覆盖项目中的配置文件</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;</span></span><br><span class="line"><span class="meta">        &quot;redis.host=localhost:6379&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getRedisHost</span><span class="params">()</span> &#123;</span><br><span class="line">        assertThat(redisClient)</span><br><span class="line">        .isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>kafka</strong> kafka单测也和redis一样，进行个性化配置即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestKafka &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其他组件也都是一样的做法，笔者暂时用到的组件如下<ul><li>feign</li><li>kafka</li><li>mongodb</li><li>redis</li><li>service</li><li>controller</li><li>mybatis</li></ul></li></ul><p>tips: 如果不知道组件需要加载哪些配置，可通过完整启动项目打印所有装配的配置，然后再筛选需要的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderPrint</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;标题党，各位大佬手下留情&lt;del&gt;_&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;!! 笔者使用的是 2.6.6 版本&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/categories/spring-boot/"/>
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
    <category term="单元测试" scheme="https://taeyang0126.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>rocksdb</title>
    <link href="https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/</id>
    <published>2025-02-19T15:52:22.000Z</published>
    <updated>2025-02-19T15:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h4><p><img data-src="/images/db/rocksdb/image1.png" alt="image1.png"></p><h4 id="数据读取流程"><a href="#数据读取流程" class="headerlink" title="数据读取流程"></a>数据读取流程</h4><p><img data-src="/images/db/rocksdb/image2.png" alt="image2.png"></p><h4 id="db-相关属性"><a href="#db-相关属性" class="headerlink" title="db 相关属性"></a>db 相关属性</h4><table><thead><tr><th>类别</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>总体统计</td><td>rocksdb.stats</td><td>提供详细的数据库统计信息，包括压缩、读写操作、块缓存等数据</td></tr><tr><td>数据库大小</td><td>rocksdb.total-sst-files-size</td><td>所有 SST 文件的总大小</td></tr><tr><td></td><td>rocksdb.estimate-table-readers-mem</td><td>估计表读取器使用的内存</td></tr><tr><td></td><td>rocksdb.estimate-live-data-size</td><td>估计的活跃数据大小</td></tr><tr><td>内存使用</td><td>rocksdb.cur-size-all-mem-tables</td><td>所有 MemTable 的当前大小</td></tr><tr><td></td><td>rocksdb.block-cache-usage</td><td>块缓存的使用量</td></tr><tr><td>压缩</td><td>rocksdb.background-errors</td><td>后台工作（如压缩）中的错误数</td></tr><tr><td></td><td>rocksdb.num-running-compactions</td><td>当前运行的压缩任务数</td></tr><tr><td>写入</td><td>rocksdb.num-immutable-mem-table</td><td>不可变 MemTable 的数量</td></tr><tr><td></td><td>rocksdb.mem-table-flush-pending</td><td>是否有待处理的 MemTable 刷新</td></tr><tr><td></td><td>rocksdb.is-write-stopped</td><td>写入是否已停止</td></tr><tr><td></td><td>rocksdb.actual-delayed-write-rate</td><td>实际的延迟写入速率</td></tr><tr><td>读取</td><td>rocksdb.estimate-num-keys</td><td>估计的键数量</td></tr><tr><td>文件</td><td>rocksdb.num-files-at-level<N></td><td>第 N 层的文件数量（如 rocksdb.num-files-at-level0）</td></tr><tr><td></td><td>rocksdb.live-sst-files-size</td><td>活跃 SST 文件的大小</td></tr></tbody></table><p>注意：</p><ol><li>使用方法示例：<code>String value = db.getProperty(&quot;rocksdb.stats&quot;);</code></li><li>某些属性可能会影响性能，应谨慎使用。</li><li>属性值可能会频繁变化，建议定期获取以监控趋势。</li><li>在生产环境中使用时，可能需要限制获取这些属性的频率。</li></ol><h4 id="事务操作使用场景"><a href="#事务操作使用场景" class="headerlink" title="事务操作使用场景"></a>事务操作使用场景</h4><ul><li>为单个 key 提供并发控制<ol><li>事务开始时获取逻辑锁</li><li>提交时检查冲突</li><li>避免显式锁定，提高并发性</li><li>减少死锁风险</li><li>计数器更新</li><li>用户状态修改</li></ol></li><li>确保多个 key 的一致性更新<ol><li>将多个 key 操作组合为单一事务</li><li>全部成功或全部失败</li><li>维护相关数据的一致性</li><li>简化复杂操作的实现</li><li>用户注册（创建账户 + 初始化设置）</li><li>订单处理（更新库存 + 记录订单）</li></ol></li></ul><h4 id="RocksDB-默认冲突检测机制"><a href="#RocksDB-默认冲突检测机制" class="headerlink" title="RocksDB 默认冲突检测机制"></a>RocksDB 默认冲突检测机制</h4><h5 id="事务间冲突检测"><a href="#事务间冲突检测" class="headerlink" title="事务间冲突检测"></a>事务间冲突检测</h5><ol><li>触发时机：事务提交时</li><li>检测对象：活跃事务之间的写集</li><li>检测方式：<ol><li>每个事务的 put 操作都会记录在写集中</li><li>提交时检查本事务的写集是否与其他活跃事务的写集冲突</li><li>结果：如果发现冲突，后提交的事务通常会失败</li></ol></li></ol><h5 id="非事务性写入检测"><a href="#非事务性写入检测" class="headerlink" title="非事务性写入检测"></a>非事务性写入检测</h5><ol><li>触发时机：执行非事务性写入时（如 txnDb.put()）</li><li>检测对象：所有活跃事务的锁和写意图</li><li>检测方式：<ol><li>检查目标键是否被任何活跃事务锁定</li><li>检查是否有活跃事务对该键有写意图</li><li>结果：如果存在冲突，非事务性写入会失败并抛出异常</li></ol></li></ol><h5 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h5><ol><li>写意图（Write Intents）：事务执行写操作时登记，用于冲突检测</li><li>锁定机制：事务的 put 操作会为相应的键设置锁</li><li>快照隔离：事务开始时获取数据快照，影响可见的数据版本</li><li>乐观并发控制（默认）：大多数冲突检测在提交时进行</li><li>悲观锁定（可配置）：启用后，冲突检测在写操作执行时就会进行</li></ol><h4 id="RocksDB-读取策略"><a href="#RocksDB-读取策略" class="headerlink" title="RocksDB 读取策略"></a>RocksDB 读取策略</h4><h5 id="读已提交-默认"><a href="#读已提交-默认" class="headerlink" title="读已提交(默认)"></a>读已提交(默认)</h5><p>内部事务对于外部事务提交的立马可见</p><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readOptions.setSnapshot(snapshot);</span><br></pre></td></tr></table></figure><p>快照读类比于读已提交，对于外部事务只能看到当前快照创建时提交的数据，对于当前事务，所有写入都是可见的</p><h4 id="RocksDB-事务版本号管理"><a href="#RocksDB-事务版本号管理" class="headerlink" title="RocksDB 事务版本号管理"></a>RocksDB 事务版本号管理</h4><ul><li>对于冲突检测来说，使用事务开始时的快照序列号作为基准，比较操作键的当前序列号与快照序列号</li><li>对于提交来说，获取新的全局序列号作为起始点，将事务内部的临时序列号映射到连续的全局序列号，最终序列号 &#x3D; 新全局序列号 + 临时序列号偏移</li><li>所以会出现某个事务过程中，外部事务修改了键，内部事务再使用getForUpdate就会报错，因为比较实用的是快照的序列号</li><li>getForUpdate还有个好处就是能检测外部非事务性操作，因为本质上使用的是序列号比较，所以能检测，但是默认的写写冲突是无法检测的，因为默认是读已提交，rocksdb认为这是合理的，内部事务会覆盖外部事物的值</li></ul><table><thead><tr><th>方面</th><th>描述</th></tr></thead><tbody><tr><td>全局序列号</td><td>- 全局递增的序列号作为版本标识<br>- 每次非事务写入或事务提交时分配</td></tr><tr><td>事务开始</td><td>- 创建数据库快照<br>- 记录当前最大序列号作为事务”基线”</td></tr><tr><td>读操作</td><td>- 使用事务开始时的快照序列号<br>- 只读取序列号≤快照序列号的数据</td></tr><tr><td>写操作</td><td>- 不立即分配全局序列号<br>- 事务内部使用临时本地序列号</td></tr><tr><td>事务提交</td><td>- 获取新的全局序列号<br>- 将事务内写操作映射到连续的全局序列号<br>- 用新序列号更新数据库</td></tr><tr><td>回滚处理</td><td>- 丢弃事务内的所有本地序列号<br>- 不影响全局序列号</td></tr><tr><td>冲突检测</td><td>- 读写冲突：比较快照序列号与当前数据序列号<br>- 写写冲突：提交时检查数据是否被其他事务修改</td></tr><tr><td>OptimisticTransactionDB</td><td>- 延迟冲突检测到提交阶段<br>- 提交时比较数据当前序列号与事务开始序列号</td></tr><tr><td>TransactionDB</td><td>- 可能在操作过程中进行冲突检测<br>- 使用锁机制预防冲突</td></tr><tr><td>隔离级别影响</td><td>- 读已提交：每次读操作使用最新快照<br>- 可重复读：整个事务使用开始时的快照<br>- 快照隔离：类似可重复读，但有额外写冲突检测</td></tr><tr><td>注意事项</td><td>- 版本号管理是实现 MVCC 的基础<br>- 有助于理解和处理事务冲突和并发问题</td></tr></tbody></table><h4 id="getForUpdate总结"><a href="#getForUpdate总结" class="headerlink" title="getForUpdate总结"></a>getForUpdate总结</h4><ol><li>用来解决读写冲突，这里的冲突可以是事务与其他事务之间，也可以是事务与非事务操作之间</li><li>我认为是使用序列号进行检测的，当前快照的序列号与键的序列号之间的比较判断是否冲突</li><li>对于OptimisticTransactionDB和TransactionDB检测的时机不一样，前者属于乐观型的，在commit才会检测，后者会立即检测</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;数据写入流程&quot;&gt;&lt;a href=&quot;#数据写入流程&quot; class=&quot;headerlink&quot; title=&quot;数据写入流程&quot;&gt;&lt;/a&gt;数据写入流程&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;/images/db/rocksdb/image1.png&quot; alt=&quot;image1.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据读取流程&quot;&gt;&lt;a href=&quot;#数据读取流程&quot; class=&quot;headerlink&quot; title=&quot;数据读取流程&quot;&gt;&lt;/a&gt;数据读取流程&lt;/h4&gt;</summary>
    
    
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/categories/rocksdb/"/>
    
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/tags/rocksdb/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/</id>
    <published>2025-02-19T14:51:22.000Z</published>
    <updated>2025-02-19T14:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-执行命令编译"><a href="#1-执行命令编译" class="headerlink" title="1. 执行命令编译"></a>1. 执行命令编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=./src/main/java ./proto3/User.proto</span><br></pre></td></tr></table></figure><h4 id="2-通过maven插件"><a href="#2-通过maven插件" class="headerlink" title="2. 通过maven插件"></a>2. 通过maven插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断系统--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Protobuf Maven 插件</span></span><br><span class="line"><span class="comment">        作用：</span></span><br><span class="line"><span class="comment">             - 自动下载和使用 protoc 编译器</span></span><br><span class="line"><span class="comment">             - 编译 .proto 文件生成 Java 代码</span></span><br><span class="line"><span class="comment">             - 集成到 Maven 生命周期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- protoc 编译器配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- proto 文件源目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>$&#123;project.basedir&#125;/src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的 Java 代码输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/protobuf/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否清空输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>true<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-proto3"><a href="#3-proto3" class="headerlink" title="3. proto3"></a>3. proto3</h4><ul><li>所有字段都有默认值，比如string默认为空串</li><li>因为有默认值，所以所有的字段都是不为null的，需要判断是否为空，hasXXX()、getCount() &gt; 0 等等进行判断</li><li>使用 1-15 的字段号给最常用的字段  （频繁访问的字段放在前面，cpu缓存命中率更高）</li><li>不常用字段使用 16+ 的字段号  （不常访问的字段放在后面）</li><li>对于较小范围的数字，用 int32 而不是 int64</li><li>固定长度的数字用 fixed32&#x2F;fixed64</li><li>对于负数多的场景用 sint32&#x2F;sint64</li><li>字段更新规则！！<ol><li>添加新字段</li><li>删除字段(但保留字段号)</li><li>重命名字段(字段号不变)</li><li>添加repeated字段   reserved 2, 15, 9 to 11;       &#x2F;&#x2F; 保留字段号  reserved “foo”, “bar”;         &#x2F;&#x2F; 保留字段名</li></ol></li><li>字段不能做的更新规则！！<ol><li>改变已有字段的类型</li><li>复用已删除的字段号</li><li>改变已有字段的编号</li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-执行命令编译&quot;&gt;&lt;a href=&quot;#1-执行命令编译&quot; class=&quot;headerlink&quot; title=&quot;1. 执行命令编译&quot;&gt;&lt;/a&gt;1. 执行命令编译&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protoc --java_out=./src/main/java ./proto3/User.proto&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-通过maven插件&quot;&gt;&lt;a href=&quot;#2-通过maven插件&quot; class=&quot;headerlink&quot; title=&quot;2. 通过maven插件&quot;&gt;&lt;/a&gt;2. 通过maven插件&lt;/h4&gt;</summary>
    
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/categories/protobuf/"/>
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/tags/protobuf/"/>
    
    <category term="序列化" scheme="https://taeyang0126.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
