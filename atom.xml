<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WL&#39;s blog</title>
  
  
  <link href="https://taeyang0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://taeyang0126.github.io/"/>
  <updated>2025-02-22T07:25:52.000Z</updated>
  <id>https://taeyang0126.github.io/</id>
  
  <author>
    <name>WU LEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM与JFR事件-你可能没必要 Heap Dump</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/</id>
    <published>2025-02-22T07:25:52.000Z</published>
    <updated>2025-02-22T07:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><blockquote><p>很多情况会导致 Java 应用抛出 <code>OutOfMemoryError</code> <a href="https://zhuanlan.zhihu.com/p/265039643">参考 StackOverflowError 与 OutOfMemoryError</a></p></blockquote><h4 id="会触发HeapDumpOnOutOfMemoryError"><a href="#会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="会触发HeapDumpOnOutOfMemoryError"></a>会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><code>OutOfMemoryError: Java heap space</code> 和 <code>OutOfMemoryError: GC overhead limit exceeded</code> ：这两个都是 Java 对象堆内存不够了，一个是分配的时候发现剩余空间不足，一个是到达某一界限</li><li><code>OutOfMemoryError: Requested array size exceeds VM limit</code> ：当申请的数组大小超过堆内存限制，就会抛出这个异常</li><li><code>OutOfMemoryError: Compressed class space</code> 和 <code>OutOfMemoryError: Metaspace</code> ：这两个都和元空间相关（<a href="https://juejin.cn/post/7225879724545835045">底层原理</a>）</li><li><code>Shenandoah</code> 分配区域位图，内存的时候，触发的 OutOfMemoryError</li></ul><h4 id="不会触发HeapDumpOnOutOfMemoryError"><a href="#不会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="不会触发HeapDumpOnOutOfMemoryError"></a>不会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><strong>OutOfMemoryError: unable to create native thread</strong> ：无法创建新的平台线程</li><li><strong>OutOfMemoryError: Cannot reserve xxx bytes of direct buffer memory (allocated: xxx, limit: xxx)</strong> ：在 DirectByteBuffer 中，首先向 Bits 类申请额度， Bits 类有一个全局的 totalCapacity 变量，记录着全部DirectByteBuffer 的总大小，每次申请，都先看看是否超限，可用 <code>-XX:MaxDirectMemorySize</code> 限制（未指定默认与-Xmx相同）</li><li><strong>OutOfMemoryError: map failed</strong> ：这个是 File MMAP （文件映射内存）时，如果系统内存不足，就会抛出这个异常</li><li>OutOfMemoryError: Native heap allocation failed ，这个 Message 可能不同操作系统不一样，但是一般都有 native heap 。这个就和 Java 对象堆一般没关系，而是其他块内存无法申请导致的</li></ul><h3 id="为什么不建议打开HeapDumpOnOutOfMemoryError"><a href="#为什么不建议打开HeapDumpOnOutOfMemoryError" class="headerlink" title="为什么不建议打开HeapDumpOnOutOfMemoryError"></a>为什么不建议打开<code>HeapDumpOnOutOfMemoryError</code></h3><h4 id="HeapDumpOnOutOfMemoryError-的原理"><a href="#HeapDumpOnOutOfMemoryError-的原理" class="headerlink" title="HeapDumpOnOutOfMemoryError 的原理"></a><code>HeapDumpOnOutOfMemoryError</code> 的原理</h4><ul><li>进入安全点，所有应用线程暂停，针对 HeapDumpOnOutOfMemoryError，单线程（如果是 jcmd jmap 可以多线程）dump 堆为线程个数个文件。退出安全点。</li><li>将上面的多个文件，合并为一个，压缩。</li></ul><h4 id="HeapDumpOnOutOfMemoryError-的瓶颈"><a href="#HeapDumpOnOutOfMemoryError-的瓶颈" class="headerlink" title="HeapDumpOnOutOfMemoryError 的瓶颈"></a><code>HeapDumpOnOutOfMemoryError</code> 的瓶颈</h4><blockquote><p>这里的瓶颈主要在于第一步写入，并且，主要瓶颈在磁盘 IO</p></blockquote><ul><li><a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html">AWS EFS （普通存储）</a></li><li><a href="https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html">AWS EBS （对标 SSD ）</a></li><li>对于一个 4G 大小的 Java 对象堆内存，如果是 EFS ，对标的应该是 100G 以内的磁盘，写入最少<br>也需要大概 4 * 1024 &#x2F; 300 &#x3D; 13.65 秒（注意，这个是峰值性能），如果当时峰值性能被用完了，那<br>么需要： 4 * 1024 &#x2F; 15 &#x3D; 273 秒。如果用 EBS ，那么也需要 4 * 1024 &#x2F; 1000 &#x3D; 4 秒。注意，这个<br>计算的时间，是应用线程个完全处于安全点（即 Stop-the-world ）的时间，还没有考虑一个<br>机器上部署多个容器实例的情况，考虑成本我们也不能堆每个微服务都使用 AWS EBS 这种（对标<br>SSD ）。所以，建议还是不要打开 <code>HeapDumpOnOutOfMemoryError</code></li></ul><h3 id="为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？"><a href="#为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？" class="headerlink" title="为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？"></a>为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？</h3><h4 id="大对象分配导致的问题"><a href="#大对象分配导致的问题" class="headerlink" title="大对象分配导致的问题"></a>大对象分配导致的问题</h4><h5 id="jfr配置"><a href="#jfr配置" class="headerlink" title="jfr配置"></a>jfr配置</h5><ul><li>jfc配置文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">configuration</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>5/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>ObjectAllocationOutsideTLAB：TLAB外的分配</li><li>ObjectAllocationSample：TLAB外的以及申请新的TLAB的采样</li><li>AllocationRequiringGC：某个对象分配失败导致gc采集，针对serial、parallel、G1 gc</li><li>ZAllocationStall：ZGC中使用，当一个线程分配对象发现内存不够了，就会阻塞，从而生成此事件。”threshold”&gt;0 阻塞0ms以上都采集<br>ZGC Allocation Stall事件为啥看不到触发内存溢出的业务代码呢？jdk23才可以</li><li>JVM参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stackdepth=256 是为了演示效果，一般不需要这么大</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxchunksize=128m 是为了演示效果，一般不需要这么大</span></span><br><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br></pre></td></tr></table></figure></li></ul><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote><p>某个请求有 bug，导致全表扫描，冲爆了 Java 对象堆内存。抛出了 OutOfMemoryError ，但是这是异常情况，可能无法输出堆栈日志，在茫<br>茫众多的请求中很难找到这个请求</p></blockquote><ul><li>模拟了一个方法，从db返回结果非常大，直接导致OOM，输出的jfr如下</li><li><img data-src="/images/jfr/08.png" alt="img"></li><li><img data-src="/images/jfr/09.png" alt="img"></li><li>ZGC查看如下图<br><img data-src="/images/jfr/10.png" alt="img"></li></ul><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote><p>用户累计订单量随着你的系统成熟越来越多，大历史订单量的用户越来越多。之前的代码有 bug ，用户订单列表实际是拉取每个用户的所有订单<br>内存分页。可能两个大历史订单量的用户同时查询的时候就会抛出 OutOfMemoryError ，就算不抛出也会频繁 GC 影响性能。</p></blockquote><ul><li>模拟了一个方法，多个大订单量的用户并发查询，可能没有导致OOM，但是会频繁的GC，输出的jfr如下</li><li><img data-src="/images/jfr/11.png" alt="img"></li><li><img data-src="/images/jfr/12.png" alt="img"></li></ul><h4 id="小对象分配导致的问题"><a href="#小对象分配导致的问题" class="headerlink" title="小对象分配导致的问题"></a>小对象分配导致的问题</h4><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote><p>某个请求会触发分配一个小对象放入类似于缓存的地方，但是这个小对象一直没有被回收，日积月累导致 FullGC 越来越频繁，最后<br>OutOfMemoryError</p></blockquote><ul><li>这种情况，可能导致 JFR 事件丢失，但是大概率不影响我们定位问题，因为是一连串的趋势可以看<br>出来</li><li><img data-src="/images/jfr/13.png" alt="img"></li><li><img data-src="/images/jfr/14.png" alt="img"></li></ul><h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote><p>由于虚拟线程的引入，原来进程内处理请求的数量一定程度受限于 IO 以及线程数量，现在则是受限于 Java 对象堆内存大小，如何识别这种<code>背压</code>问题。</p></blockquote><h3 id="为什么抛出-OutOfMemoryError-的微服务最好下线重启？"><a href="#为什么抛出-OutOfMemoryError-的微服务最好下线重启？" class="headerlink" title="为什么抛出 OutOfMemoryError 的微服务最好下线重启？"></a>为什么抛出 OutOfMemoryError 的微服务最好下线重启？</h3><ul><li>因为包括 JDK 的源码在内，都没有在每一个分配内存的代码的地方考虑会出现 OutOfMemoryError ，这样会导致代码<br>状态不一致，例如 hashmap 的 rehash ，如果里面某行抛出 OutOfMemoryError ，前面更新的状态就不对了。</li><li>还有其他很多库，就不用说了，都很少有 catch Throwable 的，大部分是 catch Exception 的。并且，在每一个分配内<br>存的代码的地方考虑会出现 OutOfMemoryError 也是不现实的，所以为了防止 OutOfMemoryError 带来意想不到的<br>一致性问题，还是下线重启比较好。</li></ul><h3 id="如何实现抛出-OutOfMemoryError-的微服务下线重启？"><a href="#如何实现抛出-OutOfMemoryError-的微服务下线重启？" class="headerlink" title="如何实现抛出 OutOfMemoryError 的微服务下线重启？"></a>如何实现抛出 OutOfMemoryError 的微服务下线重启？</h3><ul><li>一般通过 -XX:OnOutOfMemoryError&#x3D;”&#x2F;path&#x2F;to&#x2F;script.sh” 指定脚本，脚本执行<ul><li>微服务的下线</li><li>微服务的重启(可以依赖k8s)</li></ul></li><li>针对 spring boot ，可以考虑开启允许本地访问 &#x2F;actuator&#x2F;shutdown 来关闭微服务（有群友反应抛出<br>OutOfMemoryError 的时候调用这个会卡死，这是因为前面说的原因，你可能开启了<br>HeapDumpOnOutOfMemoryError 导致的）， k8s 会自动拉起一个新的。<ul><li>因为<code>HeapDump</code>需要进入安全点，所有线程都 STW 了，导致k8s健康检查失败，从而k8s会自动拉起一个新的，导致dump失败</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;OutOfMemoryError&quot;&gt;&lt;a href=&quot;#OutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;OutOfMemoryError&quot;&gt;&lt;/a&gt;OutOfMemoryError&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多情况会导致 Java 应用抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/265039643&quot;&gt;参考 StackOverflowError 与 OutOfMemoryError&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;会触发HeapDumpOnOutOfMemoryError&quot;&gt;&lt;a href=&quot;#会触发HeapDumpOnOutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;会触发HeapDumpOnOutOfMemoryError&quot;&gt;&lt;/a&gt;会触发&lt;code&gt;HeapDumpOnOutOfMemoryError&lt;/code&gt;&lt;/h4&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="OOM" scheme="https://taeyang0126.github.io/tags/OOM/"/>
    
    <category term="Heap Dump" scheme="https://taeyang0126.github.io/tags/Heap-Dump/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Outside TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/</id>
    <published>2025-02-22T06:25:52.000Z</published>
    <updated>2025-02-22T06:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): jdk.ObjectAllocationOutsideTLAB</li><li>Label(Event Type，用于显示): Object Allocation Outside TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>此事件对应 <code>Java 对象分配过程</code> 中的路径三</li><li>事件字段<ul><li>Event Thread：发生路径三分配的线程的名称</li><li>Allocation Size：触发路径三分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径三分配的对象类型</li><li>线程栈：发生路径三的线程栈，默认是采集的<br><img data-src="/images/jfr/07.png" alt="img"></li></ul></li><li>编写代码模拟内存泄漏业务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocOutsideTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，三个线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">bizRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">              <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                  objects.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;biz-&quot;</span> + i)</span><br><span class="line">                      .unstarted(bizRunnable);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(bizRunnable);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                  threads[i].interrupt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">oomRun</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">              map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;oom-&quot;</span> + i)</span><br><span class="line">                      .unstarted(oomRun);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(oomRun);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="是否建议开启这个事件的采集"><a href="#是否建议开启这个事件的采集" class="headerlink" title="是否建议开启这个事件的采集"></a>是否建议开启这个事件的采集</h3><ul><li>建议开启<ul><li>上面提到的Java内存分配路径，对于一般的JVM应用，<code>TLAB</code>内分配的量远大于申请新的TLAB分配的量，同时申请新的TLAB的量又远大于在TLAB外分配的量。除非你的应用分配大量的大对象，否则这个事件发生的应该比较少</li><li>对于一般的JVM应用，建议还是开启这个事件的采集，这样能采集到在你应用的所有大对象分配。只要你的应用不是大对象分配过多，这个事件的采集对于性能的影响应该是可以接受的。</li><li>路径三分配一般会包含核心问题点：<ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li></ul></li><li>与其他哪些事件是否有重合<ul><li><code>Object Allocation Sample</code>: 虽然 Object Allocation Sample 官方默认开启，但是对于大部分小对象朝生夕死的应用，其实更应该开启 Object Allocation Outside TLAB，而不是Object Allocation Sample。大部分应用，采集到的 Object Allocation Outside TLAB 会比默认的 Object Allocation Sample 少很多很多，性能消耗小很多很多。建议将 Object Allocation Sample 的采样率调很低，主要用于看意向不到的对象分配。</li><li><code>Allocation Requiring GC 以及 ZAllocation Stall</code>: 后续分析这些事件我们会看到，有内存泄漏嫌疑的对象分配相关的对象分配路径，基本上很少会被这两个事件以及 Object Allocation Outside TLAB 采集到</li></ul></li></ul><h3 id="这个事件适合定位什么问题？"><a href="#这个事件适合定位什么问题？" class="headerlink" title="这个事件适合定位什么问题？"></a>这个事件适合定位什么问题？</h3><ul><li>大对象分配：适合度70%<ul><li>对于大于TLAB大小的对象，如果分配成功一定可以采集到</li><li>对于大于TLAB最大浪费比例的对象，分配成功有概率可以采集到，因为有一部分在TLAB内分配成功</li><li>这个<code>只会采集分配成功</code>的对象，对于大对象分配，如果触发 <code>OutOfMemoryError</code> 代表分配失败，那采集不到</li><li>比如前面的代码示例，可以看到 HashMap 不断扩容，但是如果扩容触发 OutOfMemoryError，那这次就采集不到，但是通过前面的事件也能推测出来</li></ul></li><li>Java 堆对象内存泄漏: 适合度50%。针对不断分配小对象并且不释放的场景比较合适。比如多线程不断向一个 ConcurrentHashMap 塞入对象，但是不释放，这个事件可以采集 ConcurrentHashMap 在不断扩容。</li><li><code>意想不到的大对象分配</code>: 适合度100%。可以定期回顾下这个事件的采集，看看有没有意想不到的大对象分配，以及是否可以优化，或者有利于加深对于JDK的理解</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): jdk.ObjectAllocationOutsideTLAB&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Outside TLAB&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从哪个版本引入？&lt;ul&gt;
&lt;li&gt;Java11：即一开始就存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;default.jfc 配置&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationOutsideTLAB&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;enabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;control&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;gc-enabled-high&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;stackTrace&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Profiling.jfc 配置&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationOutsideTLAB&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;enabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;control&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;gc-enabled-high&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;stackTrace&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;code&gt;Java 对象分配过程&lt;/code&gt; 中的路径三&lt;/li&gt;
&lt;li&gt;事件字段&lt;ul&gt;
&lt;li&gt;Event Thread：发生路径三分配的线程的名称&lt;/li&gt;
&lt;li&gt;Allocation Size：触发路径三分配的对象大小（实际占用，考虑了对象对其）&lt;/li&gt;
&lt;li&gt;Object Class：触发路径三分配的对象类型&lt;/li&gt;
&lt;li&gt;线程栈：发生路径三的线程栈，默认是采集的&lt;br&gt;&lt;img data-src=&quot;/images/jfr/07.png&quot; alt=&quot;img&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编写代码模拟内存泄漏业务&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;TestAllocOutsideTLAB&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;EVENT_TYPE&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationOutsideTLAB&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, IOException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;WhiteBox&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;whiteBox&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; WhiteBox.getWhiteBox();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 初始化jfr记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Recording&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;recording&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Recording&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.enable(EVENT_TYPE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// JFR 记录启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 强制 fullgc 防止程序接下来发生 gc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 同时可以区分初始化带来的其他线程的TLAB相关的日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      whiteBox.fullGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 模拟正常业务运行分配对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      runBiz(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      TimeUnit.SECONDS.sleep(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Start to create OOM&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      runOOM(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      TimeUnit.SECONDS.sleep(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将 jfr 记录到一个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;File&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;File&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;).getAbsolutePath(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;string&quot;&gt;&amp;quot;recording-&amp;quot;&lt;/span&gt; + recording.getId()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + &lt;span class=&quot;string&quot;&gt;&amp;quot;-pid&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + ProcessHandle.current().pid()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + &lt;span class=&quot;string&quot;&gt;&amp;quot;.jfr&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ).toPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.dump(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;runBiz&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;boolean&lt;/span&gt; virtualThreadFlag)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 模拟正常业务运行，三个线程并发分配对象，朝生夕死&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Thread[] threads = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;bizRunnable&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; () -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          List&amp;lt;Object&amp;gt; objects = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!Thread.currentThread().isInterrupted()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              objects.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Object&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (objects.size() &amp;gt; &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  objects.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; threads.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (virtualThreadFlag) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              threads[i] = Thread.ofVirtual().name(&lt;span class=&quot;string&quot;&gt;&amp;quot;biz-&amp;quot;&lt;/span&gt; + i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      .unstarted(bizRunnable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              threads[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;(bizRunnable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threads[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              TimeUnit.SECONDS.sleep(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; threads.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  threads[i].interrupt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;RuntimeException&lt;/span&gt;(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      thread.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;runOOM&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;boolean&lt;/span&gt; virtualThreadFlag)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Thread[] threads = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Map&amp;lt;Object, Object&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;oomRun&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; () -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;1000000&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              map.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Object&lt;/span&gt;(), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Object&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; threads.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (virtualThreadFlag) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              threads[i] = Thread.ofVirtual().name(&lt;span class=&quot;string&quot;&gt;&amp;quot;oom-&amp;quot;&lt;/span&gt; + i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      .unstarted(oomRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              threads[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;(oomRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threads[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; threads.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threads[i].join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;是否建议开启这个事件的采集&quot;&gt;&lt;a href=&quot;#是否建议开启这个事件的采集&quot; class=&quot;headerlink&quot; title=&quot;是否建议开启这个事件的采集&quot;&gt;&lt;/a&gt;是否建议开启这个事件的采集&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation In New TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/</id>
    <published>2025-02-22T06:20:52.000Z</published>
    <updated>2025-02-22T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/jfr/04.png" alt="img"><br><img data-src="/images/jfr/05.png" alt="img"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): jdk.ObjectAllocationInNewTLAB</li><li>Label(Event Type，用于显示): Object Allocation In New TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>此事件对应 <code>Java对象分配过程</code> 中的路径二</li><li>事件字段<ul><li>Event Thread：发生路径二分配的线程的名称</li><li>Allocation Size：触发路径二分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径二分配的对象类型</li><li>TLAB Size：触发路径二分配，申请新的TLAB的大小</li><li>线程栈：发生路径二的线程栈，默认是采集的<br><img data-src="/images/jfr/06.png" alt="img"></li></ul></li><li>测试代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocInNewTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于字节数组对象头占用16字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_ARRAY_OVERHEAD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 测试的对象大小是KB</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OBJECT_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 字节数组对象名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BYTE_ARRAY_CLASS_NAME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>].getClass().getName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[] 会被全部省略，只剩最后一次的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小1KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 强制 fullgc 回收所以 TLAB</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小100KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE * <span class="number">100</span> - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">      <span class="comment">// 统计事件类型</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf1KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf100KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 读取文件中的所有 JFR 事件</span></span><br><span class="line">      <span class="keyword">for</span> (RecordedEvent event : RecordingFile.readAllEvents(path)) &#123;</span><br><span class="line">          <span class="comment">// 获取分配的对象类型</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> event.getString(<span class="string">&quot;objectClass.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确保分配类型是byte</span></span><br><span class="line">          <span class="keyword">if</span> (BYTE_ARRAY_CLASS_NAME.equals(className)) &#123;</span><br><span class="line">              <span class="type">RecordedFrame</span> <span class="variable">recordedFrame</span> <span class="operator">=</span> event.getStackTrace().getFrames().get(<span class="number">0</span>);</span><br><span class="line">              <span class="comment">// 同时必须是main方法分配的对象，并且是java堆栈中的main方法</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                      recordedFrame.isJavaFrame()</span><br><span class="line">                              &amp;&amp; <span class="string">&quot;main&quot;</span>.equalsIgnoreCase(recordedFrame.getMethod().getName())</span><br><span class="line">              ) &#123;</span><br><span class="line">                  <span class="comment">// 获取分配对象大小</span></span><br><span class="line">                  <span class="type">long</span> <span class="variable">allocationSize</span> <span class="operator">=</span> event.getLong(<span class="string">&quot;allocationSize&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (EVENT_TYPE.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (allocationSize == OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf1KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allocationSize == <span class="number">100</span> * OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf100KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unexpected size of TLAB event&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(event);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;countOf1KBObjectAllocationInNewTLAB: &quot;</span> + countOf1KBObjectAllocationInNewTLAB);</span><br><span class="line">      System.out.println(<span class="string">&quot;countOf100KBObjectAllocationInNewTLAB: &quot;</span> + countOf100KBObjectAllocationInNewTLAB);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么针对大部分应用不建议开启这个事件的采集"><a href="#为什么针对大部分应用不建议开启这个事件的采集" class="headerlink" title="为什么针对大部分应用不建议开启这个事件的采集?"></a>为什么针对大部分应用不建议开启这个事件的采集?</h3><ul><li><code>路径二分配一般不是核心问题点</code><ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li><li><code>对于大部分应用，没有啥必要性</code><ul><li>重新申请 TLAB 分配，对于热点线程来说，虽然不如TLAB内分配那么多，但是也是比较频繁的</li><li>如果重新申请 TLAB 分配的次数，和 TLAB 内分配的次数差不多，这才会是问题</li><li>但是 TLAB 的大小是根据线程的分配情况动态调整的，所以 TLAB 内的分配的次数会比较多，而重新申请 TLAB 分配的次数会比较少</li><li>所以这个事件的采集，对于大部分的应用来说，并不是很有必要</li></ul></li><li><code>性能损耗</code><ul><li>这个事件的采集，会捕获堆栈信息，堆栈信息是比较耗性能的，如果开启这个事件的采集，会导致性能损耗比较大。并且这个事件的采集也相对频繁</li></ul></li></ul><h3 id="哪种情况下才会考虑开启这个事件的采集"><a href="#哪种情况下才会考虑开启这个事件的采集" class="headerlink" title="哪种情况下才会考虑开启这个事件的采集?"></a>哪种情况下才会考虑开启这个事件的采集?</h3><ul><li>正常的应用场景下，不需要调整TLAB的配置参数。一般情况下，JVM会根据应用的情况自动调整TLAB的大小</li><li>如果确实怀疑TLAB的配置参数有问题，第一步是开启 Java Application -&gt; Allocation In New TLAB(jdk.ObjectAllocationInNewTLAB) 和 Java Application -&gt;  Allocation outside TLAB(jdk.ObjectAllocationOutsideTLAB)</li><li>确认有大量的 Object Allocation Outside TLAB 事件发生（一般在应用稳定之后，如果很多线程的 Object Allocation Outside TLAB 相对于 Allocation In New TLAB 大于 5%以上就需要调整 TLAB 相关参数了），然后再考虑是否需要调整 TLAB 的配置参数。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/jfr/04.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;/images/jfr/05.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): jdk.ObjectAllocationInNewTLAB&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation In New TLAB&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从哪个版本引入？&lt;ul&gt;
&lt;li&gt;Java11：即一开始就存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;default.jfc 配置&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationInNewTLAB&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;enabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;control&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;gc-enabled-high&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;stackTrace&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Profiling.jfc 配置&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationInNewTLAB&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;enabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;control&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;gc-enabled-high&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;stackTrace&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;event&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;code&gt;Java对象分配过程&lt;/code&gt; 中的路径二&lt;/li&gt;
&lt;li&gt;事件字段&lt;ul&gt;
&lt;li&gt;Event Thread：发生路径二分配的线程的名称&lt;/li&gt;
&lt;li&gt;Allocation Size：触发路径二分配的对象大小（实际占用，考虑了对象对其）&lt;/li&gt;
&lt;li&gt;Object Class：触发路径二分配的对象类型&lt;/li&gt;
&lt;li&gt;TLAB Size：触发路径二分配，申请新的TLAB的大小&lt;/li&gt;
&lt;li&gt;线程栈：发生路径二的线程栈，默认是采集的&lt;br&gt;&lt;img data-src=&quot;/images/jfr/06.png&quot; alt=&quot;img&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试代码 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;TestAllocInNewTLAB&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对于字节数组对象头占用16字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;BYTE_ARRAY_OVERHEAD&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 测试的对象大小是KB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;OBJECT_SIZE&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 字节数组对象名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;BYTE_ARRAY_CLASS_NAME&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].getClass().getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[] 会被全部省略，只剩最后一次的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;byte&lt;/span&gt;[] tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;EVENT_TYPE&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;jdk.ObjectAllocationInNewTLAB&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;WhiteBox&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;whiteBox&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; WhiteBox.getWhiteBox();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 初始化jfr记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Recording&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;recording&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Recording&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.enable(EVENT_TYPE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// JFR 记录启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 强制 fullgc 防止程序接下来发生 gc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 同时可以区分初始化带来的其他线程的TLAB相关的日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      whiteBox.fullGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 分配对象，大小1KB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;512&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tmp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;byte&lt;/span&gt;[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 强制 fullgc 回收所以 TLAB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      whiteBox.fullGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 分配对象，大小100KB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tmp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;byte&lt;/span&gt;[OBJECT_SIZE * &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; - BYTE_ARRAY_OVERHEAD];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      whiteBox.fullGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将 jfr 记录到一个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;File&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;File&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;).getAbsolutePath(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;string&quot;&gt;&amp;quot;recording-&amp;quot;&lt;/span&gt; + recording.getId()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + &lt;span class=&quot;string&quot;&gt;&amp;quot;-pid&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + ProcessHandle.current().pid()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      + &lt;span class=&quot;string&quot;&gt;&amp;quot;.jfr&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ).toPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      recording.dump(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 统计事件类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;countOf1KBObjectAllocationInNewTLAB&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;countOf100KBObjectAllocationInNewTLAB&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 读取文件中的所有 JFR 事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (RecordedEvent event : RecordingFile.readAllEvents(path)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 获取分配的对象类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; event.getString(&lt;span class=&quot;string&quot;&gt;&amp;quot;objectClass.name&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 确保分配类型是byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (BYTE_ARRAY_CLASS_NAME.equals(className)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;type&quot;&gt;RecordedFrame&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;recordedFrame&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; event.getStackTrace().getFrames().get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;comment&quot;&gt;// 同时必须是main方法分配的对象，并且是java堆栈中的main方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      recordedFrame.isJavaFrame()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              &amp;amp;&amp;amp; &lt;span class=&quot;string&quot;&gt;&amp;quot;main&amp;quot;&lt;/span&gt;.equalsIgnoreCase(recordedFrame.getMethod().getName())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;comment&quot;&gt;// 获取分配对象大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;allocationSize&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; event.getLong(&lt;span class=&quot;string&quot;&gt;&amp;quot;allocationSize&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (EVENT_TYPE.equalsIgnoreCase(event.getEventType().getName())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allocationSize == OBJECT_SIZE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          countOf1KBObjectAllocationInNewTLAB++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allocationSize == &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; * OBJECT_SIZE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          countOf100KBObjectAllocationInNewTLAB++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Exception&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;unexpected size of TLAB event&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              System.out.println(event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;countOf1KBObjectAllocationInNewTLAB: &amp;quot;&lt;/span&gt; + countOf1KBObjectAllocationInNewTLAB);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;countOf100KBObjectAllocationInNewTLAB: &amp;quot;&lt;/span&gt; + countOf100KBObjectAllocationInNewTLAB);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>Java对象分配过程</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/</id>
    <published>2025-02-22T06:13:52.000Z</published>
    <updated>2025-02-22T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路径一-TLAB-内分配"><a href="#路径一-TLAB-内分配" class="headerlink" title="路径一 TLAB 内分配"></a>路径一 TLAB 内分配</h3><ul><li>需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配</li><li>这是大多数对象的分配路径</li></ul><h3 id="路径二-申请新的-TLAB-分配"><a href="#路径二-申请新的-TLAB-分配" class="headerlink" title="路径二 申请新的 TLAB 分配"></a>路径二 申请新的 TLAB 分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间</li><li>重新分配一个 TLAB，然后在新的 TLAB 中分配</li></ul><h3 id="路径三-TLAB-外分配"><a href="#路径三-TLAB-外分配" class="headerlink" title="路径三 TLAB 外分配"></a>路径三 TLAB 外分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间</li><li>或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小</li><li>或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁</li><li>以上三种情况都会直接在堆上分配</li></ul><h3 id="路径四-分配前触发GC或者等待GC"><a href="#路径四-分配前触发GC或者等待GC" class="headerlink" title="路径四 分配前触发GC或者等待GC"></a>路径四 分配前触发GC或者等待GC</h3><ul><li>路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁</li><li>这种情况下，会触发 GC 或者等待 GC 释放对象</li></ul><h3 id="为什么有个最大浪费空间？？"><a href="#为什么有个最大浪费空间？？" class="headerlink" title="为什么有个最大浪费空间？？"></a>为什么有个最大浪费空间？？</h3><ul><li>这是为了避免更有效的利用空间</li><li>假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择<ul><li>丢弃掉当前这个TLAB，去申请一个新的</li><li>不在当前这个TLAB上配置，去堆上分配</li><li>最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><ul><li>TLAB 是动态的，一般分配频繁的线程TLAB&#x3D;2M</li><li>每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;路径一-TLAB-内分配&quot;&gt;&lt;a href=&quot;#路径一-TLAB-内分配&quot; class=&quot;headerlink&quot; title=&quot;路径一 TLAB 内分配&quot;&gt;&lt;/a&gt;路径一 TLAB 内分配&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配&lt;/li&gt;
&lt;li&gt;这是大多数对象的分配路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;路径二-申请新的-TLAB-分配&quot;&gt;&lt;a href=&quot;#路径二-申请新的-TLAB-分配&quot; class=&quot;headerlink&quot; title=&quot;路径二 申请新的 TLAB 分配&quot;&gt;&lt;/a&gt;路径二 申请新的 TLAB 分配&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-准备工作</title>
    <link href="https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/</id>
    <published>2025-02-20T06:13:52.000Z</published>
    <updated>2025-02-20T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h2 id="为什么需要JFR"><a href="#为什么需要JFR" class="headerlink" title="为什么需要JFR?"></a>为什么需要JFR?</h2><h3 id="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式"><a href="#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式" class="headerlink" title="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式"></a>我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 <code>OpenTelemetry</code> 标准的监控方式</h3><ul><li>arthas: 主要用于实时定位问题，必须有问题线程，必须复现才能定位，没法事后定位，如果有应用问题也可能挂载不上。<br>JFR可以实现从JVM启动开始一直持续采集监控与事后定位，即使应用有问题卡住，也基本能通过JFR定位。</li><li>APM 框架: 例如 micrometer，open-telemetry，Skywalking 等等，大部分基于 <code>Java Agent</code> 和侵入代码的方式结合实现，<br>这些对于JFR来说：<ul><li>这些框架没办法采集JVM层面的指标</li><li>JVM协调安全点，JVM卡住，Java应用有问题，CPU吃满等等，这些框架会受很大影响</li></ul></li></ul><h3 id="结合学习-JVM-JDK-的最佳方式"><a href="#结合学习-JVM-JDK-的最佳方式" class="headerlink" title="结合学习 JVM + JDK 的最佳方式"></a>结合学习 JVM + JDK 的最佳方式</h3><ul><li>JFR 有哪些事件，为啥要采集这些事件</li><li>采集这些事件的机制</li><li>搞懂上面的问题，基本从 JVM 到 JDK 的任意一个细节都搞懂了，比如：<ul><li>JVM GC 的时候有哪些阶段，每个阶段耗时与做了什么？看 GC 相关 JFR 事件</li><li>JVM Safepoint 是啥，有啥原因会进入 safePoint？看 Safepoint 相关 JFR 事件</li><li>JDK 中的 AQS 究竟基于啥，实现原理是啥？看 Thread Park 事件属性与对应线程栈</li></ul></li></ul><h2 id="JFR-如何实现高效"><a href="#JFR-如何实现高效" class="headerlink" title="JFR 如何实现高效"></a>JFR 如何实现高效</h2><ul><li><img data-src="/images/jfr/01.png" alt="img"></li></ul><h2 id="JFR-如何从-JVM-启动一开始监控到任意时候"><a href="#JFR-如何从-JVM-启动一开始监控到任意时候" class="headerlink" title="JFR 如何从 JVM 启动一开始监控到任意时候"></a>JFR 如何从 JVM 启动一开始监控到任意时候</h2><blockquote><p>突破 JFR 本身限制，不用 dumponexit，不用主动 dump</p></blockquote><ul><li>JFR 写入磁盘的 Data Chunk，默认在临时目录(<code>java.io.tmpdir</code>)，这个可以通过<br>JFR 配置限制<ul><li><code>maxage</code>：限制保留的 JFR 事件的最早时间</li><li><code>maxsize</code>：限制保留在本地磁盘临时文件的最大总大小</li></ul></li><li>Java 14开始，增加了 JFR Event Streaming 机制<ul><li>写入的临时文件不再是.part，而是.jfr，这样即使JMC无法解析，也可以使用jfr命令解析</li><li>java 14 引入定时任务定时（默认1s）执行 JFR Flush 将元数据刷入本地文件 Data Chunk，这样大概率最新的文件就是数据完整的，即可以被JMC解析</li></ul></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Java-17-以上的-JDK"><a href="#Java-17-以上的-JDK" class="headerlink" title="Java 17 以上的 JDK"></a>Java 17 以上的 JDK</h3><blockquote><p>Azul、Corretto、OpenJdk随意</p></blockquote><h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><blockquote><p>下载最新版本即可，即 JMC 9</p></blockquote><h3 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h3><blockquote><p><code>WhiteBox API</code> 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的API暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解JVM并调优参数</p></blockquote><ul><li>编译 WhiteBox API<ol><li>拉取 openjdk 源码</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 --filter=blob:none --sparse https://github.com/openjdk/jdk</span><br><span class="line">cd jdk</span><br><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout set test/lib/jdk/test/whitebox</span><br></pre></td></tr></table></figure><ol start="2"><li>新建 maven 空项目，将刚刚拉取的代码复制进去，执行 <code>maven package</code> 即可</li><li>将编译的 jar 包放在项目根目录，通过 maven 本地 system 依赖的方式将 jar 包加入依赖<br><img data-src="/images/jfr/02.png" alt="img"></li><li>不想自己构建可以使用 <a href="/files/jfr/whitebox-1.0-SNAPSHOT.jar">whitebox-1.0-SNAPSHOT.jar</a></li><li>编写测试代码<ul><li>代码</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWhiteBox</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            主要用于添加WhiteBox测试API的jar包，这个jar必须通过引导类加载器加载，因为它需要访问JVM内部功能，/a 表示append，将指定的jar追加到引导类路径末尾</span></span><br><span class="line"><span class="comment">            -Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            解锁JVM诊断选项，启用一些默认被禁用的诊断/调试选项，这是使用WhiteBox API的前提条件</span></span><br><span class="line"><span class="comment">            -XX:+UnlockDiagnosticVMOptions</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            启用WhiteBox测试API，WhiteBox API提供了访问JVM内部状态的能力</span></span><br><span class="line"><span class="comment">            -XX:+WhiteBoxAPI</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            开启GC日志记录，输出带有gc标签的日志</span></span><br><span class="line"><span class="comment">            -Xlog:gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 获取 ReservedCodeCacheSize 这个 JVM flag 的值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">reservedCodeCacheSize</span> <span class="operator">=</span> whiteBox.getUintxVMFlag(<span class="string">&quot;ReservedCodeCacheSize&quot;</span>);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        <span class="comment">// 打印内存各项指标</span></span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        <span class="comment">// 执行 full GC</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        <span class="comment">// 保持进程不退出，打印完整日志</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动VM Options</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure><ul><li>执行结果，出现 NoSuchMethodError 错误没关系，因为打包的是最新的 whitebox，使用的jdk版本可能没有某些最新的api<br><img data-src="/images/jfr/03.png" alt="img"></li></ul></li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么需要JFR&quot;&gt;&lt;a href=&quot;#为什么需要JFR&quot; class=&quot;headerlink&quot; title=&quot;为什么需要JFR?&quot;&gt;&lt;/a&gt;为什么需要JFR?&lt;/h2&gt;&lt;h3 id=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot;&gt;&lt;a href=&quot;#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot; class=&quot;headerlink&quot; title=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式&quot;&gt;&lt;/a&gt;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 &lt;code&gt;OpenTelemetry&lt;/code&gt; 标准的监控方式&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 单元测试最佳实践</title>
    <link href="https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/</id>
    <published>2025-02-19T15:55:22.000Z</published>
    <updated>2025-02-19T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>标题党，各位大佬手下留情<del>_</del></p></blockquote><p>单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)</p><blockquote><p>!! 笔者使用的是 2.6.6 版本</p></blockquote><p><img data-src="/images/spring/boot/01.png" alt="image.png"></p><blockquote><p>SpringBoot 常规单元测试</p></blockquote><p>常规的单元测试如下图所示，这样会将整个容器启动起来，需要加载各种各样的外部化配置，耗时时间长且容易失败；大部分场景下我们只是测试某个功能，只需加载部分组件即可</p><p><img data-src="/images/spring/boot/02.png" alt="image.png"></p><blockquote><p>SpringBoot 单元测试指定加载配置</p></blockquote><p>为了解决以上问题，我们可以指定配置进行加载，避免加载整个容器；如下图所示，只会加载基础的Spring容器以及IdGenerator，大大提升了单测的效率</p><p><code>推荐学习</code><a href="https://github.com/chanjarster/spring-test-examples">spring-test-examples</a></p><p><img data-src="/images/spring/boot/03.png" alt="image.png"></p><blockquote><p>SprongBoot 固定组件单元测试</p></blockquote><p>以上指定配置加载已经基本满足了我们的需求(加载部分组件)；但在日常开发中，要求每次单测都指定加载的配置本身就是个伪命题，一是因为本身开发可能对于需要加载的配置不太熟悉，二是因为这种重复的工作过于啰嗦；那么我们该怎么优化这个流程呢？</p><ol><li>要简化配置，第一步就是禁用所有自动加载的配置</li></ol><ul><li>仿造<code>SpringBootTest</code>的注解，构建一个元注解，禁用所有自动加载的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(EmptyTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(EmptyTypeExcludeFilter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestEmptyEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTestContextBootstrapper</span> <span class="keyword">extends</span> <span class="title class_">SpringBootTestContextBootstrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getProperties(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestEmptyEnvironment</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">        <span class="keyword">return</span> (annotation != <span class="literal">null</span>) ? annotation.properties() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTypeExcludeFilter</span> <span class="keyword">extends</span> <span class="title class_">AnnotationCustomizableTypeExcludeFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEmptyEnvironment annotation;</span><br><span class="line"></span><br><span class="line">    EmptyTypeExcludeFilter(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ComponentScan.Filter[] getFilters(<span class="keyword">final</span> FilterType type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> INCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.includeFilters();</span><br><span class="line">            <span class="keyword">case</span> EXCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.excludeFilters();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported type &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation.useDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getDefaultIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getComponentIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>TestEmptyEnvironment</strong>: 禁用所有自动配置，只加载最基础的spring容器</li><li><strong>EmptyTestContextBootstrapper</strong>: 重写properties加载方法，将TestEmptyEnvironment注解中的properties属性加载到容器中</li><li><strong>EmptyTypeExcludeFilter</strong>: 容器过滤</li><li><strong>@OverrideAutoConfiguration(enabled &#x3D; false)</strong>: 禁用自动配置加载，如果是boot2.2.x之前的版本，此配置不会生效，可以使用 @ContextConfiguration(classes &#x3D; EmptyConfiguration.class) 替代，其中 EmptyConfiguration 表示空的配置</li></ul><ol start="2"><li>要简化单测的流程，就需要将重复的工作声明化，即使用注解完成自动配置的大部分工作；具体需要如何处理呢，我们可以将常用单测注解进行声明化处理，编写单测时只需引入对应组件的注解即可</li></ol><ul><li><strong>service</strong> 仅对service进行单测，可声明以下注解，构建一个简单的spring容器即可，需要测试哪个service，直接Import加载即可；若此service中有其他注解，可进行mock处理，这里不再赘述mock的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TestService</span></span><br><span class="line"><span class="comment">// 若是boot2.2.x之后这里不再需要，因为元注解中已经增加了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// @RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;</span></span><br><span class="line"><span class="meta">        LabelService.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LabelService labelService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>redis</strong> 对redis进行单测，需要引入redis相关的自动配置，如下代码中的 RedisTestAutoConfiguration 类，不同项目使用的框架不同，自动装配也不相同，这里需要根据项目进行个性化设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        RedisTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRedis &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        LettuceAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRedis</span></span><br><span class="line"><span class="comment">// 优先级最高，可覆盖项目中的配置文件</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;</span></span><br><span class="line"><span class="meta">        &quot;redis.host=localhost:6379&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getRedisHost</span><span class="params">()</span> &#123;</span><br><span class="line">        assertThat(redisClient)</span><br><span class="line">        .isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>kafka</strong> kafka单测也和redis一样，进行个性化配置即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestKafka &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其他组件也都是一样的做法，笔者暂时用到的组件如下<ul><li>feign</li><li>kafka</li><li>mongodb</li><li>redis</li><li>service</li><li>controller</li><li>mybatis</li></ul></li></ul><p>tips: 如果不知道组件需要加载哪些配置，可通过完整启动项目打印所有装配的配置，然后再筛选需要的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderPrint</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;标题党，各位大佬手下留情&lt;del&gt;_&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;!! 笔者使用的是 2.6.6 版本&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/categories/spring-boot/"/>
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
    <category term="单元测试" scheme="https://taeyang0126.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>rocksdb</title>
    <link href="https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/shu-ju-ku/rocksdb/rocksdb/posts/undefined/</id>
    <published>2025-02-19T15:52:22.000Z</published>
    <updated>2025-02-19T15:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h4><p><img data-src="/images/db/rocksdb/image1.png" alt="image1.png"></p><h4 id="数据读取流程"><a href="#数据读取流程" class="headerlink" title="数据读取流程"></a>数据读取流程</h4><p><img data-src="/images/db/rocksdb/image2.png" alt="image2.png"></p><h4 id="db-相关属性"><a href="#db-相关属性" class="headerlink" title="db 相关属性"></a>db 相关属性</h4><table><thead><tr><th>类别</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>总体统计</td><td>rocksdb.stats</td><td>提供详细的数据库统计信息，包括压缩、读写操作、块缓存等数据</td></tr><tr><td>数据库大小</td><td>rocksdb.total-sst-files-size</td><td>所有 SST 文件的总大小</td></tr><tr><td></td><td>rocksdb.estimate-table-readers-mem</td><td>估计表读取器使用的内存</td></tr><tr><td></td><td>rocksdb.estimate-live-data-size</td><td>估计的活跃数据大小</td></tr><tr><td>内存使用</td><td>rocksdb.cur-size-all-mem-tables</td><td>所有 MemTable 的当前大小</td></tr><tr><td></td><td>rocksdb.block-cache-usage</td><td>块缓存的使用量</td></tr><tr><td>压缩</td><td>rocksdb.background-errors</td><td>后台工作（如压缩）中的错误数</td></tr><tr><td></td><td>rocksdb.num-running-compactions</td><td>当前运行的压缩任务数</td></tr><tr><td>写入</td><td>rocksdb.num-immutable-mem-table</td><td>不可变 MemTable 的数量</td></tr><tr><td></td><td>rocksdb.mem-table-flush-pending</td><td>是否有待处理的 MemTable 刷新</td></tr><tr><td></td><td>rocksdb.is-write-stopped</td><td>写入是否已停止</td></tr><tr><td></td><td>rocksdb.actual-delayed-write-rate</td><td>实际的延迟写入速率</td></tr><tr><td>读取</td><td>rocksdb.estimate-num-keys</td><td>估计的键数量</td></tr><tr><td>文件</td><td>rocksdb.num-files-at-level<N></td><td>第 N 层的文件数量（如 rocksdb.num-files-at-level0）</td></tr><tr><td></td><td>rocksdb.live-sst-files-size</td><td>活跃 SST 文件的大小</td></tr></tbody></table><p>注意：</p><ol><li>使用方法示例：<code>String value = db.getProperty(&quot;rocksdb.stats&quot;);</code></li><li>某些属性可能会影响性能，应谨慎使用。</li><li>属性值可能会频繁变化，建议定期获取以监控趋势。</li><li>在生产环境中使用时，可能需要限制获取这些属性的频率。</li></ol><h4 id="事务操作使用场景"><a href="#事务操作使用场景" class="headerlink" title="事务操作使用场景"></a>事务操作使用场景</h4><ul><li>为单个 key 提供并发控制<ol><li>事务开始时获取逻辑锁</li><li>提交时检查冲突</li><li>避免显式锁定，提高并发性</li><li>减少死锁风险</li><li>计数器更新</li><li>用户状态修改</li></ol></li><li>确保多个 key 的一致性更新<ol><li>将多个 key 操作组合为单一事务</li><li>全部成功或全部失败</li><li>维护相关数据的一致性</li><li>简化复杂操作的实现</li><li>用户注册（创建账户 + 初始化设置）</li><li>订单处理（更新库存 + 记录订单）</li></ol></li></ul><h4 id="RocksDB-默认冲突检测机制"><a href="#RocksDB-默认冲突检测机制" class="headerlink" title="RocksDB 默认冲突检测机制"></a>RocksDB 默认冲突检测机制</h4><h5 id="事务间冲突检测"><a href="#事务间冲突检测" class="headerlink" title="事务间冲突检测"></a>事务间冲突检测</h5><ol><li>触发时机：事务提交时</li><li>检测对象：活跃事务之间的写集</li><li>检测方式：<ol><li>每个事务的 put 操作都会记录在写集中</li><li>提交时检查本事务的写集是否与其他活跃事务的写集冲突</li><li>结果：如果发现冲突，后提交的事务通常会失败</li></ol></li></ol><h5 id="非事务性写入检测"><a href="#非事务性写入检测" class="headerlink" title="非事务性写入检测"></a>非事务性写入检测</h5><ol><li>触发时机：执行非事务性写入时（如 txnDb.put()）</li><li>检测对象：所有活跃事务的锁和写意图</li><li>检测方式：<ol><li>检查目标键是否被任何活跃事务锁定</li><li>检查是否有活跃事务对该键有写意图</li><li>结果：如果存在冲突，非事务性写入会失败并抛出异常</li></ol></li></ol><h5 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h5><ol><li>写意图（Write Intents）：事务执行写操作时登记，用于冲突检测</li><li>锁定机制：事务的 put 操作会为相应的键设置锁</li><li>快照隔离：事务开始时获取数据快照，影响可见的数据版本</li><li>乐观并发控制（默认）：大多数冲突检测在提交时进行</li><li>悲观锁定（可配置）：启用后，冲突检测在写操作执行时就会进行</li></ol><h4 id="RocksDB-读取策略"><a href="#RocksDB-读取策略" class="headerlink" title="RocksDB 读取策略"></a>RocksDB 读取策略</h4><h5 id="读已提交-默认"><a href="#读已提交-默认" class="headerlink" title="读已提交(默认)"></a>读已提交(默认)</h5><p>内部事务对于外部事务提交的立马可见</p><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readOptions.setSnapshot(snapshot);</span><br></pre></td></tr></table></figure><p>快照读类比于读已提交，对于外部事务只能看到当前快照创建时提交的数据，对于当前事务，所有写入都是可见的</p><h4 id="RocksDB-事务版本号管理"><a href="#RocksDB-事务版本号管理" class="headerlink" title="RocksDB 事务版本号管理"></a>RocksDB 事务版本号管理</h4><ul><li>对于冲突检测来说，使用事务开始时的快照序列号作为基准，比较操作键的当前序列号与快照序列号</li><li>对于提交来说，获取新的全局序列号作为起始点，将事务内部的临时序列号映射到连续的全局序列号，最终序列号 &#x3D; 新全局序列号 + 临时序列号偏移</li><li>所以会出现某个事务过程中，外部事务修改了键，内部事务再使用getForUpdate就会报错，因为比较实用的是快照的序列号</li><li>getForUpdate还有个好处就是能检测外部非事务性操作，因为本质上使用的是序列号比较，所以能检测，但是默认的写写冲突是无法检测的，因为默认是读已提交，rocksdb认为这是合理的，内部事务会覆盖外部事物的值</li></ul><table><thead><tr><th>方面</th><th>描述</th></tr></thead><tbody><tr><td>全局序列号</td><td>- 全局递增的序列号作为版本标识<br>- 每次非事务写入或事务提交时分配</td></tr><tr><td>事务开始</td><td>- 创建数据库快照<br>- 记录当前最大序列号作为事务”基线”</td></tr><tr><td>读操作</td><td>- 使用事务开始时的快照序列号<br>- 只读取序列号≤快照序列号的数据</td></tr><tr><td>写操作</td><td>- 不立即分配全局序列号<br>- 事务内部使用临时本地序列号</td></tr><tr><td>事务提交</td><td>- 获取新的全局序列号<br>- 将事务内写操作映射到连续的全局序列号<br>- 用新序列号更新数据库</td></tr><tr><td>回滚处理</td><td>- 丢弃事务内的所有本地序列号<br>- 不影响全局序列号</td></tr><tr><td>冲突检测</td><td>- 读写冲突：比较快照序列号与当前数据序列号<br>- 写写冲突：提交时检查数据是否被其他事务修改</td></tr><tr><td>OptimisticTransactionDB</td><td>- 延迟冲突检测到提交阶段<br>- 提交时比较数据当前序列号与事务开始序列号</td></tr><tr><td>TransactionDB</td><td>- 可能在操作过程中进行冲突检测<br>- 使用锁机制预防冲突</td></tr><tr><td>隔离级别影响</td><td>- 读已提交：每次读操作使用最新快照<br>- 可重复读：整个事务使用开始时的快照<br>- 快照隔离：类似可重复读，但有额外写冲突检测</td></tr><tr><td>注意事项</td><td>- 版本号管理是实现 MVCC 的基础<br>- 有助于理解和处理事务冲突和并发问题</td></tr></tbody></table><h4 id="getForUpdate总结"><a href="#getForUpdate总结" class="headerlink" title="getForUpdate总结"></a>getForUpdate总结</h4><ol><li>用来解决读写冲突，这里的冲突可以是事务与其他事务之间，也可以是事务与非事务操作之间</li><li>我认为是使用序列号进行检测的，当前快照的序列号与键的序列号之间的比较判断是否冲突</li><li>对于OptimisticTransactionDB和TransactionDB检测的时机不一样，前者属于乐观型的，在commit才会检测，后者会立即检测</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;数据写入流程&quot;&gt;&lt;a href=&quot;#数据写入流程&quot; class=&quot;headerlink&quot; title=&quot;数据写入流程&quot;&gt;&lt;/a&gt;数据写入流程&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;/images/db/rocksdb/image1.png&quot; alt=&quot;image1.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据读取流程&quot;&gt;&lt;a href=&quot;#数据读取流程&quot; class=&quot;headerlink&quot; title=&quot;数据读取流程&quot;&gt;&lt;/a&gt;数据读取流程&lt;/h4&gt;</summary>
    
    
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/categories/rocksdb/"/>
    
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="rocksdb" scheme="https://taeyang0126.github.io/tags/rocksdb/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/protobuf/protobuf/posts/undefined/</id>
    <published>2025-02-19T14:51:22.000Z</published>
    <updated>2025-02-19T14:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-执行命令编译"><a href="#1-执行命令编译" class="headerlink" title="1. 执行命令编译"></a>1. 执行命令编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=./src/main/java ./proto3/User.proto</span><br></pre></td></tr></table></figure><h4 id="2-通过maven插件"><a href="#2-通过maven插件" class="headerlink" title="2. 通过maven插件"></a>2. 通过maven插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断系统--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Protobuf Maven 插件</span></span><br><span class="line"><span class="comment">        作用：</span></span><br><span class="line"><span class="comment">             - 自动下载和使用 protoc 编译器</span></span><br><span class="line"><span class="comment">             - 编译 .proto 文件生成 Java 代码</span></span><br><span class="line"><span class="comment">             - 集成到 Maven 生命周期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- protoc 编译器配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- proto 文件源目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>$&#123;project.basedir&#125;/src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的 Java 代码输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/protobuf/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否清空输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>true<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-proto3"><a href="#3-proto3" class="headerlink" title="3. proto3"></a>3. proto3</h4><ul><li>所有字段都有默认值，比如string默认为空串</li><li>因为有默认值，所以所有的字段都是不为null的，需要判断是否为空，hasXXX()、getCount() &gt; 0 等等进行判断</li><li>使用 1-15 的字段号给最常用的字段  （频繁访问的字段放在前面，cpu缓存命中率更高）</li><li>不常用字段使用 16+ 的字段号  （不常访问的字段放在后面）</li><li>对于较小范围的数字，用 int32 而不是 int64</li><li>固定长度的数字用 fixed32&#x2F;fixed64</li><li>对于负数多的场景用 sint32&#x2F;sint64</li><li>字段更新规则！！<ol><li>添加新字段</li><li>删除字段(但保留字段号)</li><li>重命名字段(字段号不变)</li><li>添加repeated字段   reserved 2, 15, 9 to 11;       &#x2F;&#x2F; 保留字段号  reserved “foo”, “bar”;         &#x2F;&#x2F; 保留字段名</li></ol></li><li>字段不能做的更新规则！！<ol><li>改变已有字段的类型</li><li>复用已删除的字段号</li><li>改变已有字段的编号</li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-执行命令编译&quot;&gt;&lt;a href=&quot;#1-执行命令编译&quot; class=&quot;headerlink&quot; title=&quot;1. 执行命令编译&quot;&gt;&lt;/a&gt;1. 执行命令编译&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protoc --java_out=./src/main/java ./proto3/User.proto&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-通过maven插件&quot;&gt;&lt;a href=&quot;#2-通过maven插件&quot; class=&quot;headerlink&quot; title=&quot;2. 通过maven插件&quot;&gt;&lt;/a&gt;2. 通过maven插件&lt;/h4&gt;</summary>
    
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/categories/protobuf/"/>
    
    
    <category term="protobuf" scheme="https://taeyang0126.github.io/tags/protobuf/"/>
    
    <category term="序列化" scheme="https://taeyang0126.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>panama</title>
    <link href="https://taeyang0126.github.io/2025/02/19/panama/panama/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/panama/panama/posts/undefined/</id>
    <published>2025-02-19T13:51:22.000Z</published>
    <updated>2025-02-19T13:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://openjdk.org/jeps/454">JEP 454: Foreign Function &amp; Memory API</a></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><blockquote><p>通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。</p></blockquote><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><ul><li>JNI 涉及几个繁琐的人工制品：一个 Java API（ native 方法）、一个从 Java API 派生的 C 头文件和一个调用目标原生库的 C 实现。Java 开发人员必须跨多个工具链工作以保持平台相关的人工制品同步，而这在原生库快速演化时尤其繁重。</li><li>JNI 只能与用操作系统和 CPU 的调用约定编写的语言（通常是 C 和 C++）编写的库进行交互，这是 JVM 为其构建的。native 方法不能用于调用以使用不同约定的语言编写的函数。</li><li>JNI 无法协调 Java 类型系统和 C 类型系统。Java 代码使用对象表示聚合数据，但 C 代码使用结构表示聚合数据，因此任何传递给 native 方法的 Java 对象都必须由本机代码费力地解包。例如，考虑一个 Java 记录类 Person ：将一个 Person 对象传递给 native 方法，要求本机代码使用 JNI 的 C API 从该对象中提取字段（例如， firstName 和 lastName ）。因此，Java 开发人员有时会将他们的数据展平到单个对象中（例如，字节数组或直接字节缓冲区），但更多情况下，由于通过 JNI 传递 Java 对象速度很慢，他们使用 Unsafe API 分配堆外内存并将其地址作为 long 传递给 native 方法 - 这使得 Java 代码非常不安全！</li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol><li>控制外内存的分配和释放</li><li>操控和访问结构化的外部内存</li><li>调用外部函数（ Linker 、 SymbolLookup 、 FunctionDescriptor 和 MethodHandle ）</li></ol><h3 id="Memory-segments-and-arenas"><a href="#Memory-segments-and-arenas" class="headerlink" title="Memory segments and arenas"></a>Memory segments and arenas</h3><ul><li>内存段是一个由一块连续的内存区域支持的抽象概念，该区域可以位于堆外或堆上。<ol><li>从非堆内存中从头分配的本机段（如同通过 malloc)</li><li>映射段，围绕一块映射的非堆内存（如通过 mmap ）</li><li>一个数组或缓冲区段，它被包装在一个与现有 Java 数组或字节缓冲区关联的堆上内存区域周围</li></ol></li><li>所有内存段都提供空间和时间边界，这些边界确保内存访问操作是安全的。简而言之，这些边界保证不使用未分配的内存，也不进行释放后使用。</li><li><code>global arena</code> 全局区域，它提供无限的生命周期：它始终保持活动状态，只有在JVM退出的时候才会被自动卸载</li><li><code>Auto arena</code> 自动 arena 提供了有限的生命周期：由自动 arena 分配的段可以被访问，直到 JVM 的垃圾回收器检测到该内存段不可访问，此时该段背后的内存区域将被释放</li><li><code>confined arena</code> 提供了一种有界限且确定性的生存期：从客户端打开区域到客户端关闭区域之间的这段时间它将一直存在。在受限区域中分配的内存段只能在关闭区域之前访问，在关闭区域时，支持该段的内存区域将被取消分配。在区域关闭后尝试访问内存段将失败并引发异常。!!只有一个线程可以访问</li><li><code>shared arena</code> 在共享区域中分配的内存段可以被多个线程访问，并且任何线程——无论是否访问该区域——都可以关闭该区域以释放这些段。关闭区域会原子地使这些段无效，尽管支持这些段的内存区域的释放可能不会立即发生，因为需要昂贵的同步操作来检测和取消对这些段的挂起并发访问操作</li></ul><h3 id="Zero-length-memory-segments"><a href="#Zero-length-memory-segments" class="headerlink" title="Zero-length memory segments"></a>Zero-length memory segments</h3><ul><li>FFM API 将外函数返回的指针表示为零长度的内存段。该段的地址是该指针的值，该段的大小为零。类似地，当客户端从内存段读取指针时，将返回一个零长度的内存段。</li><li>任何 Address 布局返回的MemorySegment都是 Zero-length memory segments</li><li>零长度段具有微不足道的空间边界，因此任何访问此类段的尝试都会失败，并带有 IndexOutOfBoundsException 。这是一个至关重要的安全特性：由于这些段与大小未知的内存区域相关联，因此涉及这些段的访问操作无法验证。实际上，零长度内存段封装了一个地址，在没有明确意图的情况下无法使用它。</li><li>可以使用 MemorySegment::reinterpret 方法将零长度内存段转换为特定大小的本机段。 此方法将新的空间和时间边界附加到零长度内存段，以便允许解除引用操作。 此方法返回的内存段不安全：零长度内存段可能由 10 字节长的内存区域支持，但客户端可能会高估该区域的大小并使用 MemorySegment::reinterpret 获取 100 字节长的段。 稍后，这可能会导致尝试在该区域边界之外解除引用内存，从而可能导致 JVM 崩溃或更糟的情况，导致静默内存损坏。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/454&quot;&gt;JEP 454: Foreign Function &amp;amp; Memory API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="panama" scheme="https://taeyang0126.github.io/categories/panama/"/>
    
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
    <category term="panama" scheme="https://taeyang0126.github.io/tags/panama/"/>
    
    <category term="ffi" scheme="https://taeyang0126.github.io/tags/ffi/"/>
    
  </entry>
  
  <entry>
    <title>loom-springboot</title>
    <link href="https://taeyang0126.github.io/2025/02/19/loom/loom-springboot/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/loom/loom-springboot/posts/undefined/</id>
    <published>2025-02-19T12:52:22.000Z</published>
    <updated>2025-02-19T12:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring-Boot-使用-project-loom"><a href="#Spring-Boot-使用-project-loom" class="headerlink" title="Spring Boot 使用 project loom"></a>Spring Boot 使用 project loom</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul><li>jdk 22.0.1-graal</li><li>maven 3.6.3</li><li>内置容器 tomcat，最大线程数量 256</li><li>Xms200M Xmx300M</li><li>压测条件: 1000线程 循环100次 Ramp-up&#x3D;10s</li><li>M1 max 64g</li><li>SpringBoot 3.3.0</li></ul><h5 id="普通线程，同步请求"><a href="#普通线程，同步请求" class="headerlink" title="普通线程，同步请求"></a>普通线程，同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>压测吞吐量253&#x2F;s，与配置最大线程 256 基本一致</li></ul><p><img data-src="/images/loom/img4.png" alt="img.png"></p><ul><li>内存、线程占用情况</li></ul><p><img data-src="/images/loom/img3.png" alt="普通线程.png"></p><h5 id="虚拟线程，异步servlet"><a href="#虚拟线程，异步servlet" class="headerlink" title="虚拟线程，异步servlet"></a>虚拟线程，异步servlet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/loom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">helloLoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回异步 -&gt; springmvc会处理为异步servlet，提升吞吐量</span></span><br><span class="line">    DeferredResult&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;();</span><br><span class="line">    Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setResult(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>压测吞吐量879&#x2F;s，大概是普通线程的3~4倍</li></ul><p><img data-src="/images/loom/img6.png" alt="&#x2F;images&#x2F;loom"></p><ul><li>内存、线程占用情况，可以发现虚拟线程的内存比普通线程占用要大<br>这个很好理解，因为开启的虚拟线程多了，虚拟线程也是对象，自然占用的内存会大一些</li></ul><p><img data-src="/images/loom/img5.png" alt="img.png"></p><h5 id="旧版本tomcat不支持异步线程"><a href="#旧版本tomcat不支持异步线程" class="headerlink" title="旧版本tomcat不支持异步线程"></a>旧版本tomcat不支持异步线程</h5><ul><li>版本9.0.60</li><li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法是用 <code>synchronized</code><br>包裹住的，导致虚拟线程无法卸载，这个版本下即使替换了tomcat线程池为虚拟线程池，也会造成阻塞<br><img data-src="/images/loom/img.png" alt="img.png"></li><li>之所以在这里需要使用锁是因为对于一个socket来说，需要保证并发安全，因为这里是在业务线程池executor执行的，会有多个线程访问同一个socket，这里的锁就是锁住每个连接，防止单个连接多个请求并发(题外话: netty高明之处就在于事件监听+事件处理都是用一个eventLoop，就不存在并发问题，如果使用者使用了异步线程池，也只需要在涉及channel的操作放到eventLoop中执行大概率不会有什么并发问题)</li><li>如果在此版本下想要支持虚拟线程，可以使用上面的方式，将同步servlet转换为异步servlet，再使用虚拟线程包裹一层</li></ul><h5 id="新版本tomcat支持异步线程"><a href="#新版本tomcat支持异步线程" class="headerlink" title="新版本tomcat支持异步线程"></a>新版本tomcat支持异步线程</h5><ul><li>版本10.1.24</li><li>org.apache.tomcat.util.net.SocketProcessorBase.run 方法调整为用 <code>ReentrantLock</code> 进行加锁，这样虚拟线程可以正常卸载<br><img data-src="/images/loom/img2.png" alt="img.png"></li><li>此版本下如何启用虚拟线程?<ol><li>自定义 <code>WebServerFactoryCustomizer</code> 修改tomcat执行线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadExecutorWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableTomcatWebServerFactory&gt;, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(ConfigurableTomcatWebServerFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newThreadPerTaskExecutor(Thread.ofVirtual().name(<span class="string">&quot;tomcat-virtual-&quot;</span>, <span class="number">0</span>).factory());</span><br><span class="line">        factory.addProtocolHandlerCustomizers(</span><br><span class="line">                (protocolHandler) -&gt; protocolHandler.setExecutor(executorService));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用框架自带的 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code></li><li>测试发现二者性能相差不大，可自行选择，不过 <code>TomcatVirtualThreadsWebServerFactoryCustomizer</code> 底层使用了反射，性能可能略有损耗，更推荐第一种自定义的</li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Spring-Boot-使用-project-loom&quot;&gt;&lt;a href=&quot;#Spring-Boot-使用-project-loom&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 使用 project loom&quot;&gt;&lt;/a&gt;Spring Boot 使用 project loom&lt;/h4&gt;&lt;h5 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;jdk 22.0.1-graal&lt;/li&gt;
&lt;li&gt;maven 3.6.3&lt;/li&gt;
&lt;li&gt;内置容器 tomcat，最大线程数量 256&lt;/li&gt;
&lt;li&gt;Xms200M Xmx300M&lt;/li&gt;
&lt;li&gt;压测条件: 1000线程 循环100次 Ramp-up&amp;#x3D;10s&lt;/li&gt;
&lt;li&gt;M1 max 64g&lt;/li&gt;
&lt;li&gt;SpringBoot 3.3.0&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/categories/loom/"/>
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/tags/loom/"/>
    
    <category term="虚拟线程" scheme="https://taeyang0126.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>loom</title>
    <link href="https://taeyang0126.github.io/2025/02/19/loom/loom/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/loom/loom/posts/undefined/</id>
    <published>2025-02-19T12:51:22.000Z</published>
    <updated>2025-02-19T12:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://wiki.openjdk.org/display/loom">openjdk loom</a></li><li><a href="https://openjdk.org/jeps/444">虚拟线程</a></li><li><a href="https://openjdk.org/jeps/480">结构化并发</a></li><li><a href="https://inside.java/2021/05/10/networking-io-with-virtual-threads/">虚拟线程网络IO实现原理</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html">Project Loom: Java虚拟机的纤程和计算续体</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html">State of Loom: part 1</a></li><li><a href="https://cr.openjdk.org/~rpressler/loom/loom/sol1_part2.html">State of Loom: part 2</a></li><li><a href="https://zhuanlan.zhihu.com/p/685013298">虚拟线程不推荐上生产的思考</a></li><li><a href="https://zhuanlan.zhihu.com/p/686222059">Java 虚拟线程截止 2024-3-10 在 OpenJDK 还没有解决消息的问题</a></li><li><a href="https://openjdk.org/jeps/481">Scoped Values</a></li></ul><h3 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h3><blockquote><p>We say that a virtual thread is <code>pinned</code> to its carrier if it is mounted but is in a state in which it cannot be unmounted. If a virtual thread blocks while pinned, it blocks its carrier. This behavior is still correct, but it holds on to a worker thread for the duration that the virtual thread is blocked, making it unavailable for other virtual threads.</p></blockquote><ul><li>Java 代码调用本地代码 (JNI)</li><li>synchronized 块或方法</li></ul><h4 id="减少pin发生"><a href="#减少pin发生" class="headerlink" title="减少pin发生"></a>减少pin发生</h4><ul><li>synchronized 保护的普通 I&#x2F;O 操作，请用 <code>ReentrantLock</code> 替换监视器，（如果可以的话，使用性能更高的 <code>StampedLock</code> 效果会更好）。</li></ul><h4 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h4><ol><li>Synchronization<ul><li>synchronized最终会解决，但是JNI不会处理</li><li>java.util.concurrent 中部分已经调整，比如LockSupport.park &#x2F; unpark 但是还有大部分的工作</li></ul></li><li>I&#x2F;O<ul><li>java.nio.channels 和 ServerSocketChannel 和 DatagramChannel 类改造为支持虚拟线程。当它们的同步操作（如 read 和 write ）在虚拟线程上执行时，在底层仅使用非阻塞 I&#x2F;O。</li><li>getHostName 、 getCanonicalHostName 和 getByName 方法的 DNS 查找仍然委托给操作系统,而操作系统仅提供一个阻塞操作系统线程的 API。正在探索替代方案。</li><li>Http(s)URLConnection 和 TLS&#x2F;SSL 的实现已更改为依赖 j.u.c 锁并避免pin</li><li>文件 I&#x2F;O 存在问题。内部,JDK 对文件使用缓冲 I&#x2F;O,即使读取操作会阻塞,也始终报告可用字节数。在 Linux 上,我们计划使用 io_uring 进行异步文件 I&#x2F;O,同时我们正在使用 ForkJoinPool.ManagedBlocker 机制,通过向工作池添加更多 OS 线程来平滑阻塞文件 I&#x2F;O 操作。</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.openjdk.org/display/loom&quot;&gt;openjdk loom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/444&quot;&gt;虚拟线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/480&quot;&gt;结构化并发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://inside.java/2021/05/10/networking-io-with-virtual-threads/&quot;&gt;虚拟线程网络IO实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html&quot;&gt;Project Loom: Java虚拟机的纤程和计算续体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html&quot;&gt;State of Loom: part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.org/~rpressler/loom/loom/sol1_part2.html&quot;&gt;State of Loom: part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/685013298&quot;&gt;虚拟线程不推荐上生产的思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/686222059&quot;&gt;Java 虚拟线程截止 2024-3-10 在 OpenJDK 还没有解决消息的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/jeps/481&quot;&gt;Scoped Values&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pin&quot;&gt;&lt;a href=&quot;#pin&quot; class=&quot;headerlink&quot; title=&quot;pin&quot;&gt;&lt;/a&gt;pin&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;We say that a virtual thread is &lt;code&gt;pinned&lt;/code&gt; to its carrier if it is mounted but is in a state in which it cannot be unmounted. If a virtual thread blocks while pinned, it blocks its carrier. This behavior is still correct, but it holds on to a worker thread for the duration that the virtual thread is blocked, making it unavailable for other virtual threads.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/categories/loom/"/>
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/tags/loom/"/>
    
    <category term="虚拟线程" scheme="https://taeyang0126.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jvm监控和故障处理工具</title>
    <link href="https://taeyang0126.github.io/2025/02/19/jvm/jvm-jian-kong-he-gu-zhang-chu-li-gong-ju/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/jvm/jvm-jian-kong-he-gu-zhang-chu-li-gong-ju/posts/undefined/</id>
    <published>2025-02-19T05:53:30.000Z</published>
    <updated>2025-02-19T05:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令行处理工具"><a href="#命令行处理工具" class="headerlink" title="命令行处理工具"></a>命令行处理工具</h3><h4 id="1-jps"><a href="#1-jps" class="headerlink" title="1. jps"></a>1. jps</h4><blockquote><p>显示指定系统类所有的HotSpot虚拟机进程</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有java进程，输出主类的名称</span></span><br><span class="line">jps -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机进程启动时传给主类main()函数的参数</span></span><br><span class="line">jps -m </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出虚拟机启动时JVM参数</span></span><br><span class="line">jps -v</span><br></pre></td></tr></table></figure><h4 id="2-jstat"><a href="#2-jstat" class="headerlink" title="2. jstat"></a>2. jstat</h4><blockquote><p>用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p></blockquote><blockquote><p>命令格式: jstat [ option vmind [interval[s|ms]] [count] ]-printcompilation</p></blockquote><ul><li>选项<code>option</code>代表用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况 使用 <code>jstat -options</code> 获取支持的options</li></ul><table><thead><tr><th>选项</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td><td><img data-src="/images/jvm/img.png" alt="img.png"></td></tr><tr><td>-gc</td><td>监视java堆状况</td><td><img data-src="/images/jvm/img2.png" alt="img.png">  <img data-src="/images/jvm/img3.png" alt="img.png"></td></tr><tr><td>-gccapacity</td><td>与-gc基本相同，主要关注堆各个区域使用到的最大最小空间</td><td><img data-src="/images/jvm/img4.png" alt="img.png"></td></tr><tr><td>-gcutil</td><td>与-gc基本相同，主要关注已使用空间占总空间的百分比</td><td><img data-src="/images/jvm/img5.png" alt="img.png"></td></tr><tr><td>-gccause</td><td>与-gcutil基本相同，但是会额外输出导致上一次GC产生的原因</td><td>LGCC: 上一次垃圾收集的原因 GCC: 触发垃圾收集的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td><td></td></tr><tr><td>-gcnewcapacity</td><td>与gcnew基本相同，主要关注使用到的最大、最小空间</td><td></td></tr><tr><td>-gcold</td><td>监视老年代GC状况</td><td></td></tr><tr><td>-gcoldcapacity</td><td>与gcold基本相同，主要关注使用到的最大、最小空间</td><td></td></tr><tr><td>-gcmetacapacity</td><td>metaspace用的最大、最小空间</td><td></td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td><td></td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td><td></td></tr></tbody></table><h4 id="3-jinfo"><a href="#3-jinfo" class="headerlink" title="3. jinfo"></a>3. jinfo</h4><blockquote><p>Java配置信息工具。使用<code>jps -v</code>可以查看虚拟机启动时显示指定的参数列表，如果想知道未被显示指定的参数的系统默认值，可以使用 jinfo 的 -flag 选项查询</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看进程所有的参数</span></span><br><span class="line">jinfo -flags #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个参数</span></span><br><span class="line">jinfo -flag UseG1GC #pid</span><br></pre></td></tr></table></figure><h4 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4. jmap"></a>4. jmap</h4><blockquote><p>jmap(Memory Map for Java) 命令用于生产堆快照(heapdump)。还可以查询finalize执行队列、java堆和metaspace的详细信息，如空间使用率、当前使用的是哪种收集器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 jmap 查看更多命令</span></span><br><span class="line">jmap </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示堆中对象统计信息，包括类、实例数量、合计容量</span></span><br><span class="line">jmap -histo:live,file=histo.data #pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成dump快照 在线分析工具 https://heaphero.io/</span></span><br><span class="line">jmap -dump:live,format=b,file=hh.bin #pid</span><br></pre></td></tr></table></figure><h4 id="5-jstack"><a href="#5-jstack" class="headerlink" title="5. jstack"></a>5. jstack</h4><blockquote><p>用于生成虚拟机当前时刻的线程快照</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前线程堆栈输出到某个文件</span></span><br><span class="line">jstack -l 17723 &gt; thread.info</span><br></pre></td></tr></table></figure><h4 id="6-jcmd"><a href="#6-jcmd" class="headerlink" title="6. jcmd"></a>6. jcmd</h4><blockquote><p>jcmd 是从 Java 7 开始引入的一个命令行工具。它提供了一种非常强大和灵活的方式来与 JVM 进行交互，可以用于诊断和监控 Java 应用程序。jcmd是以上工具的集合</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用命令</span></span><br><span class="line">jcmd &lt;pid&gt; help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 JVM 运行时信息</span></span><br><span class="line">jcmd &lt;pid&gt; VM.info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印堆转储</span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump &lt;filename&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印线程信息</span></span><br><span class="line">jcmd &lt;pid&gt; Thread.print</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印系统属性</span></span><br><span class="line">jcmd &lt;pid&gt; VM.system_properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 JVM 配置参数</span></span><br><span class="line">jcmd &lt;pid&gt; VM.flags</span><br></pre></td></tr></table></figure><h3 id="可视化处理工具"><a href="#可视化处理工具" class="headerlink" title="可视化处理工具"></a>可视化处理工具</h3><h4 id="1-JCconsole"><a href="#1-JCconsole" class="headerlink" title="1. JCconsole"></a>1. JCconsole</h4><blockquote><p>JConsole 是一个图形化界面，用于监控和配置 Java 应用程序。它提供了一些基本的监控功能，如线程、内存、垃圾回收、类加载等，并提供了插件机制，可以扩展到更复杂的监控需求。</p></blockquote><p>a. 启动JConsole</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位于jdk/bin目录下</span></span><br><span class="line">open `sdk home java 17.0.11-zulu`/bin/jconsole</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;命令行处理工具&quot;&gt;&lt;a href=&quot;#命令行处理工具&quot; class=&quot;headerlink&quot; title=&quot;命令行处理工具&quot;&gt;&lt;/a&gt;命令行处理工具&lt;/h3&gt;&lt;h4 id=&quot;1-jps&quot;&gt;&lt;a href=&quot;#1-jps&quot; class=&quot;headerlink&quot; title=&quot;1. jps&quot;&gt;&lt;/a&gt;1. jps&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;显示指定系统类所有的HotSpot虚拟机进程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="工具" scheme="https://taeyang0126.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>接口安全</title>
    <link href="https://taeyang0126.github.io/2025/02/12/an-quan/jie-kou-an-quan/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/12/an-quan/jie-kou-an-quan/posts/undefined/</id>
    <published>2025-02-12T13:01:22.000Z</published>
    <updated>2025-02-12T13:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/opus/917872422844104721">前后端安全性页面与接口设计</a></li><li><a href="https://www.bilibili.com/read/cv33868282/?opus_fallback=1">防刷机制</a></li></ul><h2 id="前后端安全性页面与接口设计"><a href="#前后端安全性页面与接口设计" class="headerlink" title="前后端安全性页面与接口设计"></a>前后端安全性页面与接口设计</h2><h3 id="接口安全密钥交换"><a href="#接口安全密钥交换" class="headerlink" title="接口安全密钥交换"></a>接口安全密钥交换</h3><blockquote><p>分为 web&#x2F;wap（轻客户端），android&#x2F;ios（受信任客户端） 两大类。</p></blockquote><ul><li>针对 web&#x2F;wap，首先通过 csrf 获取 RSA public key，然后通过 RSA public key，解密服务端对应你当前 session 的 AES Token，之后每次请求都是这个 AES Token 加密。首先 csrf 一定要内嵌在页面，不能放在 cookie，否则意义不大。这样 csrf 可以起到一定的保证页面是服务端渲染生成的效果csrf 需要加密，每次返回的不一样（将时间戳嵌入进去），但是其实对应的后台 csrf token 是同一个。公钥需要轮换：这是一个定时任务，就是后台保存的 wap&#x2F;web 密钥对，定时更新，上一个设置过期时间为 1 个月（我们前端 session 公钥过期时间最多是 2 周，无续期，保险点 1 个月）</li><li>针对 android&#x2F;ios，public key 针对每个版本会生成一个新的带到 app 里面服务端记录好，直接解密服务端对应你当前 session 的 AES Token，之后每次请求都是这个 AES Token 加密。由于 app 一般是受信任客户端，并且每个版本 public key 不一样，一般不用 csrf版本强制升级，也可以通过这个机制去实现。</li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul><li>https 是为了防止 wifi 劫持抓包直接能看到 http header 和 body</li><li>接口加密是为了防止机器人爬取，请求伪造，客户端模拟</li><li>android&#x2F;ios 通过 public key 基本能确定是哪个版本并且是我们信任的客户端，浏览器不能，所以加入 csrf token 在一定程度上确保一定是我们渲染的页面发的请求</li></ul><h3 id="安全-Header"><a href="#安全-Header" class="headerlink" title="安全 Header"></a>安全 Header</h3><ul><li>Strict-Transport-Security: max-age&#x3D;31536000; includeSubDomains; preload这个头部用于启用HTTP严格传输安全（HSTS），它告诉浏览器只能通过HTTPS来访问网站。max-age&#x3D;31536000 指定浏览器应该在接下来的31,536,000秒（1年）内记住只通过HTTPS访问站点。includeSubDomains 指令扩展了这个规则，使其也适用于当前域名的所有子域。preload 指令表示网站想要被包含在预加载的HSTS列表中，这些列表内置于浏览器中，即使是第一次请求也会强制使用HTTPS。</li><li>X-Content-Type-Options: nosniff这个头部是一个安全功能，用于防止浏览器尝试猜测（”嗅探”）资源的MIME类型，它强制浏览器遵守服务器提供的Content-Type头。nosniff选项可以防止一些基于MIME类型混淆的攻击，例如防止浏览器将非脚本文件解释为脚本文件。</li><li>X-Frame-Options: SAMEORIGIN这个头部可以防止页面被其他站点通过、、或嵌套，从而防止点击劫持攻击。SAMEORIGIN仅允许来自同一源的页面将当前页面作为、等嵌入。</li><li>Content-Security-Policy: 内容很长，这里省略这个拦截可能会导致某些三方埋点，图片等等显示失败，需要监控（即最后加上 report-uri &#x2F;api&#x2F;csp-report-endpoint?version&#x3D;5）这个上报的都是被拦截的，包括拦截的那些 js，css，jpg，长链接，视频资源等等这个 Header 变化很频繁，所以在 CDN 维护，随时修改。例如搜索引擎跳转你的网页，会嵌入 js 等，以及投放新的广告渠道商会嵌入其他东西等等&#x2F;api&#x2F;csp-report-endpoint 需要自己实现加入 version 参数，用于在你修改添加了新的白名单后，增加版本号，老的版本号的上报可以忽略（因为加这个 header 一般在 CDN 加，比如 Cloudflare，但是一般有很长缓存）</li></ul><h4 id="一个允许-google-和-facebook-所有资源的-Content-Security-Policy-示例"><a href="#一个允许-google-和-facebook-所有资源的-Content-Security-Policy-示例" class="headerlink" title="一个允许 google 和 facebook 所有资源的 Content-Security-Policy 示例"></a>一个允许 google 和 facebook 所有资源的 Content-Security-Policy 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-src &#x27;self&#x27; data: &#x27;unsafe-inline&#x27; blob: &#x27;unsafe-eval&#x27; *.google-analytics.com *.googletagmanager.com *.gstatic.com *.googleapis.com *.google.co *.google.com *.google.ad *.google.ae *.google.com.af *.google.com.ag *.google.al *.google.am *.google.co.ao *.google.com.ar *.google.as *.google.at *.google.com.au *.google.az *.google.ba *.google.com.bd *.google.be *.google.bf *.google.bg *.google.com.bh *.google.bi *.google.bj *.google.com.bn *.google.com.bo *.google.com.br *.google.bs *.google.bt *.google.co.bw *.google.by *.google.com.bz *.google.ca *.google.cd *.google.cf *.google.cg *.google.ch *.google.ci *.google.co.ck *.google.cl *.google.cm *.google.cn *.google.com.co *.google.co.cr *.google.com.cu *.google.cv *.google.com.cy *.google.cz *.google.de *.google.dj *.google.dk *.google.dm *.google.com.do *.google.dz *.google.com.ec *.google.ee *.google.com.eg *.google.es *.google.com.et *.google.fi *.google.com.fj *.google.fm *.google.fr *.google.ga *.google.ge *.google.gg *.google.com.gh *.google.com.gi *.google.gl *.google.gm *.google.gr *.google.com.gt *.google.gy *.google.com.hk *.google.hn *.google.hr *.google.ht *.google.hu *.google.co.id *.google.ie *.google.co.il *.google.im *.google.co.in *.google.iq *.google.is *.google.it *.google.je *.google.com.jm *.google.jo *.google.co.jp *.google.co.ke *.google.com.kh *.google.ki *.google.kg *.google.co.kr *.google.com.kw *.google.kz *.google.la *.google.com.lb *.google.li *.google.lk *.google.co.ls *.google.lt *.google.lu *.google.lv *.google.com.ly *.google.co.ma *.google.md *.google.me *.google.mg *.google.mk *.google.ml *.google.com.mm *.google.mn *.google.com.mt *.google.mu *.google.mv *.google.mw *.google.com.mx *.google.com.my *.google.co.mz *.google.com.na *.google.com.ng *.google.com.ni *.google.ne *.google.nl *.google.no *.google.com.np *.google.nr *.google.nu *.google.co.nz *.google.com.om *.google.com.pa *.google.com.pe *.google.com.pg *.google.com.ph *.google.com.pk *.google.pl *.google.pn *.google.com.pr *.google.ps *.google.pt *.google.com.py *.google.com.qa *.google.ro *.google.ru *.google.rw *.google.com.sa *.google.com.sb *.google.sc *.google.se *.google.com.sg *.google.sh *.google.si *.google.sk *.google.com.sl *.google.sn *.google.so *.google.sm *.google.sr *.google.st *.google.com.sv *.google.td *.google.tg *.google.co.th *.google.com.tj *.google.tl *.google.tm *.google.tn *.google.to *.google.com.tr *.google.tt *.google.com.tw *.google.co.tz *.google.com.ua *.google.co.ug *.google.co.uk *.google.com.uy *.google.co.uz *.google.com.vc *.google.co.ve *.google.co.vi *.google.com.vn *.google.vu *.google.ws *.google.rs *.google.co.za *.google.co.zm *.google.co.zw *.google.cat *.googleadservices.com facebook.net *.facebook.net facebook.com *.facebook.com; report-uri /api/csp-report-endpoint?version=2</span><br></pre></td></tr></table></figure><h3 id="一些反思"><a href="#一些反思" class="headerlink" title="一些反思"></a>一些反思</h3><ul><li>针对渲染的页面，内嵌 csrf token（注意不能放在 cookie，否则意义不大），至于服务器渲染，这个我们也是前后端分离，前端自己维护自己的 nodejs 服务器。前后端分离，但是最好还是有一个类似于中台的前端服务器前端自己维护，这样 SEO 更好做。</li><li>这些只是加固了安全性，但是并不能保证 100% 安全。但是复杂度已经很高了，目前够用了。</li><li>并且在这些机制的基础上，去做 <strong>2FA 或者 MFA 也更好做</strong>，有利于减少 2FA 对于用户的打扰。</li></ul><h2 id="防刷机制"><a href="#防刷机制" class="headerlink" title="防刷机制"></a>防刷机制</h2><h3 id="防刷子机制"><a href="#防刷子机制" class="headerlink" title="防刷子机制"></a>防刷子机制</h3><p>主要分为两种场景：</p><ol><li><strong>针对未登录或者未注册用户</strong>，对于注册，各种验证码等类似的接口进行防刷机制，同时尽量减少对于用户的打扰。</li><li><strong>针对已经登陆的用户</strong>：<ol><li>参与活动设置必要的门槛：比如最近交易量。</li><li>引入 MFA 之后，限制用户只能通过绑定的 MFA 的设备参与活动。</li></ol></li></ol><p><strong>针对 2 其实主要是从业务的角度考虑</strong>，MFA 机制不仅是安全性的保证，MFA 更是利于验证用户设备有效，从而可以使用设备做一些业务的限制。</p><p><strong>针对 1，可以使用以下的机制减少验证码对于用户的打扰</strong>：</p><ol><li>使用类似于 Google reCAPTCHA Enterprise（reCAPTCHA v3）或者国内可以用 hCAPTCHA Enterprise 服务，针对敏感接口，例如注册，短信 OTP 接口等等接入，每次请求会带上一个 Google Recaptcha Enterprise 的评分：<ol><li>reCAPTCHA v3 在用户浏览网站时连续地评估用户行为。这包括用户与页面的交互方式（如鼠标移动、滚动、点击等）、设备和浏览器的信息。它还可能分析用户在整个会话中的行为，包括访问多个页面的顺序和速度。</li><li>基于这些行为分析，reCAPTCHA v3 为每个用户请求分配一个分数，范围从 0.0 到 1.0。分数越接近 1.0 表示系统越认为该行为来自真实人类，分数越低则越可能是由自动化脚本或机器人产生。这里是一个分数分布的例子：</li></ol></li></ol><p><img data-src="/images/security/01.avif" alt="img"></p><ol start="2"><li><p>你的后台根据这个分数（笔者这里是针对所有低于 0.8 的请求），请求响应是需要验证码才能继续。这里的验证码实现方案就很多很多了，笔者就不赘述了。</p></li><li><p>也就是，对于大部分用户，注册的时候，其实连验证码都不需要输入。对于评分比较低的用户才去让用户接受挑战（challenge），或者是输入验证码，或者是其他挑战方式。</p></li></ol><p>为何不建议使用 ip + 设备封禁或者限流（限流并不是禁止访问，而是跳转或者弹出验证码）？相较于上面的手段，对于用户的打扰比较多。同时 ip 和设备比较容易伪造（ip 可以通过 vpn，设备可以模拟等等），并且，现在的浏览器的发展趋势是 user-agent 趋于统一，暴露的信息越来越少：</p><p><a href="https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version?hl=zh-cn">https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version?hl=zh-cn</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/opus/917872422844104721&quot;&gt;前后端安全性页面与接口设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/read/cv33868282/?opus_fallback=1&quot;&gt;防刷机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前后端安全性页面与接口设计&quot;&gt;&lt;a href=&quot;#前后端安全性页面与接口设计&quot; class=&quot;headerlink&quot; title=&quot;前后端安全性页面与接口设计&quot;&gt;&lt;/a&gt;前后端安全性页面与接口设计&lt;/h2&gt;&lt;h3 id=&quot;接口安全密钥交换&quot;&gt;&lt;a href=&quot;#接口安全密钥交换&quot; class=&quot;headerlink&quot; title=&quot;接口安全密钥交换&quot;&gt;&lt;/a&gt;接口安全密钥交换&lt;/h3&gt;</summary>
    
    
    
    <category term="安全" scheme="https://taeyang0126.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="https://taeyang0126.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="防刷" scheme="https://taeyang0126.github.io/tags/%E9%98%B2%E5%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>Netty中的细节优化</title>
    <link href="https://taeyang0126.github.io/2025/02/12/netty/netty-zhong-de-xi-jie-you-hua/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/12/netty/netty-zhong-de-xi-jie-you-hua/posts/undefined/</id>
    <published>2025-02-12T12:02:22.000Z</published>
    <updated>2025-02-12T12:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率"><a href="#优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率" class="headerlink" title="优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率"></a>优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率</h3><ul><li>优化代码 <code>io.netty.channel.nio.NioEventLoop#openSelector</code></li><li>原生的 jdk selector 实现是 <code>sun.nio.ch.SelectorImpl</code> 其中 IO 就绪事件存放容器是<code>Set</code></li></ul><p><img data-src="/images/netty/01.png" alt="netty"></p><ul><li><code>SelectedSelectionKeySet</code> 底层使用数组存储，减少了插入时的 hash 碰撞，遍历时又能利用 cpu 缓存提升效率</li></ul><p><img data-src="/images/netty/02.png" alt="netty"></p><h3 id="优化客户端-channel-选择-reactor-的效率"><a href="#优化客户端-channel-选择-reactor-的效率" class="headerlink" title="优化客户端 channel 选择 reactor 的效率"></a>优化客户端 channel 选择 reactor 的效率</h3><ul><li>从 reactor 数量是 2 的倍数时使用 &amp; 运算</li></ul><p><img data-src="/images/netty/03.png" alt="netty"></p><ul><li>从 reactor 数量不是 2 的倍数时使用取模运算</li></ul><p><img data-src="/images/netty/04.png" alt="netty"></p><h3 id="解决-JDK-epoll-空轮训-bug"><a href="#解决-JDK-epoll-空轮训-bug" class="headerlink" title="解决 JDK epoll 空轮训 bug"></a>解决 JDK epoll 空轮训 bug</h3><p>由于<code>JDK NIO Epoll的空轮询BUG</code>存在，这样会导致<code>Reactor线程</code>在没有任何事情可做的情况下被意外唤醒，导致 CPU 空转。</p><p>其实 Netty 也没有从根本上解决这个<code>JDK BUG</code>，而是选择巧妙的绕过这个<code>BUG</code></p><p><img data-src="/images/netty/05.png" alt="netty"></p><h3 id="对象池的设计"><a href="#对象池的设计" class="headerlink" title="对象池的设计"></a>对象池的设计</h3><ul><li>stack 是对象池中真正用来存储池化对象的地方；为了避免这种不必要的同步竞争，Netty 也采用了类似 TLAB 分配内存的方式，每个线程拥有一个独立 Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的 Stack 中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率&quot;&gt;&lt;a href=&quot;#优化-jdk-原生-selector-中-IO-就绪事件的插入和遍历效率&quot; class=&quot;headerlink&quot; title=&quot;优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率&quot;&gt;&lt;/a&gt;优化 jdk 原生 selector 中 IO 就绪事件的插入和遍历效率&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;优化代码 &lt;code&gt;io.netty.channel.nio.NioEventLoop#openSelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原生的 jdk selector 实现是 &lt;code&gt;sun.nio.ch.SelectorImpl&lt;/code&gt; 其中 IO 就绪事件存放容器是&lt;code&gt;Set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/netty/01.png&quot; alt=&quot;netty&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/tags/Netty/"/>
    
    <category term="源码解析" scheme="https://taeyang0126.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>4-Netty对象池</title>
    <link href="https://taeyang0126.github.io/2025/02/12/netty/4.netty-dui-xiang-chi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/12/netty/4.netty-dui-xiang-chi/posts/undefined/</id>
    <published>2025-02-12T12:01:22.000Z</published>
    <updated>2025-02-12T12:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/483115037">Recycler对象池的精妙设计与实现</a></li></ul><h2 id="对象池-Recycler-的使用"><a href="#对象池-Recycler-的使用" class="headerlink" title="对象池 Recycler 的使用"></a>对象池 Recycler 的使用</h2><p><img data-src="/images/netty/04_01.png" alt="netty"></p><blockquote><h4 id="对象池在-PooledDirectByteBuf-类中的使用"><a href="#对象池在-PooledDirectByteBuf-类中的使用" class="headerlink" title="对象池在 PooledDirectByteBuf 类中的使用"></a>对象池在 PooledDirectByteBuf 类中的使用</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title class_">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="comment">//创建对象池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER = ObjectPool.newPool(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ObjectCreator</span>&lt;PooledDirectByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledDirectByteBuf <span class="title function_">newObject</span><span class="params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PooledDirectByteBuf</span>(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象在对象池中的回收句柄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PooledDirectByteBuf <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> maxCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//从对象池中获取对象</span></span><br><span class="line">        <span class="type">PooledDirectByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//回收对象</span></span><br><span class="line">        recyclerHandle.recycle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ................省略和对象池无关的代码..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="对象池在-Channel-写入缓冲队列中的使用"><a href="#对象池在-Channel-写入缓冲队列中的使用" class="headerlink" title="对象池在 Channel 写入缓冲队列中的使用"></a>对象池在 Channel 写入缓冲队列中的使用</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class="keyword">new</span> <span class="title class_">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Entry <span class="title function_">newObject</span><span class="params">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(handle);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//recyclerHandle用于回收对象</span></span><br><span class="line">       <span class="keyword">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Entry</span><span class="params">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.handle = handle;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Recycler-总体设计"><a href="#Recycler-总体设计" class="headerlink" title="Recycler 总体设计"></a>Recycler 总体设计</h2><p><img data-src="/images/netty/04_02.png" alt="netty"></p><ul><li>从创建线程视角来看<ul><li>为了减少多线程从对象池获取对象时的并发操作，Recycle 使用了类似<code>TLAB</code>的分配方式；每个创建线程独立从<code>Stack</code>中分配对象</li><li><img data-src="/images/netty/04_03.png" alt="netty"></li><li>Stack 对象底层使用数组<code>DefaultHandle&lt;?&gt;[] elements</code>存储回收的池化对象</li></ul></li><li>从回收线程视角来看<ul><li><code>WeakOrderQueue</code> 表示回收线程存储待回收池化对象的地方（之所以这么设计还是为了无锁化的回收对象，避免多线程回收场景的同步竞争）</li></ul></li></ul><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><blockquote><p>Stack 中包含一个用数组实现的栈结构，这个栈结构正是对象池中真正用于存储池化对象的地方，每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中</p></blockquote><ul><li>数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的 Stack 用来存储由该线程创建出来并回收到对象池中的对象。</li><li>WeakOrderQueue 链表，head 指针指向 WeakOrderQueue 链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue 链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中 WeakOrderQueue 链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的 WeakOrderQueue 节点中。</li><li>当创建线程获取对象时，只会从 Stack 结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。当 Stack 结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历 Stack 结构中的 WeakOrderQueue 链表，将当前 WeakOrderQueue 节点存放的待回收对象转移至数组栈中。如果 WeakOrderQueue 链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。</li></ul><h3 id="WeakOrderQueue"><a href="#WeakOrderQueue" class="headerlink" title="WeakOrderQueue"></a>WeakOrderQueue</h3><p><img data-src="/images/netty/04_04.png" alt="netty"></p><ul><li>WeakOrderQueue 的结构其实是一个链表结构。其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。</li><li>链表中的元素类型为 Link 类型，Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。</li><li>Link 类型中还包含了 readIndex 用来指示当前 elements 数组中的读取位置。writeIndex 用来指示 elements 数组的写入位置。elements 数组中的容量默认为<code>16</code>，也就是说一个 Link 节点最多可以存放 16 个待回收对象。当回收线程收集的待回收对象超过 16 个时，就会新创建一个 Link 节点插入到 Link 链表的尾部。</li><li>当需要将 WeakoOrderQueue 节点中所存放的待回收对象回收转移至其对应的 Stack 结构中的数组栈中时，创建线程会遍历当前 WeakOrderQueue 节点中的 Link 链表，然后从链表的 Head 节点开始，将 Head 节点中包裹的 Link 链表头结点中存放的待回收对象回收至创建线程对应的 Stack 中。一次最多转移一个 Link 大小的待回收对象（16 个）。</li><li>当 Link 节点中的待回收对象全部转移至创建线程对应的 Stack 中时，会立马将这个 Link 节点从当前 WeakOrderQueue 节点中的 Link 链表里删除，随后 Head 节点向后移动指向下一个 Link 节点。</li><li>head 指针始终指向第一个未被转移完毕的 Link 节点，创建线程从 head 节点处读取转移待回收对象，回收线程从 Tail 节点处插入待回收对象。这样转移操作和插入操作互不影响、没有同步的开销。</li></ul><h3 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h3><h4 id="对象池中的容量控制"><a href="#对象池中的容量控制" class="headerlink" title="对象池中的容量控制"></a>对象池中的容量控制</h4><p><img data-src="/images/netty/04_05.png" alt="netty"></p><ul><li><code>DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</code>：定义每个创建线程对应的 Stack 结构中的数组栈初始默认的最大容量。默认为 4096 个。可由 JVM 启动参数 <code>-D io.netty.recycler.maxCapacity</code> 指定。</li><li><code>DEFAULT_MAX_CAPACITY_PER_THREAD</code>：定义每个创建线程对应的 Stack 结构中的数组栈的最大容量。可由 JVM 启动参数 <code>-D io.netty.recycler.maxCapacityPerThread</code> 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为 4096 个。</li><li><code>INITIAL_CAPACITY </code>： 定义每个创建线程对应的 Stack 结构中的数组栈的初始容量。计算公式为<code>min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)</code>，默认为 256 个。当池化对象超过 256 个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。</li></ul><h4 id="回收线程可回收对象的容量控制"><a href="#回收线程可回收对象的容量控制" class="headerlink" title="回收线程可回收对象的容量控制"></a>回收线程可回收对象的容量控制</h4><ul><li><code>MAX_SHARED_CAPACITY_FACTOR</code> : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为 2。可通过 JVM 参数 <code>-D io.netty.recycler.maxSharedCapacityFactor</code> 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code> 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为 2048 个，最小回收容量为 LINK_CAPACITY 默认为 16。</li><li><code>MAX_DELAYED_QUEUES_PER_THREAD</code> : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU 核数 * 2。可通过 JVM 参数 <code>-D io.netty.recycler.maxDelayedQueuesPerThread</code> 指定。注意：这里是站在回收线程的角度。</li><li><code>LINK_CAPACITY </code>： 在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的 WeakOrderQueue 节点中的 Link 链表中的 Link 节点存储待回收对象的容量。默认为 16，可通过 JVM 参数 <code>-D io.netty.recycler.linkCapacity</code> 指定。</li></ul><h4 id="对象回收频率控制"><a href="#对象回收频率控制" class="headerlink" title="对象回收频率控制"></a>对象回收频率控制</h4><ul><li><code>RATIO</code>： 创建线程回收对象时的回收比例，默认是 8，表示只回收 1&#x2F;8 的对象。也就是产生 8 个对象回收一个对象到对象池中。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为 8，可由 JVM 启动参数 <code>-D io.netty.recycler.ratio</code> 指定。表示创建线程只回收 1 &#x2F; 8 的对象，也就是每创建 8 个对象最后只回收 1 个对象。</li><li><code>DELAYED_QUEUE_RATIO</code>：回收线程回收对象时的回收比例，默认也是 8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是 1&#x2F;8。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的 Stack 中。所以回收线程就需要将池化对象回收至其创建线程对应的 Stack 中的 WeakOrderQueue 链表中。并等待创建线程将 WeakOrderQueue 链表中的待回收对象转移至 Stack 中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是 8，可由 JVM 启动参数 <code>-D io.netty.recycler.delayedQueue.ratio</code> 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。</li></ul><h3 id="从对象池中获取对象"><a href="#从对象池中获取对象" class="headerlink" title="从对象池中获取对象"></a>从对象池中获取对象</h3><p><img data-src="/images/netty/04_06.png" alt="netty"></p><h3 id="从Stack中获取池化对象"><a href="#从Stack中获取池化对象" class="headerlink" title="从Stack中获取池化对象"></a>从Stack中获取池化对象</h3><p><img data-src="/images/netty/04_07.png" alt="netty"></p><h3 id="转移回收线程回收的对象到Stack中"><a href="#转移回收线程回收的对象到Stack中" class="headerlink" title="转移回收线程回收的对象到Stack中"></a>转移回收线程回收的对象到Stack中</h3><p><img data-src="/images/netty/04_08.png" alt="netty"></p><p><img data-src="/images/netty/04_09.png" alt="netty"></p><h3 id="从WeakOrderQueue中转移回收对象"><a href="#从WeakOrderQueue中转移回收对象" class="headerlink" title="从WeakOrderQueue中转移回收对象"></a>从WeakOrderQueue中转移回收对象</h3><p><img data-src="/images/netty/04_10.png" alt="netty"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/483115037&quot;&gt;Recycler对象池的精妙设计与实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;对象池-Recycler-的使用&quot;&gt;&lt;a href=&quot;#对象池-Recycler-的使用&quot; class=&quot;headerlink&quot; title=&quot;对象池 Recycler 的使用&quot;&gt;&lt;/a&gt;对象池 Recycler 的使用&lt;/h2&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/tags/Netty/"/>
    
    <category term="源码解析" scheme="https://taeyang0126.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>3-Netty接收网络连接</title>
    <link href="https://taeyang0126.github.io/2025/02/12/netty/3.netty-jie-shou-wang-luo-lian-jie/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/12/netty/3.netty-jie-shou-wang-luo-lian-jie/posts/undefined/</id>
    <published>2025-02-12T12:00:22.000Z</published>
    <updated>2025-02-12T12:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/466019443">Netty是如何高效接收网络连接的</a></li><li><a href="https://zhuanlan.zhihu.com/p/471122992">ByteBuffer动态自适应扩缩容机制</a></li></ul><h2 id="Main-Reactor-处理-OP-ACCEPT-事件"><a href="#Main-Reactor-处理-OP-ACCEPT-事件" class="headerlink" title="Main Reactor 处理 OP_ACCEPT 事件"></a>Main Reactor 处理 OP_ACCEPT 事件</h2><ul><li>Netty 将<code>OP_ACCEPT事件</code>处理的入口函数封装在<code>NioServerSocketChannel</code>里的底层操作类 Unsafe 的<code>read</code>方法中 –&gt; <code>AbstractNioMessageChannel</code></li></ul><blockquote><p>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</p></blockquote><ul><li>接收连接过程如下</li></ul><p><img data-src="/images/netty/03_01.PNG" alt="netty"></p><ul><li><strong><code>MaxMessageHandle#maxMessagePerRead</code></strong>： 用于控制每次 read loop 里最大可以循环读取的次数，默认为 16 次，可在启动配置类<code>ServerBootstrap</code>中通过<code>ChannelOption.MAX_MESSAGES_PER_READ</code>选项设置。</li><li>客户端<code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>，而服务端<code>NioServerSocketChannel</code>继承的是<code>AbstractNioMessageChannel</code></li></ul><blockquote><p>客户端<code>NioSocketChannel</code>主要处理的是服务端与客户端的通信，这里涉及到接收客户端发送来的数据，而<code>Sub Reactor线程</code>从<code>NioSocketChannel</code>中读取的正是网络通信数据单位为<code>Byte</code>。 服务端<code>NioServerSocketChannel</code>主要负责处理<code>OP_ACCEPT事件</code>，创建用于通信的客户端<code>NioSocketChannel</code>。这时候客户端与服务端还没开始通信，所以<code>Main Reactor线程</code>从<code>NioServerSocketChannel</code>的读取对象为<code>Message</code>。这里的<code>Message</code>指的就是底层的<code>SocketChannel</code>客户端连接。</p></blockquote><p><img data-src="/images/netty/03_02.PNG" alt="netty"></p><h2 id="接收网络数据总览"><a href="#接收网络数据总览" class="headerlink" title="接收网络数据总览"></a>接收网络数据总览</h2><p><img data-src="/images/netty/03_03.PNG" alt="netty"></p><ul><li>Netty 服务端对于一次 OP_READ 事件的处理，会在一个<code>do&#123;&#125;while()</code>循环 read loop 中分多次从客户端 NioSocketChannel 中读取网络数据。每次读取我们分配的 ByteBuffer 容量大小，初始容量为 2048</li></ul><h2 id="ChannelRead-与-ChannelReadComplete-事件的区别"><a href="#ChannelRead-与-ChannelReadComplete-事件的区别" class="headerlink" title="ChannelRead 与 ChannelReadComplete 事件的区别"></a>ChannelRead 与 ChannelReadComplete 事件的区别</h2><ul><li><code>ChanneRead事件</code>：一次循环读取一次数据，就触发一次<code>ChannelRead事件</code>。本次最多读取在 read loop 循环开始分配的 DirectByteBuffer 容量大小。这个容量会动态调整。</li><li><code>ChannelReadComplete事件</code>：当读取不到数据或者不满足<code>continueReading</code>的任意一个条件就会退出 read loop，这时就会触发<code>ChannelReadComplete事件</code>。表示本次<code>OP_READ事件</code>处理完毕。</li></ul><blockquote><p>这里需要特别注意下触发<code>ChannelReadComplete事件</code>并不代表 NioSocketChannel 中的数据已经读取完了，只能说明本次<code>OP_READ事件</code>处理完毕。因为有可能是客户端发送的数据太多，Netty 读了<code>16次</code>还没读完，那就只能等到下次<code>OP_READ事件</code>到来的时候在进行读取了。</p></blockquote><h2 id="AdaptiveRecvByteBufAllocator"><a href="#AdaptiveRecvByteBufAllocator" class="headerlink" title="AdaptiveRecvByteBufAllocator"></a>AdaptiveRecvByteBufAllocator</h2><p>AdaptiveRecvByteBufAllocator 主要的作用就是为接收数据的<code>ByteBuffer</code>进行扩容缩容，那么每次怎么扩容？扩容多少？怎么缩容？缩容多少呢？？</p><h3 id="容量索引表"><a href="#容量索引表" class="headerlink" title="容量索引表"></a>容量索引表</h3><blockquote><p>Netty 中定义了一个<code>int型</code>的数组<code>SIZE_TABLE</code>来存储每个扩容单位对应的容量大小。建立起扩缩容的容量索引表。每次扩容多少，缩容多少全部记录在这个容量索引表中</p></blockquote><ul><li>在 AdaptiveRecvByteBufAllocatorl 类初始化的时候会在<code>static&#123;&#125;</code>静态代码块中对扩缩容索引表<code>SIZE_TABLE</code>进行初始化</li><li>当索引容量小于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是从<code>16开始</code>按<code>16</code>递增</li></ul><p><img data-src="/images/netty/03_04.PNG" alt="netty"></p><ul><li>当索引容量大于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是按前一个索引容量的 2 倍递增</li></ul><p><img data-src="/images/netty/03_05.PNG" alt="netty"></p><h3 id="扩缩容逻辑"><a href="#扩缩容逻辑" class="headerlink" title="扩缩容逻辑"></a>扩缩容逻辑</h3><blockquote><p>AdaptiveRecvByteBufAllocator 类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>，缩容步长<code>INDEX_DECREMENT = 1</code></p></blockquote><p>假设当前<code>ByteBuffer</code>的容量索引为<code>33</code>，对应的容量为<code>2048</code></p><ul><li>扩容</li></ul><p>当对容量为<code>2048</code>的 ByteBuffer 进行扩容时，根据当前的容量索引<code>index = 33</code> 加上 扩容步长<code>INDEX_INCREMENT = 4</code>计算出扩容后的容量索引为<code>37</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>37</code>对应的容量就是本次 ByteBuffer 扩容后的容量<code>SIZE_TABLE[37] = 32768</code></p><ul><li>缩容</li></ul><p>同理对容量为<code>2048</code>的 ByteBuffer 进行缩容时，我们就需要用当前容量索引<code>index = 33</code> 减去 缩容步长<code>INDEX_DECREMENT = 1</code>计算出缩容后的容量索引<code>32</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>32</code>对应的容量就是本次 ByteBuffer 缩容后的容量<code>SIZE_TABLE[32] = 1024</code></p><ul><li>扩缩容时机<ul><li>每轮 read loop 结束之后，我们都会调用<code>allocHandle.readComplete()</code>来根据在 allocHandle 中统计的在本轮 read loop 中读取字节总大小，来决定在下一轮 read loop 中是否对 DirectByteBuffer 进行扩容或者缩容</li></ul></li></ul><p><img data-src="/images/netty/03_06.png" alt="netty"></p><ul><li><code>DEFAULT_INITIAL</code>： 表示 ByteBuffer 的初始化容量。默认为<code>2048</code>。对应的 index&#x3D;33</li><li><code>DEFAULT_MINIMUM</code>： 表示 ByteBuffer 最小的容量，默认为<code>64</code>，也就是无论 ByteBuffer 在怎么缩容，容量也不会低于<code>64</code>，对应的 index&#x3D;3</li><li><code>DEFAULT_MAXIMUM</code>： 表示 ByteBuffer 的最大容量，默认为<code>65536</code>，也就是无论 ByteBuffer 在怎么扩容，容量也不会超过<code>65536</code>，对应的 index&#x3D;38</li><li>如果本次<code>OP_READ事件</code>实际读取到的总字节数<code>actualReadBytes</code>在 SIZE_TABLE[index - INDEX_DECREMENT]与 SIZE_TABLE[index]之间的话，也就是如果本轮 read loop 结束之后总共读取的字节数在<code>[1024,2048]</code>之间。说明此时分配的<code>ByteBuffer</code>容量正好，不需要进行缩容也不需要进行扩容。 比如本次<code>actualReadBytes = 2000</code>，正好处在<code>1024</code>与<code>2048</code>之间。说明<code>2048</code>的容量正好</li><li>如果<code>actualReadBytes</code> 小于等于 SIZE_TABLE[index - INDEX_DECREMENT]，也就是如果本轮 read loop 结束之后总共读取的字节数小于等于<code>1024</code>。表示本次读取到的字节数比当前 ByteBuffer 容量的下一级容量还要小，说明当前 ByteBuffer 的容量分配的有些大了，设置缩容标识<code>decreaseNow = true</code>。当下次<code>OP_READ事件</code>继续满足缩容条件的时候，开始真正的进行缩容。缩容后的容量为 SIZE_TABLE[index - INDEX_DECREMENT]，但不能小于 SIZE_TABLE[minIndex]</li></ul><blockquote><p>注意需要满足两次缩容条件才会进行缩容，且缩容步长为 1，缩容比较谨慎</p></blockquote><ul><li>如果本次<code>OP_READ事件</code>处理总共读取的字节数<code>actualReadBytes</code> 大于等于 当前 ByteBuffer 容量（nextReceiveBufferSize）时，说明 ByteBuffer 分配的容量有点小了，需要进行扩容。扩容后的容量为 SIZE_TABLE[index + INDEX_INCREMENT]，但不能超过 SIZE_TABLE[maxIndex]。</li></ul><blockquote><p>满足一次扩容条件就进行扩容，并且扩容步长为 4， 扩容比较奔放</p></blockquote><h2 id="PooledByteBufAllocator"><a href="#PooledByteBufAllocator" class="headerlink" title="PooledByteBufAllocator"></a>PooledByteBufAllocator</h2><blockquote><p><code>AdaptiveRecvByteBufAllocator</code>类只是负责动态调整 ByteBuffer 的容量，而具体为 ByteBuffer 申请内存空间的是由<code>PooledByteBufAllocator</code>负责</p></blockquote><ul><li>当数据达到网卡时，网卡会通过 DMA 的方式将数据拷贝到内核空间中，这是<code>第一次拷贝</code>。当用户线程在用户空间发起系统 IO 调用时，CPU 会将内核空间的数据再次拷贝到用户空间。这是<code>第二次拷贝</code>。于此不同的是当我们在 JVM 中发起 IO 调用时，比如我们使用 JVM 堆内存读取<code>Socket接收缓冲区</code>中的数据时，会多一次内存拷贝，CPU 在<code>第二次拷贝</code>中将数据从内核空间拷贝到用户空间时，此时的用户空间站在 JVM 角度是<code>堆外内存</code>，所以还需要将堆外内存中的数据拷贝到<code>堆内内存</code>中。这就是<code>第三次内存拷贝</code>。同理当我们在 JVM 中发起 IO 调用向<code>Socket发送缓冲区</code>写入数据时，JVM 会将 IO 数据先<code>拷贝</code>到<code>堆外内存</code>，然后才能发起系统 IO 调用。</li><li>Netty 在进行 I&#x2F;O 操作时都是使用的堆外内存，采用堆外内存为 ByteBuffer 分配内存的好处：<ul><li>堆外内存直接受操作系统的管理，不会受 JVM 的管理，所以 JVM 垃圾回收对应用程序的性能影响就没有了</li><li>网络数据到达之后直接在<code>堆外内存</code>上接收，进程读取网络数据时直接在堆外内存中读取，所以就避免了<code>第三次内存拷贝</code></li></ul></li><li>由于堆外内存不受 JVM 的管理，所以就需要额外关注对内存的使用和释放，稍有不慎就会造成内存泄露，于是 Netty 就引入了内存池对<code>堆外内存</code>进行统一管理</li><li>PooledByteBufAllocator 类的这个前缀<code>Pooled</code>就是<code>内存池</code>的意思，这个类会使用 Netty 的内存池为 ByteBuffer 分配<code>堆外内存</code></li><li>io.netty.channel.DefaultChannelConfig#allocator -&gt;</li></ul><p><img data-src="/images/netty/03_07.png" alt="netty"></p><p><img data-src="/images/netty/03_08.png" alt="netty"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/466019443&quot;&gt;Netty是如何高效接收网络连接的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/471122992&quot;&gt;ByteBuffer动态自适应扩缩容机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Main-Reactor-处理-OP-ACCEPT-事件&quot;&gt;&lt;a href=&quot;#Main-Reactor-处理-OP-ACCEPT-事件&quot; class=&quot;headerlink&quot; title=&quot;Main Reactor 处理 OP_ACCEPT 事件&quot;&gt;&lt;/a&gt;Main Reactor 处理 OP_ACCEPT 事件&lt;/h2&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/tags/Netty/"/>
    
    <category term="源码解析" scheme="https://taeyang0126.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2-Reactor线程运转架构</title>
    <link href="https://taeyang0126.github.io/2025/02/10/netty/2.reactor-xian-cheng-yun-zhuan-jia-gou/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/10/netty/2.reactor-xian-cheng-yun-zhuan-jia-gou/posts/undefined/</id>
    <published>2025-02-10T12:00:22.000Z</published>
    <updated>2025-02-10T12:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/462717234">一文聊透Netty核心引擎Reactor的运转架构</a></li></ul><h2 id="Reactor-线程唤醒"><a href="#Reactor-线程唤醒" class="headerlink" title="Reactor 线程唤醒"></a>Reactor 线程唤醒</h2><blockquote><p>以下三个条件中只要满足任意一个条件，Reactor 线程就会被从 Selector 上唤醒</p></blockquote><ul><li>当 Selector 轮询到有 IO 活跃事件发生时。</li></ul><p>轮询策略如下：</p><ul><li><code>返回 -1：</code> switch 逻辑分支进入<code>SelectStrategy.SELECT分支</code>，表示此时<code>Reactor</code>中没有<code>异步任务</code>需要执行，<code>Reactor线程</code>可以安心的阻塞在<code>Selector</code>上等待<code>IO就绪事件</code>发生。</li><li><code>返回 0：</code> switch 逻辑分支进入<code>default分支</code>，表示此时<code>Reactor</code>中没有<code>IO就绪事件</code>但是有<code>异步任务</code>需要执行，流程通过<code>default分支</code>直接进入了处理<code>异步任务</code>的逻辑部分。</li><li><code>返回 &gt; 0：</code>switch 逻辑分支进入<code>default分支</code>，表示此时<code>Reactor</code>中既有<code>IO就绪事件</code>发生也有<code>异步任务</code>需要执行，流程通过<code>default分支</code>直接进入了处理<code>IO就绪事件</code>和执行<code>异步任务</code>逻辑部分</li></ul><p><img data-src="/images/netty/02_01.PNG" alt="netty"></p><ul><li>当 Reactor 线程需要执行的<code>定时任务</code>到达任务执行时间<code>deadline</code>时。</li></ul><p><img data-src="/images/netty/02_02.PNG" alt="netty"></p><ul><li>当有<code>异步任务</code>提交给 Reactor 时，Reactor 线程需要从<code>Selector</code>上被唤醒，这样才能及时的去执行<code>异步任务</code>。</li></ul><blockquote><p>io.netty.channel.nio.NioEventLoop#wakeup</p></blockquote><p><img data-src="/images/netty/02_03.PNG" alt="netty"></p><h2 id="Reactor-线程工作体系"><a href="#Reactor-线程工作体系" class="headerlink" title="Reactor 线程工作体系"></a>Reactor 线程工作体系</h2><p><img data-src="/images/netty/02_04.PNG" alt="netty"></p><ol><li>Reactor 线程在 Selector 上阻塞获取 IO 就绪事件。在这个模块中首先会去检查当前是否有异步任务需要执行，如果有异步需要执行，那么不管当前有没有 IO 就绪事件都不能阻塞在 Selector 上，随后会去非阻塞的轮询一下 Selector 上是否有 IO 就绪事件，如果有，正好可以和异步任务一起执行。优先处理 IO 就绪事件，在执行异步任务</li><li>如果当前没有异步任务需要执行，那么 Reactor 线程会接着查看是否有定时任务需要执行，如果有则在 Selector 上阻塞直到定时任务的到期时间 deadline，或者满足其他唤醒条件被唤醒。如果没有定时任务需要执行，Reactor 线程则会在 Selector 上一直阻塞直到满足唤醒条件。</li><li>当 Reactor 线程满足唤醒条件被唤醒后，首先会去判断当前是因为有 IO 就绪事件被唤醒还是因为有异步任务需要执行被唤醒或者是两者都有。随后 Reactor 线程就会去处理 IO 就绪事件和执行异步任务</li><li>最后 Reactor 线程返回循环起点不断的重复上述三个步骤</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="外部线程提交一个任务给-Reactor-线程，reactor-线程怎么从-select-阻塞中释放出来，执行任务？"><a href="#外部线程提交一个任务给-Reactor-线程，reactor-线程怎么从-select-阻塞中释放出来，执行任务？" class="headerlink" title="外部线程提交一个任务给 Reactor 线程，reactor 线程怎么从 select 阻塞中释放出来，执行任务？"></a>外部线程提交一个任务给 Reactor 线程，reactor 线程怎么从 select 阻塞中释放出来，执行任务？</h3><blockquote><p>通过外部线程执行 selector.wakeup（） 方法唤醒线程</p></blockquote><p>外部线程通过 <code>execute</code> 方法添加任务时会判断是否需要唤醒线程，如果需要则唤醒线程</p><blockquote><p>io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable)</p></blockquote><p>只要不是 LazyRunnable 任务，都会唤醒线程</p><p><img data-src="/images/netty/02_05.png" alt="netty"></p><p>这里会调用到👇🏻这个方法，其中 <code>immediate</code> 是上面的第二个参数，这里是 true，<code>addTaskWakesUp</code> 表示是否只有 addTask 方法时才唤醒线程，这里默认为<code>false</code>，所以会继续执行 wake（） 方法</p><p><img data-src="/images/netty/02_06.png" alt="netty"></p><blockquote><p>io.netty.channel.nio.NioEventLoop#wakeup</p></blockquote><p>会调用到 NioEventLoop#wake 方法，nextWakeupNanos 是一个 AtomicLong 类型的值，默认是 AWAKE（-1）表示当前 reactor 线程是唤醒的状态，下面判断很简单，如果 reactor 线程当前不是唤醒的状态，那么调用  <code>selector.wakeup()</code> 进行唤醒</p><p><img data-src="/images/netty/02_07.png" alt="netty"></p><ol><li><h3 id="待执行的异步任务非常多，是否会影响到-reactor-线程的-IO-任务？"><a href="#待执行的异步任务非常多，是否会影响到-reactor-线程的-IO-任务？" class="headerlink" title="待执行的异步任务非常多，是否会影响到 reactor 线程的 IO 任务？"></a>待执行的异步任务非常多，是否会影响到 reactor 线程的 IO 任务？</h3></li></ol><blockquote><p>无论什么时候，当有<code>IO就绪事件</code>到来时，<code>Reactor</code>都需要保证<code>IO事件</code>被及时完整的处理完，而<code>ioRatio</code>主要限制的是执行<code>异步任务</code>所需用时，防止<code>Reactor线程</code>处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</p></blockquote><ul><li>当<code>ioRatio = 100</code>时，表示无需考虑执行时间的限制，当有<code>IO就绪事件</code>时（<code>strategy &gt; 0</code>）<code>Reactor线程</code>需要优先处理<code>IO就绪事件</code>，处理完<code>IO事件</code>后，执行所有的<code>异步任务</code>包括：普通任务，尾部任务，定时任务。无时间限制</li><li>当<code>ioRatio</code>设置的值不为<code>100</code>时，默认为<code>50</code>。需要先统计出执行<code>IO事件</code>的用时<code>ioTime</code>，根据<code>ioTime * (100 - ioRatio) / ioRatio</code>计算出，后面执行<code>异步任务</code>的限制时间。也就是说<code>Reactor线程</code>需要在这个限定的时间内，执行有限的异步任务，防止<code>Reactor线程</code>由于处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</li></ul><blockquote><p>默认情况下，执行<code>IO事件</code>用时和执行<code>异步任务</code>用时比例设置的是一比一。 <code>ioRatio</code>设置的越高，则<code>Reactor线程</code>执行异步任务的时间占比<code>越小</code></p></blockquote><ul><li>如果此时没有<code>IO事件</code>需要处理，Netty 只允许<code>Reactor线程</code>最多执行<code>64</code>个异步任务，然后就结束执行。转去继续轮训<code>IO就绪事件</code>。核心目的还是防止<code>Reactor线程</code>由于处理<code>异步任务</code>时间过长而导致<code>I/O 事件</code>得不到及时地处理</li></ul><p><img data-src="/images/netty/02_08.png" alt="netty"></p><ul><li>由于系统调用<code>System.nanoTime()</code>需要一定的系统开销，所以每执行完<code>64</code>个<code>异步任务</code>的时候才会去检查一下<code>执行时间</code>是否到达了<code>deadline</code>。如果到达了执行截止时间<code>deadline</code>则退出停止执行<code>异步任务</code>。如果没有到达<code>deadline</code>则继续从普通任务队列中取出任务循环执行下</li></ul><p><img data-src="/images/netty/02_09.png" alt="netty"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/462717234&quot;&gt;一文聊透Netty核心引擎Reactor的运转架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Reactor-线程唤醒&quot;&gt;&lt;a href=&quot;#Reactor-线程唤醒&quot; class=&quot;headerlink&quot; title=&quot;Reactor 线程唤醒&quot;&gt;&lt;/a&gt;Reactor 线程唤醒&lt;/h2&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://taeyang0126.github.io/tags/Netty/"/>
    
    <category term="源码解析" scheme="https://taeyang0126.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://taeyang0126.github.io/2025/02/10/shu-ju-ku/mysql/mysql/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/10/shu-ju-ku/mysql/mysql/posts/undefined/</id>
    <published>2025-02-10T11:52:22.000Z</published>
    <updated>2025-02-10T11:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://relph1119.github.io/mysql-learning-notes/#/">《MySQL 是怎样运行的：从根儿上理解 MySQL》</a></li></ul><h2 id="初识-MySQL"><a href="#初识-MySQL" class="headerlink" title="初识 MySQL"></a>初识 MySQL</h2><h3 id="启动服务器程序"><a href="#启动服务器程序" class="headerlink" title="启动服务器程序"></a>启动服务器程序</h3><ul><li><strong>mysqld</strong> 表示 mysql 服务器程序，运行这个可执行文件想可以直接启动一个 mysql 服务器进程，但这个可执行文件并不常用</li><li><strong>mysqld_safe</strong> 一个启动脚本，会间接调用 mysqld 并持续监控服务器的运行状态。当服务器进程出现错误时，还可以帮助重启服务器程序，另外，使用 mysqld_safe 启动 MYSQL 服务器程序时，它会将服务器程序的出错信息和其他诊断信息输出到错误日志，方便后期查找发生错误的原因（出错日志默认写到一个以 .err 为扩展名的文件中，该文件位于 mysql 的数据目录中）</li><li><strong>mysqld.server</strong> 也是一个启动脚本，会间接的调用 mysqld_safe。在执行 mysql.server 时，在后面添加 start 参数就可以启动服务器程序了。需要注意的是，mysqld.server 文件其实是一个链接文件，它对应的时机文件是 ..&#x2F;support-files&#x2F;mysql.server</li><li><strong>mysqld_multi</strong> 在一台计算机上运行多个服务器实例</li></ul><pre><code class="mermaid">flowchart LR  A[mysqld.server]  B[mysql_safe]  C[mysqld]  A--&gt;|启动|B--&gt;|监控并启动|C</code></pre><h3 id="启动客户端程序"><a href="#启动客户端程序" class="headerlink" title="启动客户端程序"></a>启动客户端程序</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><ul><li>mysql -h127.0.0.1 -uroot -P3307 -p</li></ul><h4 id="UNIX-套接字"><a href="#UNIX-套接字" class="headerlink" title="UNIX 套接字"></a>UNIX 套接字</h4><blockquote><p>服务端进程与客户端进程运行在一台机器上，使用 UNIX 域套接字进行进程间通信。默认 mysql 服务端启动的套接字文件是 &#x2F;tmp&#x2F;mysql.sock</p></blockquote><ul><li>mysql -S &#x2F;tmp&#x2F;mysql.sock</li><li>mysql –socket &#x2F;tmp&#x2F;mysql.sock</li></ul><h3 id="启动多个-mysql-服务端进程"><a href="#启动多个-mysql-服务端进程" class="headerlink" title="启动多个 mysql 服务端进程"></a>启动多个 mysql 服务端进程</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 端口</span><br><span class="line">port=<span class="number">3307</span></span><br><span class="line"># 监听的套接字文件</span><br><span class="line">socket=/tmp/mysql.sock2</span><br><span class="line"># 数据文件地址</span><br><span class="line">datadir=/opt/homebrew/var/mysql3307</span><br><span class="line"># 指定进程文件，好处是可以快速根据此文件定位到进程是否启动 cat /opt/homebrew/logs/mysql/mysqld3307.pid</span><br><span class="line">pid-file=/opt/homebrew/logs/mysql/mysqld3307.pid</span><br><span class="line"># 日志文件</span><br><span class="line"><span class="built_in">log</span>-error=/opt/homebrew/logs/mysql/mysqld3307.<span class="built_in">log</span></span><br><span class="line"><span class="meta"># mysqlx 端口</span></span><br><span class="line">mysqlx_port=<span class="number">33070</span></span><br></pre></td></tr></table></figure><h4 id="初始化-mysql-数据目录"><a href="#初始化-mysql-数据目录" class="headerlink" title="初始化 mysql 数据目录"></a>初始化 mysql 数据目录</h4><ul><li><code>--initialize</code>： 这个选项告诉 MySQL 创建一个新的数据目录结构，包括必要的系统表。它会生成一个随机的临时 root 密码</li><li><code>--user=mysql</code>： 指定哪个系统用户将拥有这些新创建的文件。通常，这应该是运行 MySQL 服务器的用户</li><li><code>--datadir=/opt/homebrew/var/mysql3307</code>： 这指定新数据目录的位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --datadir=/opt/homebrew/var/mysql3307</span><br></pre></td></tr></table></figure><h4 id="启动服务端程序"><a href="#启动服务端程序" class="headerlink" title="启动服务端程序"></a>启动服务端程序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --defaults-file=/opt/homebrew/etc/my_3307.cnf</span><br></pre></td></tr></table></figure><h4 id="客户端连接服务端"><a href="#客户端连接服务端" class="headerlink" title="客户端连接服务端"></a>客户端连接服务端</h4><ul><li>mysql -S &#x2F;tmp&#x2F;mysql.sock2 -uroot -p</li><li>mysql -h127.0.0.1 -uroot -P3307 -p</li></ul><h3 id="服务端处理客户端请求"><a href="#服务端处理客户端请求" class="headerlink" title="服务端处理客户端请求"></a>服务端处理客户端请求</h3><p><img data-src="/images/db/MySQL/01.png" alt="img"></p><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><blockquote><p>客户端进程可以采用我们上面介绍的<code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code>这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。<code>MySQL</code>服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量。</p></blockquote><ul><li>如何限制？</li><li>mysql 服务器给每一个客户端都分配了一个线程，这个线程和客户端是深度绑定的，即和客户端的 socket 是深度绑定的，会通过 read 方法阻塞式的获取客户端请求</li></ul><h4 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h4><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><blockquote><p><code>MySQL</code>服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果<code>缓存</code>起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端 A 刚刚查询了一个语句，而客户端 B 之后发送了同样的查询请求，那么客户端 B 的这次查询就可以直接使用查询缓存中的数据</p></blockquote><ul><li>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中</li><li>如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存</li><li>MySQL 的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除</li><li>虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除</li></ul><h5 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h5><blockquote><p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以<code>MySQL</code>服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到<code>MySQL</code>服务器内部使用的一些数据结构上来</p></blockquote><h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><blockquote><p>语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的<code>MySQL</code>语句执行起来效率可能并不是很高，<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划</p></blockquote><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><blockquote><p>截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，<code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块里。我们知道<code>表</code>是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是<code>存储引擎</code>负责的事情。为了实现不同的功能，<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同</p></blockquote><table><thead><tr><th>存储引擎</th><th>描述</th></tr></thead><tbody><tr><td>ARCHIVE</td><td>用于数据存档（行被插入后不能再修改）</td></tr><tr><td>BLACKHOLE</td><td>丢弃写操作，读操作会返回空内容</td></tr><tr><td>CSV</td><td>在存储数据时，以逗号分隔各个数据项</td></tr><tr><td>FEDERATED</td><td>用来访问远程表</td></tr><tr><td>InnoDB</td><td>具备外键支持功能的事务存储引擎</td></tr><tr><td>MEMORY</td><td>置于内存的表</td></tr><tr><td>MERGE</td><td>用来管理多个MyISAM表构成的表集合</td></tr><tr><td>MyISAM</td><td>主要的非事务处理存储引擎</td></tr><tr><td>NDB</td><td>MySQL集群专用存储引擎</td></tr></tbody></table><h5 id="InnoDB是MySQL默认的存储引擎"><a href="#InnoDB是MySQL默认的存储引擎" class="headerlink" title="InnoDB是MySQL默认的存储引擎"></a><code>InnoDB</code>是<code>MySQL</code>默认的存储引擎</h5><h5 id="查看当前服务程序支持的存储引擎"><a href="#查看当前服务程序支持的存储引擎" class="headerlink" title="查看当前服务程序支持的存储引擎"></a>查看当前服务程序支持的存储引擎</h5><blockquote><p><code>Support</code>列表示该存储引擎是否可用，<code>DEFAULT</code>值代表是当前服务器程序的默认存储引擎。<code>Comment</code>列是对存储引擎的一个描述。<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表该存储引擎是否支持分布式事务。<code>Savepoints</code>代表该列是否支持部分事务回滚</p></blockquote><p><img data-src="/images/db/MySQL/02.png" alt="img"></p><h5 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h5><ul><li>创建表时指定存储引擎</li></ul><blockquote><p>创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎<code>InnoDB</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><ul><li>修改表的存储引擎</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><ul><li>查看表的存储引擎</li></ul><p><img data-src="/images/db/MySQL/03.png" alt="img"></p><h2 id="启动选项和系统变量"><a href="#启动选项和系统变量" class="headerlink" title="启动选项和系统变量"></a>启动选项和系统变量</h2><h3 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h3><blockquote><p>每个 MySQL 程序都有许多不同的选项。大多数程序提供了一个<code>--help</code>选项，可以查看该程序支持的全部启动选项以及它们的默认值。在命令行中设置启动选项只对当次启动生效！！</p></blockquote><ul><li><code>mysql --help</code></li></ul><p><img data-src="/images/db/MySQL/04.png" alt="img"></p><ul><li><code>mysqld_safe --help</code></li><li><code>mysqld --verbose --help</code></li></ul><p><img data-src="/images/db/MySQL/05.png" alt="img"></p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的很烦呀！于是设计<code>MySQL</code>的大佬们提出一种<code>配置文件</code>（也称为<code>选项文件</code>）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，所以我们推荐使用配置文件的方式来设置启动选项。</p></blockquote><h4 id="类-Unix-操作系统中的配置文件"><a href="#类-Unix-操作系统中的配置文件" class="headerlink" title="类 Unix 操作系统中的配置文件"></a>类 Unix 操作系统中的配置文件</h4><blockquote><p>在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件</p></blockquote><ul><li>这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在<code>~/.my.cnf</code>这个路径下创建一个配置文件</li><li>在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准（比如&#x2F;etc&#x2F;my.cnf 与～&#x2F;。my.cnf 都配置了相同的启动选项，以～&#x2F;。my.cnf 为准）</li></ul><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;my.cnf</td><td>homebrew安装的目录对应 &#x2F;opt&#x2F;homebrew&#x2F;etc</td></tr><tr><td>&#x2F;etc&#x2F;mysql&#x2F;my.cnf</td><td></td></tr><tr><td>SYSCONFDIR&#x2F;my.cnf</td><td></td></tr><tr><td>$MYSQL_HOME&#x2F;my.cnf</td><td>特定于服务器的选项（仅限服务器）</td></tr><tr><td>defaults-extra-file</td><td>命令行指定的额外配置文件路径</td></tr><tr><td>~&#x2F;.my.cnf</td><td>用户特定选项</td></tr><tr><td>~&#x2F;.mylogin.cnf</td><td>用户特定的登录路径选项（仅限客户端）</td></tr></tbody></table><h4 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h4><blockquote><p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line">(具体的启动选项...)</span><br></pre></td></tr></table></figure><p>像这个配置文件里就定义了许多个组，组名分别是<code>server</code>、<code>mysqld</code>、<code>mysqld_safe</code>、<code>client</code>、<code>mysql</code>、<code>mysqladmin</code>。每个组下面可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">option1            <span class="comment">#这是option1，该选项不需要选项值</span></span><br><span class="line">option2 = value2      <span class="comment">#这是option2，该选项需要选项值</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加<code>--</code>前缀，并且每行只指定一个选项，而且<code>=</code>周围可以有空白字符（命令行中选项名、<code>=</code>、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用<code>#</code>来添加注释，从<code>#</code>出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。</p><p>配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如，<code>[mysqld]</code>和<code>[mysql]</code>组分别应用于<code>mysqld</code>服务器程序和<code>mysql</code>客户端程序。不过有两个选项组比较特别：</p><ul><li><code>[server]</code>组下面的启动选项将作用于所有的服务器程序。</li><li><code>[client]</code>组下面的启动选项将作用于所有的客户端程序。</li></ul><table><thead><tr><th>启动命令</th><th>类别</th><th>能读取的组</th></tr></thead><tbody><tr><td>mysqld</td><td>启动服务器</td><td>[mysqld]、[server]</td></tr><tr><td>mysqld_safe</td><td>启动服务器</td><td>[mysqld]、[server]、[mysqld_safe]</td></tr><tr><td>mysql.server</td><td>启动服务器</td><td>[mysqld]、[server]、[mysql.server]</td></tr><tr><td>mysql</td><td>启动客户端</td><td>[mysql]、[client]</td></tr><tr><td>mysqladmin</td><td>启动客户端</td><td>[mysqladmin]、[client]</td></tr><tr><td>mysqldump</td><td>启动客户端</td><td>[mysqldump]、[client]</td></tr></tbody></table><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项</p><h4 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h4><ol><li>在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准，配置文件的读取顺序参考 <a href="https://rq3nt70g815.feishu.cn/wiki/HBT2wcn8Ti4ONakGlG0c7jc6n7e#MAsXdQbjFoh6iVxH2x3cRpACnlc">二、启动选项和系统变量</a></li><li>同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，比如<code>~/.my.cnf</code>，在这些组里出现了同样的配置项，比如这样，将以最后一个出现的组中的启动选项为准，👇🏻例子以<code>[mysqld]</code>组中的配置项为准</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=InnoDB</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><ol start="3"><li>同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准</li></ol><h4 id="defaults-file-的使用"><a href="#defaults-file-的使用" class="headerlink" title="defaults-file 的使用"></a>defaults-file 的使用</h4><blockquote><p>如果我们不想让<code>MySQL</code>到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定<code>defaults-file</code>选项，比如这样（以<code>UNIX</code>系统为例）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --defaults-file=/tmp/myconfig.txt</span><br></pre></td></tr></table></figure><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><code>MySQL</code>服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL</code>系统变量，比如允许同时连入的客户端数量用系统变量<code>max_connections</code>表示，表的默认存储引擎用系统变量<code>default_storage_engine</code>表示，查询缓存的大小用系统变量<code>query_cache_size</code>表示，<code>MySQL</code>服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它</p><h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;default_storage_engine&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES like <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h4><h5 id="通过启动选项设置"><a href="#通过启动选项设置" class="headerlink" title="通过启动选项设置"></a>通过启动选项设置</h5><blockquote><p>大部分的<code>系统变量</code>都可以通过启动服务器时传送启动选项的方式来进行设置</p></blockquote><ul><li>通过命令行添加启动选项</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM --max-connections=10</span><br></pre></td></tr></table></figure><ul><li>通过配置文件添加启动选项</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=MyISAM</span><br><span class="line">max-connections=10</span><br></pre></td></tr></table></figure><ul><li>对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是对应的系统变量之间必须使用下划线<code>_</code>连接起来</li></ul><h5 id="服务器程序运行过程中设置"><a href="#服务器程序运行过程中设置" class="headerlink" title="服务器程序运行过程中设置"></a>服务器程序运行过程中设置</h5><blockquote><p><code>系统变量</code>比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中，进行动态修改而无需停止并重启服务器。</p></blockquote><ul><li><p>作用范围</p><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul></li><li><p>通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的</p></li><li><p>设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code></p></li><li><p>通过客户端程序设置系统变量的语法</p><ul><li><pre><code class="language-Bash">SET [GLOBAL|SESSION] 系统变量名 = 值;SET [@@(GLOBAL|SESSION).]var_name = XXX;# 全局设置语句一：SET GLOBAL default_storage_engine = MyISAM;语句二：SET @@GLOBAL.default_storage_engine = MyISAM;# 针对本客户端设置，选择下面三条语句中的任意一条来进行设置语句一：SET SESSION default_storage_engine = MyISAM;语句二：SET @@SESSION.default_storage_engine = MyISAM;语句三：SET default_storage_engine = MyISAM;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `SHOW VARIABLES`语句默认查看的是`SESSION`作用范围的系统变量，也可以通过下面方式查看不同作用范围的系统变量</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围</p><ul><li>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接</li><li>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值</li></ul></li><li><p>有些系统变量是只读的，并不能设置值</p><ul><li>比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看</li></ul></li></ul><h3 id="启动选项与系统变量的区别"><a href="#启动选项与系统变量的区别" class="headerlink" title="启动选项与系统变量的区别"></a>启动选项与系统变量的区别</h3><blockquote><p><code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量</p></blockquote><ul><li>大部分的系统变量都可以被当作启动选项传入</li><li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>等</li><li>有些启动选项也不是系统变量，比如<code>defaults-file</code></li></ul><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>为了让我们更好的了解服务器程序的运行情况，<code>MySQL</code>服务器程序中维护了很多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录等。</p><p>由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与<code>系统变量</code>类似，<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>如果我们不写明作用范围，默认的作用范围是<code>SESSION</code></p><p><img data-src="/images/db/MySQL/06.png" alt="img"></p><h2 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h2><h3 id="一些重要的字符集"><a href="#一些重要的字符集" class="headerlink" title="一些重要的字符集"></a>一些重要的字符集</h3><ul><li><code>ASCII</code>字符集</li></ul><p>共收录 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才 128 个字符，所以可以使用 1 个字节来进行编码，我们看一些字符的编码方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;L&#x27;</span> -&gt;  01001100（十六进制：0x4C，十进制：76）</span><br><span class="line"><span class="string">&#x27;M&#x27;</span> -&gt;  01001101（十六进制：0x4D，十进制：77）</span><br></pre></td></tr></table></figure><ul><li><code>ISO 8859-1</code>字符集</li></ul><p>共收录 256 个字符，是在<code>ASCII</code>字符集的基础上又扩充了 128 个西欧常用字符（包括德法两国的字母），也可以使用 1 个字节来进行编码。这个字符集也有一个别名<code>latin1</code></p><ul><li><code>GB2312</code>字符集</li></ul><p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字 6763 个，其他文字符号 682 个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p><ul><li><p>如果该字符在<code>ASCII</code>字符集中，则采用 1 字节编码</p></li><li><p>否则采用 2 字节编码</p></li><li><p><code>GBK</code>字符集</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GBK`字符集只是在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容`GB2312</span><br></pre></td></tr></table></figure><ul><li><code>utf8</code>字符集</li></ul><p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用 1～4 个字节。其实准确的说，utf8 只是 Unicode 字符集的一种编码方案，Unicode 字符集可以采用 utf8、utf16、utf32 这几种编码方案，utf8 使用 1～4 个字节编码一个字符，utf16 使用 2 个或 4 个字节编码一个字符，utf32 使用 4 个字节编码一个字符。MySQL 中并不区分字符集和编码方案的概念，所以把 utf8、utf16、utf32 都当作一种字符集对待。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;L&#x27;</span> -&gt;  01001100（十六进制：0x4C）</span><br><span class="line"><span class="string">&#x27;啊&#x27;</span> -&gt;  111001011001010110001010（十六进制：0xE5958A）</span><br></pre></td></tr></table></figure><h3 id="MySQL-中支持的字符集和排序规则"><a href="#MySQL-中支持的字符集和排序规则" class="headerlink" title="MySQL 中支持的字符集和排序规则"></a>MySQL 中支持的字符集和排序规则</h3><h4 id="MySQL-中的-utf8-和-utf8mb4"><a href="#MySQL-中的-utf8-和-utf8mb4" class="headerlink" title="MySQL 中的 utf8 和 utf8mb4"></a>MySQL 中的 utf8 和 utf8mb4</h4><p><code>utf8</code>字符集表示一个字符需要使用 1～4 个字节，但是我们常用的一些字符使用 1～3 个字节就可以表示了。而在<code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计<code>MySQL</code>的大佬偷偷的定义了两个概念：</p><ul><li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用 1～3 个字节表示字符。在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用 1～3 个字节来表示一个字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用 1～4 个字节表示字符。存储一些 emoji 表情什么的。</li></ul><h4 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h4><p><code>MySQL</code>支持好多好多种字符集，查看当前<code>MySQL</code>中支持的字符集可以用下面这个语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CHARACTER SET和CHARSET是同义词</span></span><br><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><table><thead><tr><th>字符集名称</th><th>Maxlen</th></tr></thead><tbody><tr><td>ascii</td><td>1</td></tr><tr><td>latin1</td><td>1</td></tr><tr><td>gb2312</td><td>2</td></tr><tr><td>gbk</td><td>2</td></tr><tr><td>utf8</td><td>3</td></tr><tr><td>utf8mb4</td><td>4</td></tr></tbody></table><h4 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h4><p>查看<code>MySQL</code>中支持的比较规则的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><ul><li>比较规则名称以与其关联的字符集的名称开头</li><li>后边紧跟着该比较规则主要作用于哪种语言，比如<code>utf8_polish_ci</code>表示以波兰语的规则比较，<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则</li><li>名称后缀意味着该比较规则是否区分语言中的重音、大小写什么的，具体可以用的值如下</li></ul><table><thead><tr><th>后缀</th><th>英文释义</th><th>描述</th></tr></thead><tbody><tr><td>_ai</td><td>accent insensitive</td><td>不区分重音</td></tr><tr><td>_as</td><td>accent sensitive</td><td>区分重音</td></tr><tr><td>_ci</td><td>case insensitive</td><td>不区分大小写</td></tr><tr><td>_cs</td><td>case sensitive</td><td>区分大小写</td></tr><tr><td>_bin</td><td>binary</td><td>以二进制方式比较</td></tr></tbody></table><h4 id="各级别的字符集和比较规则"><a href="#各级别的字符集和比较规则" class="headerlink" title="各级别的字符集和比较规则"></a>各级别的字符集和比较规则</h4><h5 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h5><blockquote><p><code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则</p></blockquote><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_server</td><td>服务器级别的字符集</td></tr><tr><td>collation_server</td><td>服务器级别的比较规则</td></tr></tbody></table><p><img data-src="/images/db/MySQL/07.png" alt="img"></p><blockquote><p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用<code>SET</code>语句修改这两个变量的值</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><h5 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h5><blockquote><p>在创建和修改数据库的时候可以指定该数据库的字符集和比较规则</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p><em>character_set_database</em> 和 <em>collation_database</em> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_database</td><td>当前数据库的字符集</td></tr><tr><td>collation_database</td><td>当前数据库的比较规则</td></tr></tbody></table><h5 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h5><blockquote><p>也可以在创建和修改表的时候指定表的字符集和比较规则</p></blockquote><ul><li>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><h5 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h5><blockquote><p>对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则</p></blockquote><ul><li>如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><h5 id="各级别字符集和比较规则小结"><a href="#各级别字符集和比较规则小结" class="headerlink" title="各级别字符集和比较规则小结"></a>各级别字符集和比较规则小结</h5><ul><li>如果创建或修改列时，没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则</li><li>如果创建或修改表时，没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则</li><li>如果创建或修改数据库时，没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则</li></ul><h3 id="客户端和服务端通信中的字符集"><a href="#客户端和服务端通信中的字符集" class="headerlink" title="客户端和服务端通信中的字符集"></a>客户端和服务端通信中的字符集</h3><h4 id="MySQL-中字符集的转换"><a href="#MySQL-中字符集的转换" class="headerlink" title="MySQL 中字符集的转换"></a>MySQL 中字符集的转换</h4><p>从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到 3 个系统变量</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p><img data-src="/images/db/MySQL/08.png" alt="img"></p><ul><li>服务器认为客户端发送过来的请求是用<code>character_set_client</code>编码的</li></ul><blockquote><p>假设你的客户端采用的字符集和 <em>character_set_client</em> 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_client</code>的值设置为<code>ascii</code>的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了</p></blockquote><ul><li>服务器将把得到的结果集使用<code>character_set_results</code>编码后发送给客户端</li></ul><blockquote><p>假设你的客户端采用的字符集和 <em>character_set_results</em> 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_results</code>的值设置为<code>ascii</code>的话，可能会产生乱码</p></blockquote><ul><li>通常都把 <em>character_set_client</em> 、<em>character_set_connection</em><strong>、<em>character_set_results</em></strong> 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，<code>MySQL</code>提供了一条非常简便的语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES 字符集名;</span><br></pre></td></tr></table></figure><ul><li>想在启动客户端的时候就把<code>character_set_client</code>、<code>character_set_connection</code>、<code>character_set_results</code>这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><h2 id="InnoDB-记录结构"><a href="#InnoDB-记录结构" class="headerlink" title="InnoDB 记录结构"></a>InnoDB 记录结构</h2><h3 id="InnoDB-页简介"><a href="#InnoDB-页简介" class="headerlink" title="InnoDB 页简介"></a>InnoDB 页简介</h3><p><code>InnoDB</code>是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB</code>存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，<code>InnoDB</code>采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 <em>16</em> KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。</p><h3 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h3><blockquote><p>记录在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code></p></blockquote><h4 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><h4 id="COMPACT-行格式"><a href="#COMPACT-行格式" class="headerlink" title="COMPACT 行格式"></a>COMPACT 行格式</h4><p><img data-src="/images/db/MySQL/09.png" alt="img"></p><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ul><li><p>变长字段长度列表</p><ul><li><p>各变长字段数据占用的字节数按照列的顺序逆序存放</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么需要逆序存放呢？</span><br><span class="line">因为对于数据页中的数据是通过单链表进行连接的，每条记录中头信息中包含next_record字段，此字段指向的是下一条记录的头信息和真实数据之间的位置上，这样向左读取就是记录头信息，向右读取就是真实数据，所以按顺序存放的字段和逆序存放的变长字段列表和NULL值列表就对上了，这样每个字段的值以及它的长度和NULL标识在内存中更近，这样的话可能会提高高速缓存的命中率</span><br></pre></td></tr></table></figure></li><li><p>变长字段长度列表中只存储值为 非 NULL 的列内容占用的长度，值为 <em>NULL</em> 的列的长度是不储存的</p></li><li><p>假设某个字符集中表示一个字符最多需要使用的字节数为<code>W</code>，对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<code>M</code>个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是<code>M×W</code>，<code>L</code> 表示实际存储占用的字节数</p><ul><li><code>M×W &lt;= 255</code>，那么使用 1 个字节来表示真正字符串占用的字节数</li><li><code>M×W &gt; 255 &amp;&amp; L &lt;= 127</code> 用 1 个字节来表示真正字符串占用的字节数</li><li><code>M×W &gt; 255 &amp;&amp; L &gt; 127</code>用 2 个字节来表示真正字符串占用的字节数</li><li>[疑问]为什么需要按👆🏻这种做法呢？？</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，</span><br><span class="line">该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？</span><br><span class="line">设计InnoDB的大佬使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，</span><br><span class="line">那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），</span><br><span class="line">如果该字节的第一个位为1，那该字节就是半个字段长度。对于一些占用字节数非常多的字段，</span><br><span class="line">比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，</span><br><span class="line">InnoDB会把一部分数据存放到所谓的溢出页中，</span><br><span class="line">在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。</span><br></pre></td></tr></table></figure><ul><li>NULL 值列表<ul><li>统计表中允许存储<code>NULL</code>的列，比如表中有三个列可以为空，那么 NULL 值列表就有 3 个二进制位存储当前这条数据对应字段是否为空</li><li>如果表中没有允许存储 <em>NULL</em> 的列，则 <em>NULL 值列表</em> 也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li><li><code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设A表中包含字段c1,c2,c3,c4  其中c2,c3,c4字段可以为空 那么能得到下面的结果</span><br><span class="line">1. NULL值列表只需要3个二进制位表示，只需要一个字段，00000C4C3C2 其中后面三位可以为1或者0</span><br><span class="line">2. 某条记录所有字段均不为空，那么NULL值列表中一个字节上对应所有的二进制位均为0</span><br><span class="line">3. 某条记录C3字段为空，对应的NULL值列表的二进制位是 00000010</span><br></pre></td></tr></table></figure><ul><li><p>记录头信息 </p><ul><li><p>用于描述记录的<code>记录头信息</code>，它是由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思</p></li><li><p><img data-src="/images/db/MySQL/10.png" alt="img"></p></li><li><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数。就是该记录是page directory 中的一个slot，代表这个组内共有多少条记录数(包含自己这条记录)</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在本页的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table></li><li><p><code>delete_mask</code> 标记着当前记录是否被删除，占用 1 个二进制位，值为<code>0</code>的时候代表记录并没有被删除，为<code>1</code>的时候代表记录被删除掉了 </p><p>- </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉</span><br></pre></td></tr></table></figure></li><li><p><code>min_rec_mask</code> B+树的每层非叶子节点中的最小记录都会添加该标记</p></li><li><p><code>heap_no</code> 表示当前记录在本<code>页</code>中的位置，位置是从 2 开始，因为 0 和 1 被伪记录占据了，0 表示最小记录，1 表示最大记录，这两条伪记录不在页的 User Records 部分，被单独放在<a href="https://rq3nt70g815.feishu.cn/wiki/LCejwPlwqiofWbkDn86cotzPnfd#TyLUdGtCVoepiyx43A1c6zgXnNd"> Infimum + Supermum</a> 的部分</p></li><li><p><img data-src="/images/db/MySQL/11.png" alt="img"></p></li><li><p><code>next_record</code> 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。<code>下一条记录</code>指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 <em>Infimum 记录（也就是最小记录）</em> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <em>Supremum 记录（也就是最大记录）</em> ，为了更形象的表示一下这个<code>next_record</code>起到的作用，我们用箭头来替代一下<code>next_record</code>中的地址偏移量：</p><ul><li><img data-src="/images/db/MySQL/12.png" alt="img"></li><li><img data-src="/images/db/MySQL/13.png" alt="img"></li><li>第 2 条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为<code>1</code></li><li>第 2 条记录的<code>next_record</code>值变为了 0，意味着该记录没有下一条记录了</li><li>第 1 条记录的<code>next_record</code>指向了第 3 条记录</li></ul></li></ul></li></ul><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ul><li>隐藏列</li></ul><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id(DB_ROW_ID)</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id(DB_TRX_ID)</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer(DB_ROLL_PTR)</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，</span><br><span class="line">则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，</span><br><span class="line">则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键</span><br></pre></td></tr></table></figure><ul><li><p>CHAR（M） 列的存储格式</p><ul><li><p>当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表</p></li><li><p>采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表</p></li><li><p>变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比方说对于使用utf8字符集的<span class="type">CHAR</span>(<span class="number">10</span>)的列来说，该列存储的数据字节长度的范围是<span class="number">10</span>～<span class="number">30</span>个字节。</span><br><span class="line">即使我们向该列中存储一个空字符串也会占用<span class="number">10</span>个字节，这是怕将来更新该列的值的字节长度</span><br><span class="line">大于原有值的字节长度而小于<span class="number">10</span>个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，</span><br><span class="line">导致原有的记录空间成为所谓的碎片。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><h5 id="VARCHAR（M）最多能存储的数据"><a href="#VARCHAR（M）最多能存储的数据" class="headerlink" title="VARCHAR（M）最多能存储的数据"></a>VARCHAR（M）最多能存储的数据</h5><ul><li>一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节！</li><li>VARCHAR 类型需要占用 3 部分数据<ul><li>真实数据</li><li>真实数据占用字节的长度</li><li>NULL 值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li></ul></li><li>当 M 为 ascii 字符集时，一个字符表示一个字节，这样 VARCHAR（65535） 可用吗？不可用<ul><li>没有 NOT NULL，意味着 NULL 值标识需要占一个字节，长度需要占用两个字节，所以最多只能存储 65532 个字节的数据</li><li>有 NOT NULL，意味着额外只需要长度占用两个节点，所以最多存储 65533 个字节</li></ul></li><li>当 M 使用的不是<code>ascii</code>字符集，那<code>M</code>的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为<code>NULL</code>的情况下，<code>gbk</code>字符集表示一个字符最多需要<code>2</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>32766</code>（也就是：65532&#x2F;2），也就是说最多能存储<code>32766</code>个字符；<code>utf8</code>字符集表示一个字符最多需要<code>3</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>21844</code>，就是说最多能存储<code>21844</code>（也就是：65532&#x2F;3）个字符</li></ul><h5 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h5><ul><li><code>MySQL</code>是以<code>页</code>为基本单位来管理存储空间的，我们的记录都会被分配到某个<code>页</code>中存储。而一个页的大小一般是<code>16KB</code>，也就是<code>16384</code>字节</li><li>一个<code>VARCHAR(M)</code>类型的列就最多可以存储<code>65532</code>个字节，这样就可能造成一个页存放不了一条记录的尴尬情况</li><li>在<code>Compact</code>和<code>Reduntant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用 20 个字节存储指向这些页的地址（当然这 20 个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页</li></ul><p><img data-src="/images/db/MySQL/14.png" alt="img"></p><h5 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h5><ul><li><code>MySQL</code>中规定一个页中至少存放两行记录</li><li>每个页除了存放记录以外，也需要存储一些额外的信息，额外信息加起来需要<code>136</code>个字节的空间</li><li>每个记录需要的额外信息是<code>27</code>字节 （以下表示的都是表中只有一个列）<ul><li>2 个字节用于存储真实数据的长度</li><li>1 个字节用于存储列是否是 NULL 值</li><li>5 个字节大小的头信息</li><li>6 个字节的<code>row_id</code>列</li><li>6 个字节的<code>transaction_id</code>列</li><li>7 个字节的<code>roll_pointer</code>列</li></ul></li><li>在表中只有一个列的情况下，如果一个列中存储的数据不大于<code>8098</code>个字节，那就不会发生<code>行溢出</code>，否则就会发生<code>行溢出</code></li></ul><h4 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a><code>Dynamic</code>和<code>Compressed</code>行格式</h4><ul><li><code>MySQL</code>版本是<code>5.7</code>，它的默认行格式就是<code>Dynamic</code></li><li>和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</li></ul><p><img data-src="/images/db/MySQL/15.png" alt="img"></p><ul><li><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</li></ul><h2 id="InnoDB-数据页"><a href="#InnoDB-数据页" class="headerlink" title="InnoDB 数据页"></a>InnoDB 数据页</h2><p><img data-src="/images/db/MySQL/16.png" alt="img"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录，innoDB设计的最小记录和最大记录，最小记录和最大记录的heap_no分别是0和1</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><blockquote><p>在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有<code>User Records</code>这个部分，每当我们插入一条记录，都会从<code>Free Space</code>部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p></blockquote><p><img data-src="/images/db/MySQL/17.png" alt="img"></p><p><a href="https://rq3nt70g815.feishu.cn/wiki/Da7KwAdwOi3Ji3kYjU2clxF5n9f#SyksdUNdEoV959xpiTAcZLsAnOg">数据在页中按照主键值从小打到顺序串联成一个单链表</a></p><h3 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h3><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。<ol><li><img data-src="/images/db/MySQL/18.png" alt="img"></li><li>innoDB 对于每个分组中的条数有以下规定<ul><li>于最小记录所在的分组只能有 <em>1</em> 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 <em>1～8</em> 条之间</li><li>剩下的分组中记录的条数范围只能在是 <em>4～8</em> 条之间</li></ul></li><li>Page Derectory 构建步骤<ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。</li><li>在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li></ul></li><li><img data-src="/images/db/MySQL/19.png" alt="img"></li><li>如何从 Page Derectory 中查找记录<ul><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。（由于 slot 存储的是该组中最大的记录，所以可以找到上一个 slot，上一个 slot 的指向的 next record 就是当前 slot 中最小的记录）</li><li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li></ul></li></ol></li></ol><h3 id="Page-Header-数据页头部"><a href="#Page-Header-数据页头部" class="headerlink" title="Page Header 数据页头部"></a>Page Header 数据页头部</h3><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）可能是删除记录产生的空闲空间，也可能是页面末尾的未使用空间</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置。指向的是最后插入记录的起始位置，而不是记录的结束位置，所以不等于 free space。此字段是不考虑记录删除的，所以与PAGE_FREE相差巨大</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向。假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量。假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h3 id="File-Header-文件头部"><a href="#File-Header-文件头部" class="headerlink" title="File Header 文件头部"></a>File Header 文件头部</h3><blockquote><p><code>File Header</code>针对各种类型的页都通用，也就是说不同类型的页都会以<code>File Header</code>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息</p></blockquote><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和（checksum值） 代表当前页面的校验和（checksum）。什么是个校验和？就是对于一个很长很长的字节串来说，通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号，双向链表</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_TYPE</code></li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>BLOB页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><ul><li><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code></li></ul><blockquote><p><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性。</p></blockquote><p><img data-src="/images/db/MySQL/20.png" alt="img"></p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><blockquote><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况）。因为可能断电导致内存中的页只有一部分刷新到了磁盘，所以需要通过这个来判断一个页是否完整。这个部分由 8 个字节组成</p></blockquote><ul><li>前 4 个字节代表页的校验和</li></ul><p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前面，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trialer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p><ul><li>后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><ul><li><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95">快速查询的秘籍-B+树索引</a></li></ul><p><img data-src="/images/db/MySQL/21.png" alt="img"></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><blockquote><p>在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引</p></blockquote><ol><li>页内的记录是按照主键的大小顺序排成一个单向链表</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表</li><li><code>B+</code>树的叶子节点存储的是完整的用户记录</li></ol><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p><img data-src="/images/db/MySQL/22.png" alt="img"></p><ul><li>页内的记录是按照二级索引对应的列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的二级索引对应的列大小顺序排成一个双向链表</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的二级索引对应的列大小顺序排成一个双向链表</li><li><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>二级索引对应的列+主键</code>这两个列的值</li><li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>二级索引对应的列``+页号</code>的搭配</li><li>如果我们想根据<code>二级索引对应的列</code>的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程也被称为<code>回表</code></li><li>二级索引的内节点的目录项记录的内容由三部分构成，这样才能保证同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。<ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul></li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><img data-src="/images/db/MySQL/23.png" alt="img"></p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><h4 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h4><ul><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li><li>一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</li></ul><h4 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h4><blockquote><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是什么效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以<code>InnoDB</code>的一个数据页至少可以存放两条记录</p></blockquote><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><h4 id="空间上的代价"><a href="#空间上的代价" class="headerlink" title="空间上的代价"></a>空间上的代价</h4><blockquote><p>每建立一个索引都要为它建立一棵<code>B+</code>树，每一棵<code>B+</code>树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的<code>B+</code>树由许多数据页组成，那可是很大的一片存储空间呢</p></blockquote><h4 id="时间上的代价"><a href="#时间上的代价" class="headerlink" title="时间上的代价"></a>时间上的代价</h4><blockquote><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个<code>B+</code>树索引。<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收什么的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的<code>B+</code>树都要进行相关的维护操作，这还能不给性能拖后腿么?</p></blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。</p><h3 id="B-树索引的适用条件"><a href="#B-树索引的适用条件" class="headerlink" title="B+树索引的适用条件"></a>B+树索引的适用条件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span> auto_increment,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img data-src="/images/db/MySQL/24.png" alt="img"></p><ul><li>先按照<code>name</code>列的值进行排序。</li><li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li><li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li></ul><h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><blockquote><p>搜索条件中的列和索引列一致的话</p></blockquote><p>比如👇🏻这个搜索sql，搜索条件与索引列完全一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">=</span> <span class="string">&#x27;15123983239&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h4><blockquote><p>搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行</p></blockquote><h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><h4 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h4><blockquote><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&lt;</span> <span class="string">&#x27;2000-12-31&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">&gt;</span> <span class="string">&#x27;15100000000&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、等等排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。</p><h5 id="使用联合索引进行排序注意事项"><a href="#使用联合索引进行排序注意事项" class="headerlink" title="使用联合索引进行排序注意事项"></a>使用联合索引进行排序注意事项</h5><ul><li><code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出</li><li><code>ORDER BY name</code>、<code>ORDER BY name, birthday</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h5 id="不可以使用索引进行排序的几种情况"><a href="#不可以使用索引进行排序的几种情况" class="headerlink" title="不可以使用索引进行排序的几种情况"></a>不可以使用索引进行排序的几种情况</h5><ol><li>ASC、DESC混用</li></ol><blockquote><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序，如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。</p></blockquote><ol><li>WHERE子句中出现非排序使用到的索引列</li><li>排序列包含非同一个索引的条件</li><li>排序列使用了复杂的表达式，比如函数等</li></ol><h4 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h4><blockquote><p>没有索引的话，这个分组过程全部需要在内存里实现</p></blockquote><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>一般来说二级索引查询的数据在磁盘中的存储是相连的，集中分布在一个或几个数据页中，所以是顺序IO，但是回表的时候对应的ID可能分配在不同的页上，这时候读取就是随机IO，顺序IO相比于随机IO性能高的多，所以需要回表的记录越多，使用二级索引的性能就越低</p><ul><li>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code></li><li>需要回表的记录越多，使用二级索引的性能就越低</li><li>回表数据量过大可能导致不使用二级索引，而是遍历聚簇索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number;</span><br></pre></td></tr></table></figure><p>比如👆🏻这个例子中，由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是如果增加了limit子句，需要回表的数据</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://relph1119.github.io/mysql-learning-notes/#/&quot;&gt;《MySQL 是怎样运行的：从根儿上理解 MySQL》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;初识-MySQL&quot;&gt;&lt;a href=&quot;#初识-MySQL&quot; class=&quot;headerlink&quot; title=&quot;初识 MySQL&quot;&gt;&lt;/a&gt;初识 MySQL&lt;/h2&gt;&lt;h3 id=&quot;启动服务器程序&quot;&gt;&lt;a href=&quot;#启动服务器程序&quot; class=&quot;headerlink&quot; title=&quot;启动服务器程序&quot;&gt;&lt;/a&gt;启动服务器程序&lt;/h3&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://taeyang0126.github.io/categories/MySQL/"/>
    
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://taeyang0126.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>BitMap</title>
    <link href="https://taeyang0126.github.io/2025/02/10/shu-ju-ku/bitmap/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/10/shu-ju-ku/bitmap/posts/undefined/</id>
    <published>2025-02-10T11:51:22.000Z</published>
    <updated>2025-02-10T11:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Roaring-Bitmap"><a href="#Roaring-Bitmap" class="headerlink" title="Roaring Bitmap"></a>Roaring Bitmap</h3><blockquote><p>Roaring Bitmaps 是一种高效的压缩位图数据结构，它在保持快速操作性能的同时，显著减少了内存使用。这种数据结构特别适用于表示和操作大型稀疏数据集</p></blockquote><p>基本结构： </p><ul><li>Roaring Bitmap 将 32 位整数空间分割成 2^16 &#x3D; 65536 个块。</li><li>每个块负责管理 2^16 个连续的整数。</li></ul><p>数据表示方法： </p><ul><li>对于稀疏的块（包含少量元素），使用简单的整数数组。<ul><li>用于存储稀疏数据（少量元素）</li><li>直接存储 16 位整数值</li><li>当元素数量小于 4,096 时使用</li></ul></li><li>对于稠密的块（包含大量元素），使用传统的位图。<ul><li>用于存储稠密数据（大量元素）</li><li>使用传统的位图表示，即 8,192 字节（65,536 位）</li><li>当元素数量大于等于 4,096 时使用</li></ul></li><li>对于连续的长整数序列，使用范围编码。<ul><li>用于存储连续的整数序列</li><li>存储开始和结束值的对</li><li>在特定情况下可以更节省空间</li></ul></li></ul><p>自适应性： </p><ul><li>Roaring Bitmap 会根据数据的分布自动选择最合适的容器类型，并在需要时动态转换容器类型。</li><li>这种自适应性使得 Roaring 在各种数据分布下都能保持高效。</li></ul><p>索引结构:</p><ul><li>使用一个高层索引（通常是一个数组）来快速定位到特定的容器。这个索引存储 16 位的高位值和指向相应容器的指针</li></ul><p>操作效率： </p><ul><li>支持快速的交集、并集、差集等集合操作。</li><li>这些操作可以直接在压缩的表示上执行，无需完全解压。</li></ul><p>内存效率： </p><ul><li>相比传统位图，Roaring 通常可以显著减少内存使用。</li><li>特别是对于稀疏数据集，节省的空间可能高达数百倍。</li></ul><p>使用场景： </p><ul><li>广泛应用于搜索引擎、数据库系统和大数据处理框架。</li><li>特别适合需要高效处理大量整数集合的应用。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Roaring-Bitmap&quot;&gt;&lt;a href=&quot;#Roaring-Bitmap&quot; class=&quot;headerlink&quot; title=&quot;Roaring Bitmap&quot;&gt;&lt;/a&gt;Roaring Bitmap&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Roaring Bitmaps 是一种高效的压缩位图数据结构，它在保持快速操作性能的同时，显著减少了内存使用。这种数据结构特别适用于表示和操作大型稀疏数据集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本结构： &lt;/p&gt;</summary>
    
    
    
    <category term="BitMap" scheme="https://taeyang0126.github.io/categories/BitMap/"/>
    
    
    <category term="BitMap" scheme="https://taeyang0126.github.io/tags/BitMap/"/>
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ES</title>
    <link href="https://taeyang0126.github.io/2025/02/10/shu-ju-ku/es/es/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/10/shu-ju-ku/es/es/posts/undefined/</id>
    <published>2025-02-10T10:51:22.000Z</published>
    <updated>2025-02-10T10:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/files/ES%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96.xlsx">ES参数优化</a></li></ul><h3 id="PUT、POST"><a href="#PUT、POST" class="headerlink" title="PUT、POST"></a>PUT、POST</h3><ul><li><code>PUT</code>操作主要是用来创建一个确定的新的文档<ul><li><code>PUT /index/_doc/1</code> 会创建一个 id&#x3D;1 的新文档，若是文档已存在，那么会进行删除，同时新增一条</li><li><code>PUT /index/_create/2</code> 会创建一个 id&#x3D;2 的新文档，若文档已存在，返回 http 409 错误</li></ul></li><li>POST 操作主要是用来创建一个不确定的新文档或者部分更新文档<ul><li><code>POST /index/_doc</code> 创建新文档，自动生成 ID</li><li><code>POST /index/_update/1</code> 部分更新现有文档</li></ul></li><li>最佳实践<ul><li>新增指定 ID 文档 &amp; 允许覆盖  <code>PUT /index/_doc/1</code></li><li>新增指定 ID 文档 &amp; 文档存在则报错 <code>PUT /index/_create/2</code></li><li>新增文档不指定 ID <code>POST /index/_doc</code></li><li>部分更新现有文档 <code>POST /index/_update/1</code></li></ul></li></ul><h3 id="index、create、update-API"><a href="#index、create、update-API" class="headerlink" title="index、create、update API"></a>index、create、update API</h3><h4 id="Index-API（索引-API）"><a href="#Index-API（索引-API）" class="headerlink" title="Index API（索引 API）"></a>Index API（索引 API）</h4><ul><li>作用：添加或替换文档。</li><li>类比：把一本书放在书架上。如果那个位置已经有书，就替换它。</li><li>示例：<code>PUT /library/book/1 &#123;&quot;title&quot;: &quot;Elasticsearch Guide&quot;&#125;</code></li><li>特点：不关心之前是否存在这本书。</li></ul><h4 id="Create-API（创建-API）"><a href="#Create-API（创建-API）" class="headerlink" title="Create API（创建 API）"></a>Create API（创建 API）</h4><ul><li>作用：仅添加新文档，如果文档已存在则失败。</li><li>类比：只有当书架上没有这本书时，才能放上去。</li><li>示例：<code>PUT /library/book/1?op_type=create &#123;&quot;title&quot;: &quot;New Book&quot;&#125;</code></li><li>特点：确保只添加新文档，不会覆盖现有文档。</li></ul><h4 id="Update-API（更新-API）"><a href="#Update-API（更新-API）" class="headerlink" title="Update API（更新 API）"></a>Update API（更新 API）</h4><ul><li>作用：修改现有文档的部分内容。</li><li>类比：修改书架上已有书的某些信息，比如更新作者名。</li><li>示例：<code>POST /library/book/1/_update &#123;&quot;doc&quot;: &#123;&quot;author&quot;: &quot;John Doe&quot;&#125;&#125;</code></li><li>特点：只能修改已存在的文档，且只更新指定的字段。</li></ul><ol><li>Index：不在乎文档是否已存在，总是添加或替换。（当你有新数据，但不确定它是否已存在时）</li><li>Create：只在文档不存在时才能成功。（当你只想添加新数据，绝不覆盖现有数据时）</li><li>Update：只能修改已存在的文档。（当你要修改现有数据的部分内容时）</li><li>Index 和 Create 通常使用 PUT 方法，Update 使用 POST 方法</li><li>Update 需要使用 “doc” 字段来指定要更新的内容</li></ol><h3 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h3><p><img data-src="/images/db/es/01.PNG" alt="img"></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="from-size"><a href="#from-size" class="headerlink" title="from + size"></a>from + size</h4><blockquote><p>from、size 超过 10000 时会报错，不适合深度分页，因为需要在每个分片上拉取 （from + size）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 简单的分页操作</span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: <span class="number">0</span>, # 指定开始位置</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">10</span>, # 指定获取文档个数</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h4><blockquote><p>使用 search after API 可以避免产生深分页的问题，不过 <strong>search after 不支持跳转到指定页数，只能一页页地往下翻</strong></p></blockquote><ol><li>在 sort 中指定需要排序的字段，并且保证其值的唯一性（可以使用文档的 ID）。</li><li>在下一次查询时，带上返回结果中最后一个文档的 sort 值进行访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 第一次调用 search after</span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123; <span class="string">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 返回结果</span><br><span class="line"><span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">      <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;sort&quot;</span> : [<span class="number">20.9</span>, <span class="string">&quot;6&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82462&quot;</span>,</span><br><span class="line">      <span class="string">&quot;price&quot;</span> : <span class="number">19.9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;sort&quot;</span> : [<span class="number">19.9</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 第二次调用 search after</span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;search_after&quot;</span>:[<span class="number">19.9</span>, <span class="string">&quot;1&quot;</span>], # 设置为上次返回结果中最后一个文档的 sort 值</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scroll-API"><a href="#Scroll-API" class="headerlink" title="Scroll API"></a>Scroll API</h4><blockquote><p>对结果集进行遍历的时候，例如做全量数据导出时，可以使用 scroll API。<strong>scroll API 会创建数据快照，后续的访问将会基于这个快照来进行，所以无法检索新写入的数据</strong></p></blockquote><ol><li>ES 7.10 中引入了 Point In Time 后，scroll API 就不建议被使用了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 第一次使用 scroll API，指定快照10m结束，超过10m</span><br><span class="line">POST books/_search?scroll=10m</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;, </span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_scroll_id&quot;</span> : <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF9......==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ......</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 进行翻页</span><br><span class="line">POST /_search/scroll                                                    </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scroll_id&quot;</span> : <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF9......==&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Point-in-time"><a href="#Point-in-time" class="headerlink" title="Point in time"></a>Point in time</h4><blockquote><p>Point In Time（PIT）是 ES 7.10 中引入的新特性，<strong>PIT 是一个轻量级的数据状态视图，用户可以利用这个视图反复查询某个索引，仿佛这个索引的数据集停留在某个时间点上</strong>。也就是说，在创建 PIT 之后更新的数据是无法被检索到的</p></blockquote><ol><li>使用 PIT 前需要显式使用 _pit API 获取一个 PID ID</li><li>PIT 可以允许用户在同一个固定数据集合上运行不同的查询，例如多个请求可以使用同一个 PIT 视图而互不影响</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用 pit API 获取一个 PID ID</span><br><span class="line">POST /books/_pit?keep_alive=20m</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>PIT 可以结合 search after 进行查询，能有效保证数据的一致性</li><li>Pit + search after 允许更改查询或排序字段，因为根据 search_after 一定定位到了某条数据，无论更改查询条件还是排序条件，只需要从新的查询条件的结果过滤出 search_after 后面的数据就能得到结果了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 第一次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。</span><br><span class="line"># 不再需要在 sort 中指定唯一的排序值了</span><br><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123; <span class="string">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="string">&quot;pit&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:  <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>, # 添加 PIT id</span><br><span class="line">    <span class="string">&quot;keep_alive&quot;</span>: <span class="string">&quot;5m&quot;</span> # 视图的有效时长</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; # 按价格倒序排序</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pit_id&quot;</span> : <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82467&quot;</span>,</span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">20.9</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sort&quot;</span> : [<span class="number">20.9</span>, <span class="number">8589934593</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;book_id&quot;</span> : <span class="string">&quot;4ee82462&quot;</span></span><br><span class="line">          <span class="string">&quot;price&quot;</span> : <span class="number">19.9</span></span><br><span class="line">        &#125;,</span><br><span class="line">        # 第一个是我们用作排序的 price 的值</span><br><span class="line">        # 第二个值是一个隐含的排序值。所有的 PIT 请求都会自动加入一个隐式的用于排序的字段称为：_shard_doc，当然这个排序值可以显式指定。</span><br><span class="line">        # 这个隐含的字段官方也称它为：tiebreaker（决胜字段），其代表的是文档的唯一值，保证了分页不会丢失或者分页结果的数据不会重复，其作用就好像原 search after 的 sort 字段中要指定的唯一值一样</span><br><span class="line">        <span class="string">&quot;sort&quot;</span> : [<span class="number">19.9</span>, <span class="number">8589934592</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。</span><br><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;pit&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:  <span class="string">&quot;46ToAwMDaWR5BXV1aWQy......==&quot;</span>, # 添加 PIT id</span><br><span class="line">    <span class="string">&quot;keep_alive&quot;</span>: <span class="string">&quot;5m&quot;</span> # 视图的有效时长</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;search_after&quot;</span>: [<span class="number">19.9</span>, <span class="number">8589934592</span>], # 上次结果中最后一个文档的 sort 值</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/files/ES%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96.xlsx&quot;&gt;ES参数优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;PUT、POST&quot;&gt;&lt;a href=&quot;#PUT、POST&quot; class=&quot;headerlink&quot; title=&quot;PUT、POST&quot;&gt;&lt;/a&gt;PUT、POST&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt;操作主要是用来创建一个确定的新的文档&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PUT /index/_doc/1&lt;/code&gt; 会创建一个 id&amp;#x3D;1 的新文档，若是文档已存在，那么会进行删除，同时新增一条&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT /index/_create/2&lt;/code&gt; 会创建一个 id&amp;#x3D;2 的新文档，若文档已存在，返回 http 409 错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;POST 操作主要是用来创建一个不确定的新文档或者部分更新文档&lt;ul&gt;
&lt;li&gt;&lt;code&gt;POST /index/_doc&lt;/code&gt; 创建新文档，自动生成 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST /index/_update/1&lt;/code&gt; 部分更新现有文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最佳实践&lt;ul&gt;
&lt;li&gt;新增指定 ID 文档 &amp;amp; 允许覆盖  &lt;code&gt;PUT /index/_doc/1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增指定 ID 文档 &amp;amp; 文档存在则报错 &lt;code&gt;PUT /index/_create/2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增文档不指定 ID &lt;code&gt;POST /index/_doc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;部分更新现有文档 &lt;code&gt;POST /index/_update/1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ES" scheme="https://taeyang0126.github.io/categories/ES/"/>
    
    
    <category term="数据库" scheme="https://taeyang0126.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="ES" scheme="https://taeyang0126.github.io/tags/ES/"/>
    
  </entry>
  
</feed>
