<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WL&#39;s blog</title>
  
  
  <link href="https://taeyang0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://taeyang0126.github.io/"/>
  <updated>2025-03-23T09:46:30.000Z</updated>
  <id>https://taeyang0126.github.io/</id>
  
  <author>
    <name>WU LEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存解析 - 4.JVM 元空间设计</title>
    <link href="https://taeyang0126.github.io/2025/03/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-yuan-kong-jian-she-ji/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-yuan-kong-jian-she-ji/posts/undefined/</id>
    <published>2025-03-23T09:46:30.000Z</published>
    <updated>2025-03-23T09:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析</p></blockquote><ul><li><a href="https://juejin.cn/post/7225879698952486972">元空间存储的元数据</a></li><li><a href="https://juejin.cn/post/7225879724545835045">元空间的核心概念与设计</a></li></ul><h2 id="什么是元数据，为什么需要元数据"><a href="#什么是元数据，为什么需要元数据" class="headerlink" title="什么是元数据，为什么需要元数据"></a>什么是元数据，为什么需要元数据</h2><hr><p>JVM 在执行 Java 应用程序时，将加载的 Java 类的许多细节记录在内存中，这些信息称为类<code>元数据（Class MetaData）</code>。这些元数据对于 Java 的很多灵活的语言以及虚拟机特性都是很重要的，比如动态类加载、JIT 实时编译、反射以及动态代理等等。不同的 JVM 加载类保存的内存信息是不一样的，它们通常<code>在更低的内存占用</code>与<code>更快的执行速度之间进行权衡</code>（类似于空间还是时间的权衡）。对于 OpenJDK Hotspot 使用的则是相对丰富的元数据模型来获得尽可能快的性能（时间优先，不影响速度的情况下尽量优化空间占用）。相比于 C,C++,Go 这些离线编译为可执行二进制文件的程序相比，像 JVM 这样的托管运行时动态解释执行或者编译执行的，<code>则需要保留更多关于正在执行的代码的运行时信息</code>。原因如下：</p><ol><li><code>依赖类库并不是一个确定的有限集</code>: Java 可以动态加载类，并且还有 ASM 以及 Javassist 这些工具在运行时动态定义类并加载，还有 JVMTI agent 这样的机制来动态修改类。所以，JVM 通过类元数据保存：<code>运行时中存在哪些类，它们包含哪些方法和字段，并能够在链接加载期间动态地解析从一个类到另一个类的引用</code>。类的链接也需要考虑类的<code>可见性和可访问性</code>。类元数据<code>与类加载器相关联</code>，同时类元数据也包括<code>类权限和包路径以及模块信息</code>（Java 9之后引入的模块化），以确定可访问性</li><li><code>JVM 解释执行或者通过 JIT 实时编译执行 Java 代码的时候需要基于类元数据的很多信息才能执行</code>：需要知道例如类与类之间的关系，类属性以及字段还有方法结构等等等等。例如在做强制转换的时候，需要检查类型的父子类关系确定是否可以强制转换等等。</li><li><code>JVM 需要一些统计数据决定哪些代码解释执行那些代码是热点代码需要 JIT 即时编译执行</code>。</li><li><code>Java 有反射 API 供用户使用</code>，这就需要运行时知道所有类的各种信息。</li></ol><h2 id="什么时候用到元空间，元空间保存什么"><a href="#什么时候用到元空间，元空间保存什么" class="headerlink" title="什么时候用到元空间，元空间保存什么"></a>什么时候用到元空间，元空间保存什么</h2><hr><h3 id="什么时候用到元空间，以及释放时机"><a href="#什么时候用到元空间，以及释放时机" class="headerlink" title="什么时候用到元空间，以及释放时机"></a>什么时候用到元空间，以及释放时机</h3><p><code>只要发生类加载，就会用到元空间</code>。例如我们创建一个类对象时：这个类首先会被类加载器加载，在发生类加载的时候，对应类的元数据被存入元空间。元数据分为<code>两部分存入元空间</code>，<code>一部分存入了元空间的类空间另一部分存入了元空间的非类空间</code>。堆中新建的对象的对象头中的 <code>Klass</code> 指针部分，指向元空间中 Klass，同时，Klass 中各种字段都是指针，实际对象的地址，可能在非类空间，例如实现方法多态以及 virtual call 的 vtable 与 itable 保存着方法代码地址的引用指针。非类空间中存储着比较大的元数据，例如常量池，字节码，JIT 编译后的代码等等。由于编译后的代码可能非常大，以及 JVM 对于多语言支持的扩展可能动态加载很多类，所以<code>将 MetaSpace 的类空间与非类空间区分开</code>。如图所示：</p><p><img data-src="/../../../images/jvm/memory/19.png" alt="img.png"></p><p>JVM 启动参数 <code>-XX:CompressedClassSpaceSize</code> 指定的是压缩类空间大小，默认是 <code>1G</code>。<code>-XX:MaxMetaspaceSize</code> 控制的是 MetaSpace 的总大小。</p><p>当类加载器加载的所有类都没有任何实例，并且没有任何指向这些类对象(java.lang.Class)的引用，也没有指向这个类加载器的引用的时候，如果发生了 GC，这个类加载器使用的元空间就会被释放。但是这个释放并不一定是释放回操作系统，而是被标记为可以被其他类加载器使用了。</p><h3 id="元空间保存什么"><a href="#元空间保存什么" class="headerlink" title="元空间保存什么"></a>元空间保存什么</h3><p>元空间保存的数据，目前分为两大类：</p><ul><li><code>Java 类数据</code>: 即加载的 Java 类对应 JVM 中的 Klass 对象（Klass 是 JVM 源码中的一个 c++ 类，你可以理解为类在 JVM 中的内存形式），但是这个 Klass 对象中存储的很多数据都是指针，具体的数据存储属于非 Java 类数据，一般非 Java 类数据远比 Java 类数据占用空间大。</li><li><code>非 Java 类数据</code>: 即被 Klass 对象引用的一些数据，例如：类中的各种方法，注解，执行采集与统计信息等等。</li></ul><p>如果是 64 位的 JVM 虚拟机（从 Java 9+ 开始只有 64 位的虚拟机了）并且开启了压缩类指针(<code>-XX:+UseCompressedClassPointers</code>，默认是开启的)，那么元空间会被划分成两部分：</p><ul><li><code>类元空间</code>：存储上面说的Java 类数据的空间</li><li><code>数据元空间</code>：存储上面说的非 Java 类数据的空间</li></ul><p>基于是否开启了压缩类指针分为这两部分的原因是，在对象头需要保留指向 <code>Klass</code> 的指针，如果我们能尽量压缩这个指针的大小，那么每个对象的大小也能得到压缩，这将节省很多堆空间。在 64 位虚拟机上面，指针默认都是 64 位大小的，开启压缩类指针(<code>-XX:+UseCompressedClassPointers</code>，默认是开启的)之后，类指针变为 32 位大小，最多能指向 2^32 也就是 4G 的空间，如果我们能保持 Klass 所处的空间占用不超过这个限制的话，就能使用压缩类指针了。所以我们把 Klass 单独提取到一个单独的区域进行分配。Klass 占用的空间并不会太大，虽然对于 Java 中的每一个类都会有一个 Klass，但是占用空间的方法内容以及动态编译信息等等，具体数据都在<code>数据元空间</code>中存储，Klass 中大部分都是指针。基本上很少会遇到 32 位指针不够用的情况。</p><p>注意，老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是从 Java 15 Build 23 开始， UseCompressedClassPointers 已经不再依赖 UseCompressedOops 了，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。</p><p>在元空间分配的对象，都是调用 <code>Metaspace::allocate</code> 从元空间分配空间。调用这个方法的是 <code>MetaspaceObj</code> 的构造函数，对应源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/memory/allocation.cpp">https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/memory/allocation.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* MetaspaceObj::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, ClassLoaderData* loader_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">size_t</span> word_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 MetaspaceObj::Type type, TRAPS)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Klass has its own operator new</span></span><br><span class="line">  <span class="keyword">return</span> Metaspace::<span class="built_in">allocate</span>(loader_data, word_size, type, THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* MetaspaceObj::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, ClassLoaderData* loader_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">size_t</span> word_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 MetaspaceObj::Type type)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!Thread::<span class="built_in">current</span>()-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;only allowed by non-Java thread&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> Metaspace::<span class="built_in">allocate</span>(loader_data, word_size, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MetaspaceObj</code> 的 Operator new 方法定义了从 MetaSpace 上分配内存，即所有 <code>MetaspaceObj</code> 的子类，只要没有明确覆盖从其他地方分配，就会从 MetaSpace 分配内存。<code>MetaspaceObj</code> 的子类包括：</p><p><code>位于类元空间的</code>：</p><ul><li><code>Klass</code>: 其实就是 Java 类的实例（每个 Java 的 class 有一个对应的对象实例，用来反射访问，这个就是那个对象实例），即 Java 对象头的类型指针指向的实例：<ul><li><code>InstanceKlass</code>：普通对象类的 Klass：<ul><li><code>InstanceRefKlass</code>：<code>java.lang.ref.Reference</code> 类以及子类对应的 Klass</li><li><code>InstanceClassLoaderKlass</code>：Java 类加载器对应的 Klass</li><li><code>InstanceMirrorKlass</code>：java.lang.Class 对应的 Klass</li></ul></li><li><code>ArrayKlass</code>：Java 数组对应的 Klass<ul><li><code>ObjArrayKlass</code>：普通对象数组对应的 Klass</li><li><code>TypeArrayKlass</code>：原始类型数组对应的 Klass</li></ul></li></ul></li></ul><p><code>位于数据元空间的</code>：</p><ul><li><code>Symbol</code>：符号常量，即类中所有的符号字符串，例如类名称，方法名称，方法定义等等。</li><li><code>ConstantPool</code>：运行时常量池，数据来自于类文件中的常量池。</li><li><code>ConstanPoolCache</code>：运行时常量池缓存，用于加速常量池访问</li><li><code>ConstMethod</code>：类文件中的方法解析后，静态信息放入 ConstMethod，这部分信息可以理解为是不变的，例如字节码，行号，方法异常表，本地变量表，参数表等等。</li><li><code>MethodCounters</code>：方法的计数器相关数据。</li><li><code>MethodData</code>：方法数据采集，动态编译相关数据。例如某个方法需要采集一些指标，决定是否采用 C1 C2 动态编译优化性能。</li><li><code>Method</code>：Java 方法，包含以上 <code>ConstMethod</code>，<code>MethodCounters</code>，<code>MethodData</code> 的指针以及一些额外数据。</li><li><code>RecordComponent</code>：对应 Java 14 新特性 Record，即从 Record 中解析出的关键信息。</li></ul><h2 id="元空间的核心概念与设计"><a href="#元空间的核心概念与设计" class="headerlink" title="元空间的核心概念与设计"></a>元空间的核心概念与设计</h2><hr><h3 id="元空间的整体配置以及相关参数"><a href="#元空间的整体配置以及相关参数" class="headerlink" title="元空间的整体配置以及相关参数"></a>元空间的整体配置以及相关参数</h3><ul><li><code>MetaspaceSize</code>：初始元空间大小，也是最小元空间大小。后面元空间大小伸缩的时候，不会小于这个大小。默认是 21M。</li><li><code>MaxMetaspaceSize</code>：最大元空间大小，默认是无符号 int 最大值。</li><li><code>MinMetaspaceExpansion</code>：每次元空间大小伸缩的时候，至少改变的大小。默认是 256K。</li><li><code>MaxMetaspaceExpansion</code>: 每次元空间大小伸缩的时候，最多改变的大小。默认是 4M。</li><li><code>MaxMetaspaceFreeRatio</code>：最大元空间空闲比例，默认是 70，即 70%。</li><li><code>MinMetaspaceFreeRatio</code>：最小元空间空闲比例，默认是 40，即 40%。</li><li><code>UseCompressedClassPointers</code>：前文提到过，是否开启压缩类指针。默认是开启的。老版本中， UseCompressedClassPointers 取决于 UseCompressedOops，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是从 Java 15 Build 23 开始， UseCompressedClassPointers 已经不再依赖 UseCompressedOops 了，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。</li><li><code>CompressedClassSpaceSize</code>：如果启用了压缩类指针，则元空间会分为类元空间和数据元空间，否则只有数据元空间。这个参数限制类元空间的大小，范围是 1M ~ 3G。默认大小是 1G，如果指定了 <code>MaxMetaspaceSize</code>，那么为 1G 与 <code>MaxMetaspaceSize * 0.8</code> 中比较小的那个值</li><li><code>CompressedClassSpaceBaseAddress</code>：类元空间起始虚拟内存地址，这个一般不指定。作用和前文分析堆内存的堆起始位置的作用差不多。</li><li><code>MetaspaceReclaimPolicy</code>：可以为：<code>balanced</code>, <code>aggressive</code>, 以及 <code>none</code>，需要注意一点的是 none 要被移除了。默认是 balanced。具体主要是影响元空间底层相关的配置</li></ul><p>元空间底层相关的配置包括：</p><ul><li><code>commit 粒度 - commit_granule</code>：通过第二章的分析我们知道，JVM 的空间一般是先 reserve， 之后 commit 之前 reserve 的空间的一部分，然后才能使用的。这个 commit 粒度代表元空间中 commit 内存的最小粒度，元空间在扩容缩容的时候最小的大小单位是 commit 粒度。</li><li><code>虚拟内存空间节点内存大小 - virtual_space_node_default_word_size</code>：这是后文我们会详细分析的 VirtualSpaceNode 的虚拟内存大小。大小在 64 位环境下是 64 MB。</li><li><code>虚拟内存空间节点内存对齐 - virtual_space_node_reserve_alignment_words</code>：这是后文我们会详细分析的 <code>VirtualSpaceNode</code> 的虚拟内存大小需要对齐的大小，即整体大小需要大于这个对齐大小并且是这个对齐大小整数倍。这个大小就是 <code>MetaChunk</code> 的最大大小，即 4MB。</li><li><code>当前 MetaChunk 不足以分配的时候，是否尝试扩容当前 MetaChunk - enlarge_chunks_in_place</code>：这个参数在正式 JVM 中是 true，并且不能修改。后文我们会详细分析什么是 MetaChunk。这里简单理解就是，元空间整体使用了和 Linux 伙伴分配算法类似的设计与抽象，其中内存分配的单元就是 Chunk，元空间中对应的就是 MetaChunk。</li><li><code>分配新的 MetaChunk 的时候，是否一下子 commit MetaChunk 所有的内存 - new_chunks_are_fully_committed</code>：后文我们会详细分析什么是 MetaChunk。</li><li><code>在 MetaChunk 整个空间都没有使用的时候，是否将 MetaChunk 的内存全部释放回操作系统 - uncommit_free_chunks</code>：后文我们会详细分析什么是 MetaChunk。</li></ul><p>从 Java 16 开始，引入了弹性元空间。老的元空间由于设计上分配粒度比较大，并且没有很好地释放空间的策略设计，所以占用可能比较大。Java 16 开始，JEP 387: Elastic Metaspace 引入了<code>弹性元空间的设计</code>，也是我们这里要讨论的设计。这个弹性元空间也引入了一个重要的参数 <code>-XX:MetaspaceReclaimPolicy</code>。</p><p><code>MetaspaceReclaimPolicy</code>：可以为：<code>balanced</code>, <code>aggressive</code>, 以及 <code>none</code>，需要注意一点的是 none 要被移除了，这三个配置具体影响是：</p><p><img data-src="/../../../images/jvm/memory/20.png" alt="img.png"></p><h3 id="元空间上下文-MetaspaceContext"><a href="#元空间上下文-MetaspaceContext" class="headerlink" title="元空间上下文 MetaspaceContext"></a>元空间上下文 MetaspaceContext</h3><p><code>MetaspaceContext</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 Metaspace 那一类别，即元空间的抽象类占用的空间。</p><p>JVM 元空间，会在全局建立<code>两个元空间上下文</code>（<code>MetaspaceContext</code>），一个用于类元空间（我们后面称为<code>类元空间 MetaspaceContext</code>），一个用于数据元空间（我们后面称为<code>数据元空间 MetaspaceContext</code>）。当然，在没有启用压缩类指针的时候，只会初始化一个数据元空间 <code>MetaspaceContext</code>，不会初始化类元空间 <code>MetaspaceContext</code>，之后使用分配的时候，也只会用数据元空间 MetaspaceContext 进行分配。但是我们在后面讨论的时候，<code>只会讨论开启压缩类指针的情况，因为这是默认并且常用的情况</code>。</p><p><img data-src="/../../../images/jvm/memory/21.png" alt="img.png"></p><p>每个 <code>MetaspaceContext</code> 都会对应<code>一个独立的</code> <code>VirtualSpaceList</code>，以及一个独立的 <code>ChunkManager</code>。</p><p><img data-src="/../../../images/jvm/memory/22.png" alt="img.png"></p><p>这个 <code>VirtualSpaceList</code> 中的每一个元素都是一个 <code>VirtualSpaceNode</code>。顾名思义，<code>VirtualSpaceNode</code> 是从操作系统申请内存，与元空间内存划分的抽象隔离的中间层抽象。<code>VirtualSpaceList</code> 负责与操作系统交互，申请或者释放内存。元空间与 <code>VirtualSpaceList</code> 交互，使用内存。</p><p><code>ChunkManager</code> 顾名思义，是管理所有 Chunk 的内存管理器。Chunk 这个概念经常出现在各种伙伴内存管理算法框架（Buddy Allocator）中，一般指内存管理分配的最小单元，这里的 Chunk 抽象对应的就是 <code>MetaChunk</code>。<code>ChunkManager</code> 从 <code>VirtualSpaceList</code> 上面获取一块连续比较大的内存的 <code>MetaChunk</code>（其实是 <code>RootMetaChunk</code>），然后将这个 <code>RootMetaChunk</code> 按照分配需求，连续对半分割成需要的大小，返回这个合适大小的 <code>MetaChunk</code>，剩下的分割出来的 <code>MetaChunk</code> 进入 <code>FreeChunkListVector</code> 用于下次分配 <code>MetaChunk</code> 的时候，直接返回合适的，就不再从 <code>VirtualSpaceList</code> 获取了。</p><h3 id="虚拟内存空间节点列表-VirtualSpaceList"><a href="#虚拟内存空间节点列表-VirtualSpaceList" class="headerlink" title="虚拟内存空间节点列表 VirtualSpaceList"></a>虚拟内存空间节点列表 VirtualSpaceList</h3><p><code>VirtualSpaceList</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。其实本人感觉这么设计不太合理，应该和 <code>MetaspaceContext</code> 属于同一个类别才比较合理。真正分配加载的类的占用空间的是从 <code>VirtualSpaceNode</code> 上面标记的内存分配的，这是下一小节要分析的内容。</p><p>首先提一点，类元空间 <code>MetaspaceContext</code> 与数据元空间 <code>MetaspaceContext</code> 略有不同：类元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是不可以扩展申请新的内存的，但是数据元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是可以的。也就是说：类元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 其实只有一个 <code>VirtualSpaceNode</code>，但是数据元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是一个包含多个 <code>VirtualSpaceNode</code> 的列表。</p><p><img data-src="/../../../images/jvm/memory/23.png" alt="img.png"></p><h3 id="虚拟内存空间节点-VirtualSpaceNode-与-CompressedClassSpaceSize"><a href="#虚拟内存空间节点-VirtualSpaceNode-与-CompressedClassSpaceSize" class="headerlink" title="虚拟内存空间节点 VirtualSpaceNode 与 CompressedClassSpaceSize"></a>虚拟内存空间节点 VirtualSpaceNode 与 CompressedClassSpaceSize</h3><p><code>VirtualSpaceNode</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。其实本人感觉这么设计不太合理，应该和 <code>MetaspaceContext</code> 属于同一个类别才比较合理。真正分配加载的类的占用空间的是从 <code>VirtualSpaceNode</code> 上面标记的内存地址分配的，<code>VirtualSpaceNode</code> 本身的空间占用只是起到描述记录作用，应该也属于元空间描述的那一类。</p><p><code>VirtualSpaceNode</code> 是一块连续的虚拟内存空间内存的抽象。类元空间的 <code>VirtualSpaceList</code> 只包含一个 <code>VirtualSpaceNode</code>，大小是前文提到的 <code>CompressedClassSpaceSize</code>。</p><p><code>数据元空间并不像类元空间或者堆内存那样</code>，一下子 reserve 最大堆内存限制的内存，而是<code>每次 reserve VirtualSpaceNode 大小</code>。<code>VirtualSpaceNode</code> 大小在 64 位环境下是 64 MB。</p><p><code>VirtualSpaceNode</code> 通过两个数据结构来管理它维护的虚拟内存空间：</p><ul><li><code>CommitMask</code>：实际是一个位图，用于维护哪些内存被 commit 了，哪些没有，位图的标记的单位就是前文提到的 commit_granule（commit 粒度）。</li><li><code>RootChunkAreaLUT</code>：用于维护每个 <code>RootMetaChunk</code> 的内存分布。</li></ul><p>一个 <code>VirtualSpaceNode</code> 的主要结构如下图所示：</p><p><img data-src="/../../../images/jvm/memory/24.png" alt="img.png"></p><h3 id="MetaChunk"><a href="#MetaChunk" class="headerlink" title="MetaChunk"></a>MetaChunk</h3><p><code>MetaChunk</code> 是元空间内存分配的核心抽象，其本质就是<code>描述</code>一块连续的虚拟内存空间。<code>MetaChunk</code> 本身只是一个描述对象，它也是直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。这个描述对象是池化的，参考后面会分析的 <code>ChunkHeaderPool</code>。</p><p>元空间的任意分配，都是在某个 <code>MetaChunk</code> 上进行的。<code>MetaChunk</code> 有级别的概念，即 <code>ChunkLevel</code>，每个 <code>MetaChunk</code> 都有自己的 <code>ChunkLevel</code>，这个 <code>ChunkLevel</code> 主要代表了 <code>MetaChunk</code> 描述的内存空间的大小，每一个 level 都是下一个 level 大小的 2 倍：</p><p><img data-src="/../../../images/jvm/memory/25.png" alt="img.png"></p><p>从 <code>VirtualSpaceNode</code> 上直接划分的 <code>MetaChunk</code> 是 <code>RootMetaChunk</code>，它的 <code>ChunkLevel</code> 为最高级别的 0，大小是 4MB，并且其中的内存只是 reserve 还没有 commit 的。</p><p><code>MetaChunk</code>有三个状态：</p><ul><li><code>Dead</code>：即 <code>MetaChunk</code> 只是对象被创建出来，但是没有关联描述实际的虚拟内存。后面我们会知道，<code>MetaChunk</code> 是池化可回收在利用的，<code>MetaChunk</code> 的池就是 <code>ChunkHeaderPool</code>。位于 <code>ChunkHeaderPool</code> 都还没有关联描述实际的虚拟内存，状态为 <code>Dead</code>。</li><li><code>Free</code>：即 <code>MetaChunk</code> 关联描述了实际的虚拟内存，但是没有被实际使用。此时，这个 <code>MetaChunk</code> 位于 <code>ChunkManager</code> 管理。</li><li><code>InUse</code>：即 <code>MetaChunk</code> 关联描述了实际的虚拟内存，也被实际使用了，此时，<code>MetaChunkArena</code> 管理这个 <code>MetaChunk</code> 上面的内存分配。</li></ul><h4 id="ChunkHeaderPool-池化-MetaChunk-对象"><a href="#ChunkHeaderPool-池化-MetaChunk-对象" class="headerlink" title="ChunkHeaderPool 池化 MetaChunk 对象"></a>ChunkHeaderPool 池化 MetaChunk 对象</h4><p><code>MetaChunk</code> 实际上只是一块连续的虚拟内存空间的描述类，即元数据类。由于类加载需要的大小不一，并且还经常会发生合并，切分等等，<code>MetaChunk</code> 可能有很多很多，元空间为了节省这个元数据类占用的空间，将其池化，回收再利用。这个池就是 <code>ChunkHeaderPool</code>。例如，从 <code>VirtualSpaceNode</code> 上直接划分 <code>RootMetaChunk</code> 的内存空间，会从 <code>ChunkHeaderPool</code> 申请一个 <code>MetaChunk</code> 用于描述。当两个 <code>MetaChunk</code> 的空间需要合并成一个的时候，其中一个 <code>MetaChunk</code> 其实就没有用了，会放回 <code>ChunkHeaderPool</code>，而不是直接 <code>free</code> 掉这个对象。</p><p><code>ChunkHeaderPool</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。</p><p>其实从这里我们可以推测出，<code>MetaChunk</code> 本身也是直接原生堆上面分配，Native Memory Tracking 中也是属于 <code>Metaspace</code> 那一类别。</p><p><code>ChunkHeaderPool</code> 的结构是：</p><p><img data-src="/../../../images/jvm/memory/26.png" alt="img.png"></p><p>其实 <code>ChunkHeaderPool</code> 的机制很简单：</p><ul><li>申请 <code>MetaChunk</code> 用于描述内存：<ul><li>首先查看 <code>_freelist</code>，是否有之前放回的 <code>MetaChunk</code> 可以使用，如果有，就返回那个 <code>MetaChunk</code>，并从 <code>_freelist</code> 移除这个 <code>MetaChunk</code></li><li>如果没有，读取 <code>_current_slab</code> 指向的 <code>Slab</code>，<code>Slab</code> 核心就是一个预分配好的 <code>MetaChunk</code> 数组（大小是 128），<code>_top</code> 指的是当前使用到数组的哪一个。</li><li>如果 <code>_top</code> 没有到 128，返回 <code>_top</code> 代表的 <code>MetaChunk</code>，并将 <code>_top</code> 加 1。</li><li>如果 <code>_top</code> 到 128，创建新的 <code>Slab</code>，<code>_current_slab</code> 指向这个新的 <code>Slab</code></li></ul></li><li>回收 <code>MetaChunk</code>：放入 <code>_freelist</code></li></ul><h4 id="ChunkManager-管理空闲的-MetaChunk"><a href="#ChunkManager-管理空闲的-MetaChunk" class="headerlink" title="ChunkManager 管理空闲的 MetaChunk"></a>ChunkManager 管理空闲的 MetaChunk</h4><p><code>ChunkManager</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间</p><p><code>ChunkManager</code> 管理已经关联内存但是还没使用（状态是 Free）的 MetaChunk。在第一次从 <code>VirtualSpaceNode</code> 上面分配 <code>RootMetaChunk</code> 的内存的时候，根据申请的内存大小，决定要将 <code>RootMetaChunk</code> 拆分到某个 <code>ChunkLevel</code> 大小之后用于当前分配，拆分出来的其他的 <code>MetaChunk</code> 还没有使用，先放入一个类似于之前 <code>ChunkHeaderPool</code> 里面的 <code>_free_list</code> 的结构，用于下次申请 <code>MetaChunk</code> 用于分配的时候，先从这个里面找，找不到之后再从 <code>VirtualSpaceNode</code> 上面尝试分配新的 <code>RootMetaChunk</code>。</p><p><code>ChunkManager</code> 的整体结构是：</p><p><img data-src="/../../../images/jvm/memory/27.png" alt="img.png"></p><p><code>ChunkManager</code> 主要维护一个 <code>FreeChunkListVector</code>，<code>FreeChunkListVector</code> 里面是一个 <code>FreeChunkList</code> 数组。<code>FreeChunkList</code> 是一个 <code>MetaChunk</code> 链表，链表中都是 <code>Free</code> 的 <code>MetaChunk</code>，同样 <code>ChunkLevel</code> 的 <code>MetaChunk</code> 位于同一个 <code>FreeChunkList</code> 中。<code>FreeChunkList</code> 数组以 <code>ChunkLevel</code> 为下标，这样的数据结构可以快速找到一个所需 <code>ChunkLevel</code> 的 <code>MetaChunk</code>。<code>FreeChunkList</code>这个链表其实是一个双向链表，包含头尾两个指针，如果一个 <code>MetaChunk</code> 管理的内存被 commit 了，就会放在链表头部，没有 commit 的放在链表尾部。</p><p><code>MetaChunk</code> 具体的分配，切分，合并流程，我们会在介绍完 <code>MetaspaceArena</code> 之后详细分析。但是，<code>MetaspaceArena</code> 和 <code>ChunkManager</code> 不一样，<code>ChunkManager</code> 是全局两个，一个属于类元空间，一个属于数据元空间，倘若没有开启压缩类指针，那么就只有一个数据元空间 <code>ChunkManager</code>，而 <code>MetaspaceArena</code> 我们后面会看到是每个 <code>ClassLoader</code> 独立私有的。所以，在讲 <code>MetaspaceArena</code> 之前，我们先要从另一个角度即 <code>ClassLoader</code> 加载类的角度出发，向下一层一层剖析到 <code>MetaspaceArena</code>。</p><h3 id="类加载的入口-SystemDictionary-与保留所有-ClassLoaderData-的-ClassLoaderDataGraph"><a href="#类加载的入口-SystemDictionary-与保留所有-ClassLoaderData-的-ClassLoaderDataGraph" class="headerlink" title="类加载的入口 SystemDictionary 与保留所有 ClassLoaderData 的 ClassLoaderDataGraph"></a>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></h3><p>类加载的入口在全局唯一的 SystemDictionary 中，这里我们只是为了看一下类加载需要哪些参数，来搞清楚对应关系，不用关心细节</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225879698952486972&quot;&gt;元空间存储的元数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225879724545835045&quot;&gt;元空间的核心概念与设计&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是元数据，为什么需要元数据&quot;&gt;&lt;a href=&quot;#什么是元数据，为什么需要元数据&quot; class=&quot;headerlink&quot; title=&quot;什么是元数据，为什么需要元数据&quot;&gt;&lt;/a&gt;什么是元数据，为什么需要元数据&lt;/h2&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="元空间" scheme="https://taeyang0126.github.io/tags/%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>loom-Continuation</title>
    <link href="https://taeyang0126.github.io/2025/03/23/loom/continuation/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/23/loom/continuation/posts/undefined/</id>
    <published>2025-03-23T02:51:22.000Z</published>
    <updated>2025-03-23T02:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础条件"><a href="#基础条件" class="headerlink" title="基础条件"></a>基础条件</h3><hr><ul><li>jdk21及以上</li><li>编译&#x2F;运行时开启 <code>--enable-preview</code> &amp; <code>--add-exports=java.base/jdk.internal.vm=ALL-UNNAMED</code></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinuationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">cont</span> <span class="operator">=</span> getContinuation();</span><br><span class="line">        cont.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        cont.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        cont.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Continuation <span class="title function_">getContinuation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;Demo&quot;</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">cont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(scope, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Continuation.<span class="keyword">yield</span>(scope);</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Continuation.<span class="keyword">yield</span>(scope);</span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cont;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ContinuationScope"><a href="#ContinuationScope" class="headerlink" title="ContinuationScope"></a>ContinuationScope</h4><ol><li>定义挂起边界: 只有在 <code>scope</code> 内才能被挂起</li><li>实现嵌套和隔离: ContinuationScope 允许创建多个互相隔离的作用域，支持嵌套调用时的独立控制<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ContinuationScope</span> <span class="variable">OUTER_SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;outer&quot;</span>);</span><br><span class="line"><span class="type">ContinuationScope</span> <span class="variable">INNER_SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;inner&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Continuation</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(OUTER_SCOPE, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外层开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Continuation</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(INNER_SCOPE, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内层开始&quot;</span>);</span><br><span class="line">        Continuation.<span class="keyword">yield</span>(INNER_SCOPE); <span class="comment">// 只挂起内层</span></span><br><span class="line">        System.out.println(<span class="string">&quot;内层继续&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!inner.isDone()) inner.run();</span><br><span class="line">    </span><br><span class="line">    Continuation.<span class="keyword">yield</span>(OUTER_SCOPE); <span class="comment">// 只挂起外层</span></span><br><span class="line">    System.out.println(<span class="string">&quot;外层继续&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>控制挂起权限</li><li>安全性保障</li><li>分层架构支持</li><li>调试和监控支持</li></ol><h4 id="Continuation-yield"><a href="#Continuation-yield" class="headerlink" title="Continuation#yield"></a>Continuation#yield</h4><ol><li><code>挂起执行</code>：立即暂停当前 Continuation 的执行</li><li><code>保存状态</code>：保存当前执行状态（包括调用栈、局部变量等）</li><li><code>返回控制权</code>：将控制权返回到启动该 Continuation 的 run() 方法的<code>调用者</code></li></ol><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img data-src="/../../images/loom/img7.png" alt="img.png"></p><ol><li>执行 <code>yield</code> 会返回 run() 方法的调用者，同时将堆栈信息保存到 <code>Continuation</code> 对象中</li><li>当执行 <code>run</code> 时，会将控制权转移到最后一个 <code>yield</code> 的地方继续执行</li></ol><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol><li>异步转同步<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fetchDataSynchronously</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ContinuationScope</span> <span class="variable">SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;io&quot;</span>);</span><br><span class="line"> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">Continuation</span> <span class="variable">cont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(SCOPE, () -&gt; &#123;</span><br><span class="line">     <span class="comment">// 发起异步操作</span></span><br><span class="line">     CompletableFuture&lt;Result&gt; future = service.fetchDataAsync();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 注册回调以恢复 Continuation</span></span><br><span class="line">     future.whenComplete((r, ex) -&gt; &#123;</span><br><span class="line">         result = r;</span><br><span class="line">         scheduler.schedule(cont::run, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">     &#125;);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 挂起等待结果</span></span><br><span class="line">     Continuation.<span class="keyword">yield</span>(SCOPE);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 恢复后处理结果</span></span><br><span class="line">     processResult(result);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 开始执行</span></span><br><span class="line"> cont.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现协作式调度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cooperativeTask</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ContinuationScope</span> <span class="variable">SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">         <span class="comment">// 做一些计算</span></span><br><span class="line">         compute();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 每处理一定量数据就主动让出控制权</span></span><br><span class="line">         <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">             Continuation.<span class="keyword">yield</span>(SCOPE);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="type">Continuation</span> <span class="variable">cont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(SCOPE, task);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 循环执行直到完成</span></span><br><span class="line"> <span class="keyword">while</span> (!cont.isDone()) &#123;</span><br><span class="line">     cont.run();</span><br><span class="line">     <span class="comment">// 这里可以调度其他任务</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实现简单的虚拟线程"><a href="#实现简单的虚拟线程" class="headerlink" title="实现简单的虚拟线程"></a>实现简单的虚拟线程</h3><hr><p><img data-src="/../../images/loom/img8.png" alt="img.png"></p><h4 id="实现-VirtualThread"><a href="#实现-VirtualThread" class="headerlink" title="实现 VirtualThread"></a>实现 VirtualThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ContinuationScope</span> <span class="variable">SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;VirtualThread&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">COUNTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Continuation cont;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VirtualThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cont = <span class="keyword">new</span> <span class="title class_">Continuation</span>(SCOPE, runnable);</span><br><span class="line">        <span class="built_in">this</span>.id = COUNTER.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Virtual Thread %s is running on %s\n&quot;</span>, id, Thread.currentThread());</span><br><span class="line">        cont.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-VirtualThreadScheduler"><a href="#实现-VirtualThreadScheduler" class="headerlink" title="实现 VirtualThreadScheduler"></a>实现 VirtualThreadScheduler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadScheduler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;VirtualThread&gt; CURRENT_VIRTUAL_THREAD = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;VirtualThread&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">VirtualThread</span> <span class="variable">vt</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                <span class="comment">// 创建一个新的执行环境，在该环境中CURRENT_VIRTUAL_THREAD的值被设置为vt</span></span><br><span class="line">                <span class="comment">// 这个值只在接下来的.run()方法执行的代码块中可见</span></span><br><span class="line">                executor.submit(() -&gt; ScopedValue.where(CURRENT_VIRTUAL_THREAD, vt).run(vt::run));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduler</span><span class="params">(VirtualThread vt)</span> &#123;</span><br><span class="line">        queue.add(vt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-WaitingOperation"><a href="#实现-WaitingOperation" class="headerlink" title="实现 WaitingOperation"></a>实现 WaitingOperation</h4><blockquote><p>模拟一些IO操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingOperation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">(String name, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;wait for %s for %d seconds\n&quot;</span>, name, duration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前执行的vt</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">VirtualThread</span> <span class="operator">=</span> VirtualThreadScheduler.CURRENT_VIRTUAL_THREAD.get();</span><br><span class="line">        <span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 让vt继续执行</span></span><br><span class="line">                SCHEDULER.scheduler(VirtualThread);</span><br><span class="line">                timer.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, duration * <span class="number">1_000L</span>);</span><br><span class="line"></span><br><span class="line">        Continuation.<span class="keyword">yield</span>(SCOPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">VirtualThreadScheduler</span> <span class="variable">SCHEDULER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualThreadScheduler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(SCHEDULER::start).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总数量: 4000</span></span><br><span class="line">        <span class="comment">// 一半任务需要2s，另外一半5s</span></span><br><span class="line">        <span class="comment">// 10个线程</span></span><br><span class="line">        <span class="comment">// 虚拟线程: 只需要 5s</span></span><br><span class="line">        <span class="comment">// 平台线程: 2000 * 2 / 10 + 2000 * 5 / 10 = 1400s</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(count * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">vt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualThread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1.1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">                WaitingOperation.perform(<span class="string">&quot;Network&quot;</span>, <span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;1.3&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;1.4&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">var</span> <span class="variable">vt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualThread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2.1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;2.2&quot;</span>);</span><br><span class="line">                WaitingOperation.perform(<span class="string">&quot;DB&quot;</span>, <span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;2.3&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;2.4&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            SCHEDULER.scheduler(vt1);</span><br><span class="line">            SCHEDULER.scheduler(vt2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish -&gt; &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现 2000个 2s 的任务，2000个 5s 的任务，在平台线程只有 <code>10</code> 的基础上只需要 <code>5s</code></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基础条件&quot;&gt;&lt;a href=&quot;#基础条件&quot; class=&quot;headerlink&quot; title=&quot;基础条件&quot;&gt;&lt;/a&gt;基础条件&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;jdk21及以上&lt;/li&gt;
&lt;li&gt;编译&amp;#x2F;运行时开启 &lt;code&gt;--enable-preview&lt;/code&gt; &amp;amp; &lt;code&gt;--add-exports=java.base/jdk.internal.vm=ALL-UNNAMED&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/categories/loom/"/>
    
    
    <category term="loom" scheme="https://taeyang0126.github.io/tags/loom/"/>
    
    <category term="虚拟线程" scheme="https://taeyang0126.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="java" scheme="https://taeyang0126.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient基准测试</title>
    <link href="https://taeyang0126.github.io/2025/03/15/java/httpclient-ji-zhun-ce-shi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/15/java/httpclient-ji-zhun-ce-shi/posts/undefined/</id>
    <published>2025-03-15T02:43:22.000Z</published>
    <updated>2025-03-15T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/taeyang0126/JavaForge/tree/main/src/main/java/com/lei/java/forge/http">case</a></li></ul><h2 id="使用-WireMockServer-测试"><a href="#使用-WireMockServer-测试" class="headerlink" title="使用 WireMockServer 测试"></a>使用 WireMockServer 测试</h2><hr><h3 id="自定义-WireMockServer"><a href="#自定义-WireMockServer" class="headerlink" title="自定义 WireMockServer"></a>自定义 WireMockServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWireMockServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WireMockServer mockServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomWireMockServer</span><span class="params">(<span class="type">int</span> fixedDelayMs)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">containerThreads</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 增加容器线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">responseThreads</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 增加响应线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">WireMockConfiguration</span> <span class="variable">options</span> <span class="operator">=</span> WireMockConfiguration.options()</span><br><span class="line">                .port(<span class="number">8080</span>)</span><br><span class="line">                .containerThreads(containerThreads)      <span class="comment">// 增加容器线程数</span></span><br><span class="line">                .jettyAcceptors(<span class="number">4</span>)                       <span class="comment">// 增加接收器数量</span></span><br><span class="line">                .jettyAcceptQueueSize(<span class="number">100</span>)               <span class="comment">// 增加接受队列大小</span></span><br><span class="line">                .asynchronousResponseEnabled(<span class="literal">true</span>)       <span class="comment">// 启用异步响应</span></span><br><span class="line">                .asynchronousResponseThreads(responseThreads); <span class="comment">// 设置异步响应线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.mockServer = <span class="keyword">new</span> <span class="title class_">WireMockServer</span>(options);</span><br><span class="line">        <span class="built_in">this</span>.mockServer.start();</span><br><span class="line"></span><br><span class="line">        mockServer.stubFor(get(urlEqualTo(<span class="string">&quot;/test&quot;</span>))</span><br><span class="line">                .willReturn(aResponse()</span><br><span class="line">                        .withFixedDelay(fixedDelayMs)</span><br><span class="line">                        .withStatus(<span class="number">200</span>)</span><br><span class="line">                        .withBody(<span class="string">&quot;Hello&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.url = mockServer.baseUrl() + <span class="string">&quot;/test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockServer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th>http client</th><th>测试条件</th><th>测试结果</th><th>说明</th><th>推荐指数</th></tr></thead><tbody><tr><td>jdk11之后提供的 <code>HttpClient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>0.5s</code><br/> requestCount&#x3D;10000 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>nio</code><br/>2. 在请求数量一定的情况下，总的耗时最少<br/>3. 耗时最少的原因是对于每个http请求都会建立一个连接，造成连接极大的浪费<br/>4. 会出现大量time_wait连接</td><td>⭐️⭐️⭐️</td></tr><tr><td><code>httpasyncclient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>nio</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr><tr><td><code>OkHttp</code></td><td>单个请求耗时0.1s</td><td>maxConnection&#x3D;1 &#x3D;&gt; <code>106s</code><br/>maxConnection&#x3D;5(default) &#x3D;&gt; <code>21s</code><br/>maxConnection&#x3D;100 &#x3D;&gt; <code>1.2s</code></td><td>1. 底层使用<code>bio</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 每条连接对应一个线程，线程数增长过快</td><td>⭐️⭐</td></tr><tr><td><code>SpringWebflux</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.4s</code></td><td>1. 底层使用<code>reactor</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr><tr><td><code>VertxWebClient</code></td><td>线程数量&#x3D;1<br/>单个请求耗时0.1s<br/>最大连接数量&#x3D;100</td><td>requestCount&#x3D;1000 &#x3D;&gt; <code>1.3s</code></td><td>1. 底层使用<code>netty</code><br/>2. 总耗时与最大连接数量成反比<br/>3. 连接数可控且可复用<br/>4. 性能与线程数量不正相关</td><td>⭐️⭐️⭐️⭐️⭐</td></tr></tbody></table><h2 id="使用-httpbin-测试"><a href="#使用-httpbin-测试" class="headerlink" title="使用 httpbin 测试"></a>使用 httpbin 测试</h2><hr><h3 id="使用-testcontainers-构建通用的测试类"><a href="#使用-testcontainers-构建通用的测试类" class="headerlink" title="使用 testcontainers 构建通用的测试类"></a>使用 testcontainers 构建通用的测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testcontainers</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMicroServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个私有的 Docker 网络，使得不同的容器可以在这个网络内相互通信。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Network</span> <span class="variable">network</span> <span class="operator">=</span> Network.newNetwork();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTPBIN</span> <span class="operator">=</span> <span class="string">&quot;httpbin&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HTTPBIN_PORT</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置一个 httpbin 容器（它提供各种 HTTP 测试端点）</span></span><br><span class="line"><span class="comment">        暴露 80 端口</span></span><br><span class="line"><span class="comment">        将容器连接到之前创建的网络</span></span><br><span class="line"><span class="comment">        给容器一个网络别名 &quot;httpbin&quot;，使其在网络内可通过该名称访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> GenericContainer&lt;?&gt; HTTPBIN_CONTAINER</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">GenericContainer</span>&lt;&gt;(<span class="string">&quot;kennethreitz/httpbin:latest&quot;</span>)</span><br><span class="line">            .withExposedPorts(HTTPBIN_PORT)</span><br><span class="line">            .withNetwork(network)</span><br><span class="line">            .withNetworkAliases(HTTPBIN);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;https://java.testcontainers.org/modules/toxiproxy/&quot;&gt;toxiproxy&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * 使用 toxiproxy 封装 httpbin</span></span><br><span class="line"><span class="comment">     * 可以使用 toxiproxy 模拟网络故障等情况</span></span><br><span class="line"><span class="comment">     * 可以用的 port 范围是 8666～8697</span></span><br><span class="line"><span class="comment">     * 也连接到同一个网络</span></span><br><span class="line"><span class="comment">     * 一个 TOXIPROXY_CONTAINER 对应多个不同 proxy，通过 TOXIPROXY_CONTAINER.getMappedPort(内部端口) 获取映射到主机的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ToxiproxyContainer</span> <span class="variable">TOXIPROXY_CONTAINER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToxiproxyContainer</span>(<span class="string">&quot;ghcr.io/shopify/toxiproxy:2.5.0&quot;</span>)</span><br><span class="line">            .withNetwork(network);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用的 httpbin 端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GOOD_HTTPBIN_PROXY_PORT</span> <span class="operator">=</span> <span class="number">8666</span>;</span><br><span class="line">    <span class="comment">// READ_TIMEOUT httpbin 端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ_TIMEOUT_HTTPBIN_PROXY_PORT</span> <span class="operator">=</span> <span class="number">8667</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESET_PEER_HTTPBIN_PROXY_PORT</span> <span class="operator">=</span> <span class="number">8668</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GOOD_HOST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> GOOD_PORT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下代表请求已经发出到服务端，但是响应超时，或者不能响应（比如服务器重启）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ_TIMEOUT_HOST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> READ_TIMEOUT_PORT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESET_PEER_HOST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> RESET_PEER_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下代表请求都没有发出去，TCP 链接都没有建立</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONNECT_TIMEOUT_HOST</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口 1 一定连不上的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT_PORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 不使用 @Container 注解管理容器声明周期，因为我们需要在静态块生成代理，必须在这之前启动容器</span></span><br><span class="line">        <span class="comment">// 不用担心容器不会被关闭，因为 testcontainers 会启动一个 ryuk 容器，用于监控并关闭所有容器</span></span><br><span class="line">        HTTPBIN_CONTAINER.start();</span><br><span class="line">        TOXIPROXY_CONTAINER.start();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ToxiproxyClient</span> <span class="variable">toxiproxyClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToxiproxyClient</span>(TOXIPROXY_CONTAINER.getHost(), TOXIPROXY_CONTAINER.getControlPort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 创建正常代理</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">            <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> toxiproxyClient.createProxy(<span class="string">&quot;good&quot;</span>, <span class="string">&quot;0.0.0.0:&quot;</span> + GOOD_HTTPBIN_PROXY_PORT, HTTPBIN + <span class="string">&quot;:&quot;</span> + HTTPBIN_PORT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 创建读取超时代理</span></span><br><span class="line">            <span class="comment">// 关闭流量，会 READ TIME OUT</span></span><br><span class="line">            proxy = toxiproxyClient.createProxy(<span class="string">&quot;read_timeout&quot;</span>, <span class="string">&quot;0.0.0.0:&quot;</span> + READ_TIMEOUT_HTTPBIN_PROXY_PORT, HTTPBIN + <span class="string">&quot;:&quot;</span> + HTTPBIN_PORT);</span><br><span class="line">            <span class="comment">// 将上下行带宽设为0，模拟读取超时</span></span><br><span class="line">            <span class="comment">// bandwidth 限制网络连接的带宽</span></span><br><span class="line">            <span class="comment">// UPSTREAM=0 客户端无法向服务端发送请求，导致写超时</span></span><br><span class="line">            <span class="comment">// DOWNSTREAM=0 服务端无法向客户端响应，导致读超时</span></span><br><span class="line">            proxy.toxics().bandwidth(<span class="string">&quot;UP_DISABLE&quot;</span>, ToxicDirection.UPSTREAM, <span class="number">0</span>);</span><br><span class="line">            proxy.toxics().bandwidth(<span class="string">&quot;DOWN_DISABLE&quot;</span>, ToxicDirection.DOWNSTREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 创建连接重置代理</span></span><br><span class="line">            <span class="comment">// todo reset peer 不生效，抓包发现没有发送 rst 包，具体原因需要再看</span></span><br><span class="line">            proxy = toxiproxyClient.createProxy(<span class="string">&quot;reset_peer&quot;</span>, <span class="string">&quot;0.0.0.0:&quot;</span> + RESET_PEER_HTTPBIN_PROXY_PORT, HTTPBIN + <span class="string">&quot;:&quot;</span> + HTTPBIN_PORT);</span><br><span class="line">            <span class="comment">// 在连接建立后立即重置连接</span></span><br><span class="line">            <span class="comment">// 上游重置 (ToxicDirection.UPSTREAM): 当客户端尝试向服务器发送数据时，连接会被重置，客户端会收到 &quot;Connection reset by peer&quot; 错误</span></span><br><span class="line">            <span class="comment">// 下游重置 (ToxicDirection.DOWNSTREAM): 当服务器尝试向客户端发送数据时，连接会被重置，服务器会收到 &quot;Connection reset by peer&quot; 错误</span></span><br><span class="line">            <span class="comment">// 延迟为1ms</span></span><br><span class="line">            proxy.toxics().resetPeer(<span class="string">&quot;UP_SLOW_CLOSE&quot;</span>, ToxicDirection.UPSTREAM, <span class="number">1</span>);</span><br><span class="line">            proxy.toxics().resetPeer(<span class="string">&quot;DOWN_SLOW_CLOSE&quot;</span>, ToxicDirection.DOWNSTREAM, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        GOOD_HOST = TOXIPROXY_CONTAINER.getHost();</span><br><span class="line">        GOOD_PORT = TOXIPROXY_CONTAINER.getMappedPort(GOOD_HTTPBIN_PROXY_PORT);</span><br><span class="line">        READ_TIMEOUT_HOST = TOXIPROXY_CONTAINER.getHost();</span><br><span class="line">        READ_TIMEOUT_PORT = TOXIPROXY_CONTAINER.getMappedPort(READ_TIMEOUT_HTTPBIN_PROXY_PORT);</span><br><span class="line">        RESET_PEER_HOST = TOXIPROXY_CONTAINER.getHost();</span><br><span class="line">        RESET_PEER_PORT = TOXIPROXY_CONTAINER.getMappedPort(RESET_PEER_HTTPBIN_PROXY_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        okHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .readTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                .writeTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                .connectTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                .retryOnConnectionFailure(<span class="literal">false</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_good</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        curl(GOOD_HOST, GOOD_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = ConnectException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_connectTimeout</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        curl(CONNECT_TIMEOUT_HOST, CONNECT_TIMEOUT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = SocketTimeoutException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_readTimeout</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        curl(READ_TIMEOUT_HOST, READ_TIMEOUT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        curl(RESET_PEER_HOST, RESET_PEER_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">curl</span><span class="params">(String goodHost, <span class="type">int</span> goodPort)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + goodHost + <span class="string">&quot;:&quot;</span> + goodPort + <span class="string">&quot;/delay/0.5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> okHttpClient</span><br><span class="line">                .newCall(request)</span><br><span class="line">                .execute()</span><br><span class="line">                .body()</span><br><span class="line">                .string();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;res =&gt; &#123;&#125;&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/taeyang0126/JavaForge/tree/main/src/main/java/com/lei/java/forge/http&quot;&gt;case&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用-WireMockServer-测试&quot;&gt;&lt;a href=&quot;#使用-WireMockServer-测试&quot; class=&quot;headerlink&quot; title=&quot;使用 WireMockServer 测试&quot;&gt;&lt;/a&gt;使用 WireMockServer 测试&lt;/h2&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="基准测试" scheme="https://taeyang0126.github.io/tags/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
    <category term="http client" scheme="https://taeyang0126.github.io/tags/http-client/"/>
    
  </entry>
  
  <entry>
    <title>JMH基准测试</title>
    <link href="https://taeyang0126.github.io/2025/03/08/java/jmh-ji-zhun-ce-shi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/08/java/jmh-ji-zhun-ce-shi/posts/undefined/</id>
    <published>2025-03-08T02:43:22.000Z</published>
    <updated>2025-03-08T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/taeyang0126/JVMForge">github代码</a></li></ul><h2 id="什么是基准测试？"><a href="#什么是基准测试？" class="headerlink" title="什么是基准测试？"></a>什么是基准测试？</h2><hr><p>基准测试是测量和评估软件性能的过程。</p><ul><li>比较不同算法的性能</li><li>分析代码优化的效果</li><li>识别性能瓶颈</li><li>验证性能假设</li></ul><h2 id="为什么需要专业的基准测试工具？"><a href="#为什么需要专业的基准测试工具？" class="headerlink" title="为什么需要专业的基准测试工具？"></a>为什么需要专业的基准测试工具？</h2><hr><p>考虑这个简单的性能测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">method();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;执行时间: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方法存在严重问题:</p><ul><li>无法处理 <code>JVM</code> 预热和 <code>JIT</code> 编译优化</li><li><code>单次</code>测量没有<code>统计意义</code></li><li>容易受到外部因素干扰</li><li>无法控制 GC 影响</li></ul><h2 id="JMH：基本设置"><a href="#JMH：基本设置" class="headerlink" title="JMH：基本设置"></a>JMH：基本设置</h2><hr><h3 id="添加-JMH-依赖"><a href="#添加-JMH-依赖" class="headerlink" title="添加 JMH 依赖"></a>添加 JMH 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="比较字符串连接的两种不同方式"><a href="#比较字符串连接的两种不同方式" class="headerlink" title="比较字符串连接的两种不同方式"></a>比较字符串连接的两种不同方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 3, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1)</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcatBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param(&#123;&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringConcatenation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(StringConcatBenchmark.class.getSimpleName())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Benchmark                                      (length)  Mode  Cnt   Score    Error  Units</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder              10  avgt    5   0.040 ±  0.001  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder             100  avgt    5   0.225 ±  0.005  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringBuilder            1000  avgt    5   3.433 ±  0.104  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation        10  avgt    5   0.085 ±  0.002  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation       100  avgt    5   1.128 ±  0.085  us/op</span></span><br><span class="line"><span class="comment">        StringConcatBenchmark.testStringConcatenation      1000  avgt    5  44.292 ±  6.484  us/op</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明:</p><ul><li>对于小字符串(长度10)，两种方法差异很小</li><li>对于中等字符串(长度100)，StringBuilder 约快9倍</li><li>对于长字符串(长度1000)，StringBuilder 约快14倍</li></ul><h2 id="JMH基本概念"><a href="#JMH基本概念" class="headerlink" title="JMH基本概念"></a>JMH基本概念</h2><hr><h3 id="如何理解-State"><a href="#如何理解-State" class="headerlink" title="如何理解 @State"></a>如何理解 <code>@State</code></h3><blockquote><p><code>@State</code> 是 JMH 中管理测试状态（即测试数据和变量）的机制。</p></blockquote><h4 id="为什么需要-State？"><a href="#为什么需要-State？" class="headerlink" title="为什么需要 @State？"></a>为什么需要 @State？</h4><ol><li>避免 <code>DCE</code> (Dead Code Elimination)：如果在测试方法内直接创建变量，JVM 可能会发现这些变量没有被”外部使用”而优化掉，导致测试结果不准确。</li><li><code>管理对象生命周期</code>: 控制对象何时创建、共享和销毁。</li><li><code>支持不同的共享级别</code>：通过 Scope 参数控制状态对象如何在线程间共享</li></ol><h4 id="State-的-Scope-选项："><a href="#State-的-Scope-选项：" class="headerlink" title="@State 的 Scope 选项："></a>@State 的 <code>Scope</code> 选项：</h4><ul><li>Scope.Thread：每个测试线程有一个独立的状态实例（默认且最常用）</li><li>Scope.Benchmark：所有线程共享同一个状态实例（用于测试并发）</li><li>Scope.Group：同一个线程组内的线程共享同一个状态实例</li></ul><h3 id="为什么需要-Fork"><a href="#为什么需要-Fork" class="headerlink" title="为什么需要 @Fork"></a>为什么需要 <code>@Fork</code></h3><blockquote><p>@Fork 指定了基准测试应该在多少个独立的 JVM 进程中运行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fork(value = 3, warmups = 1)</span></span><br></pre></td></tr></table></figure><p>这表示：</p><ul><li>运行 3 个正式的测量进程</li><li>运行 1 个预热进程（不计入最终结果）</li></ul><h4 id="为什么-Fork-很重要？"><a href="#为什么-Fork-很重要？" class="headerlink" title="为什么 Fork 很重要？"></a>为什么 Fork 很重要？</h4><ol><li>隔离性：每个新的 JVM 实例都是干净的环境，没有之前测试的干扰，如 JIT 编译历史、类加载状态、内存状态等。</li><li>避免偏差：多个独立运行可以发现潜在的异常值或不稳定因素。</li><li>克服 JVM 适应性: JVM 会根据运行情况调整优化策略，Fork 可以避免这种”学习效应”影响测试。</li><li>模拟真实环境: 实际应用通常从冷启动开始，Fork 更接近这种情况。</li><li><code>设置JVM参数</code>: <code>@Fork(value = 3, jvmArgs = &#123;&quot;-Xms2G&quot;, &quot;-Xmx2G&quot;&#125;)</code></li></ol><h4 id="推荐设置："><a href="#推荐设置：" class="headerlink" title="推荐设置："></a>推荐设置：</h4><ul><li>开发阶段可以用 @Fork(1) 快速得到反馈</li><li>最终测试应该用 @Fork(3) 或更多以获得稳定结果</li></ul><h3 id="Setup-和-TearDown-注解来管理资源和初始化操作"><a href="#Setup-和-TearDown-注解来管理资源和初始化操作" class="headerlink" title="@Setup 和 @TearDown 注解来管理资源和初始化操作"></a>@Setup 和 @TearDown 注解来管理资源和初始化操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseBenchmarkState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement statement;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setup(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在整个测试开始前执行一次</span></span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:h2:mem:test&quot;</span>);</span><br><span class="line">        statement = connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setup(Level.Iteration)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupIteration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次迭代前执行</span></span><br><span class="line">        <span class="comment">// 例如重置计数器、准备新的测试数据等</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TearDown(Level.Iteration)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDownIteration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次迭代后执行</span></span><br><span class="line">        <span class="comment">// 例如清理临时数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TearDown(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在整个测试结束后执行一次</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level.Trial</code>：整个基准测试</li><li><code>Level.Iteration</code>：每次迭代（一组测量）</li><li><code>Level.Invocation</code>：每次方法调用（谨慎使用，会影响测量）</li></ul><h2 id="理解-JMH-的执行模型和优化陷阱"><a href="#理解-JMH-的执行模型和优化陷阱" class="headerlink" title="理解 JMH 的执行模型和优化陷阱"></a>理解 JMH 的执行模型和优化陷阱</h2><hr><h3 id="JMH-的线程模型"><a href="#JMH-的线程模型" class="headerlink" title="JMH 的线程模型"></a>JMH 的线程模型</h3><blockquote><p>JMH 的线程模型是理解 @State 的关键。</p></blockquote><h4 id="JMH-如何运行基准测试"><a href="#JMH-如何运行基准测试" class="headerlink" title="JMH 如何运行基准测试"></a>JMH 如何运行基准测试</h4><ol><li><strong>线程设置</strong>：JMH 默认启动多个线程来执行你的基准测试方法</li><li><strong>提高准确性</strong>：多线程运行能够更好地利用系统资源，获得更稳定的结果</li><li><strong>线程数量</strong>：默认情况下，JMH 会使用等同于 CPU 核心数的线程数</li></ol><h4 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h4><p>当运行一个简单基准测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JMH 可能会创建 4&#x2F;8&#x2F;16 个线程（取决于 <code>CPU</code> 核心数），<code>同时运行</code>这个测试方法。</p><h4 id="State-和线程的关系"><a href="#State-和线程的关系" class="headerlink" title="@State 和线程的关系"></a>@State 和线程的关系</h4><h5 id="Scope-Thread"><a href="#Scope-Thread" class="headerlink" title="Scope.Thread"></a>Scope.Thread</h5><ul><li>每个测试线程都会获得一个<code>独立的实例</code></li><li>线程之间不共享状态</li><li>适合测试<code>无共享</code>、<code>非并发</code>的代码</li><li>例如：字符串处理、算法计算等</li></ul><h5 id="Scope-Benchmark"><a href="#Scope-Benchmark" class="headerlink" title="Scope.Benchmark"></a>Scope.Benchmark</h5><ul><li>所有测试线程<code>共享同一个实例</code></li><li>适合测试并发性能</li><li>例如：线程安全集合、锁机制、原子操作等</li></ul><h3 id="JVM-优化陷阱"><a href="#JVM-优化陷阱" class="headerlink" title="JVM 优化陷阱"></a>JVM 优化陷阱</h3><blockquote><p>JVM 可能会发现变量没有被’外部使用’而优化掉，这涉及到 JVM 的一种优化技术称为 死代码消除 (Dead Code Elimination, DCE)。这个问题尤其在微基准测试中很关键。</p></blockquote><h4 id="死代码消除怎么发生"><a href="#死代码消除怎么发生" class="headerlink" title="死代码消除怎么发生"></a>死代码消除怎么发生</h4><p>假设有这样一个简单的基准测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sum变量在方法结束后没有被使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 JVM 来说，sum 变量的计算完全没有必要！因为：</p><ol><li>变量没有返回值</li><li>变量不会影响任何外部状态</li><li>变量只活在这个方法的栈空间里</li></ol><p>因此，优化后的代码可能变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 所有代码都被优化掉了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际测量的是一个”空方法”的性能，而不是计算过程的性能！</p><h4 id="如何解决-DCE-问题"><a href="#如何解决-DCE-问题" class="headerlink" title="如何解决 DCE 问题"></a>如何解决 DCE 问题</h4><ol><li>返回计算结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;  <span class="comment">// 返回结果防止优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 <code>Blackhole</code> 消费结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> sum += i;</span><br><span class="line"> &#125;</span><br><span class="line"> bh.consume(sum);  <span class="comment">// 告诉JVM这个值被使用了</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>通过 @State 对象存储结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyState</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(MyState state)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">state.result = sum;  <span class="comment">// 修改外部状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见基准测试陷阱"><a href="#常见基准测试陷阱" class="headerlink" title="常见基准测试陷阱"></a>常见基准测试陷阱</h3><h4 id="常量折叠-Constant-Folding"><a href="#常量折叠-Constant-Folding" class="headerlink" title="常量折叠 (Constant Folding)"></a>常量折叠 (Constant Folding)</h4><blockquote><p>编译器可能在编译时计算常量表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">badConstantFolding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 编译器可能直接返回 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使用 @State 变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">goodConstantFolding</span><span class="params">(MyState state)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.a + state.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环优化-Loop-Optimizations"><a href="#循环优化-Loop-Optimizations" class="headerlink" title="循环优化 (Loop Optimizations)"></a>循环优化 (Loop Optimizations)</h4><blockquote><p>JVM 可能优化循环，甚至完全消除它们</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">badLoopBenchmark</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果没有使用，循环可能被优化掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使用 Blackhole 或返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodLoopBenchmark</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    bh.consume(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法内联-Method-Inlining"><a href="#方法内联-Method-Inlining" class="headerlink" title="方法内联 (Method Inlining)"></a>方法内联 (Method Inlining)</h4><blockquote><p>JVM 可能内联小方法，改变测量结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureMethodCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addNumbers(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：使测试目标足够复杂，或禁用特定优化</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/taeyang0126/JVMForge&quot;&gt;github代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是基准测试？&quot;&gt;&lt;a href=&quot;#什么是基准测试？&quot; class=&quot;headerlink&quot; title=&quot;什么是基准测试？&quot;&gt;&lt;/a&gt;什么是基准测试？&lt;/h2&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="JMH" scheme="https://taeyang0126.github.io/tags/JMH/"/>
    
    <category term="基准测试" scheme="https://taeyang0126.github.io/tags/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Statistics/Thread Allocation Statistics</title>
    <link href="https://taeyang0126.github.io/2025/03/04/jfr/9.jvm-yu-jfr-shi-jian-thread-allocation-statistics/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/04/jfr/9.jvm-yu-jfr-shi-jian-thread-allocation-statistics/posts/undefined/</id>
    <published>2025-03-04T14:01:52.000Z</published>
    <updated>2025-03-04T14:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ThreadAllocationStatistics</code></li><li>Label(Event Type，用于显示): Thread Allocation Statistics</li><li>Category(用于分类显示): Java Application，Statistics</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>定时事件</code>: 代表定时采集，没有线程栈信息，因为执行线程都是 <code>JFR Periodic Tasks</code> 线程，采集这个线程栈没有意义</li><li><code>JVM内部事件</code></li></ul></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>everyChunk<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>everyChunk<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>period 为 everyChunk，beginChunk，endChunk 分别是什么意思？</li><li><code>Chunk</code> 可以简单理解为本地文件满了之后换一个新的文件，每个文件就是一个 <code>Chunk</code>。可以通过 <code>-XX:FlightRecorderOptions=maxchunksize=128m</code> 设置是 <code>12M</code></li><li><code>beginChunk</code>: 在每个 Chunk 开始的时候执行</li><li><code>endChunk</code>: 在每个 Chunk 满了的时候执行</li><li>下一个 Chunk 的 beginChunk 与上一个 Chunk 的 endChunk 时间基本相同</li><li><code>everyChunk</code> 代表 beginChunk + endChunk（都会执行）</li><li><code>everyChunk</code> 利于单独拿出来 tmp 目录的一个 jfr 文件的时候，有开始和结束的值</li></ul><h3 id="采集原理"><a href="#采集原理" class="headerlink" title="采集原理"></a>采集原理</h3><ul><li>在每个 Chunk 开始和结束的时候，生成 <code>jdk.ThreadAllocationStatistics</code> 事件</li><li>即采集每个线程内部的分配对象大小统计数据 <code>_allocated_bytes</code> (这是每个线程私有的)</li></ul><h3 id="统计数据的更新时机"><a href="#统计数据的更新时机" class="headerlink" title="统计数据的更新时机"></a>统计数据的更新时机</h3><ul><li>如果启动了 <code>TLAB</code>（默认就是启用的）:<ul><li>在 TLAB 满了（其实是不足以分配对象，剩余空间小于最大浪费限制的时候），或者 GC 的时候 TLAB 回退堆的时候</li><li>将 TLAB 中占用的空间大小，加到 <code>_allocated_bytes</code></li><li>每次读取的时候，读取 <code>_allocated_bytes</code> 加上当前 TLAB 已使用空间大小</li></ul></li><li>如果没有启动 TLAB(应该不会有应用这么干)，每次分配的时候会将对象大小加到这个字段</li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li><code>Thread</code>: 统计的线程名称（这个无法统计虚拟线程的，只能统计平台线程）</li><li><code>allocated</code>: 这个线程当前累计分配了多大的对象（这个字段类似于 OpenTelemetry 中的 Gauge 类型字段，瞬时值）</li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadAllocationStatistics</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ThreadAllocationStatistics 事件，每秒采集一次</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ThreadAllocationStatistics&quot;</span>).with(<span class="string">&quot;period&quot;</span>, <span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚拟线程/平台线程</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">ofVirtual</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;test-virtual-&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        Thread.Builder.<span class="type">OfPlatform</span> <span class="variable">ofPlatform</span> <span class="operator">=</span> Thread.ofPlatform().name(<span class="string">&quot;test-platform-&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各启动5个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 分配一个随机大小的数组</span></span><br><span class="line">                    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[ThreadLocalRandom.current().nextInt(<span class="number">8</span>, <span class="number">1024</span> * <span class="number">1024</span>)];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ofVirtual.start(runnable);</span><br><span class="line">            ofPlatform.start(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束程序</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据线程进行分组 -&gt; 按照 Allocated 倒序<br><img data-src="/images/jfr/31.png" alt="img"></li><li>查看图表，在柱状图显示 allocated 总计，因为之前按照 Thread 分组，这里可以看到某个 thread 的 allocated 变化<br><img data-src="/images/jfr/32.png" alt="img"><br><img data-src="/images/jfr/33.png" alt="img"></li></ul><h3 id="其他方式查看-allocated"><a href="#其他方式查看-allocated" class="headerlink" title="其他方式查看 allocated"></a>其他方式查看 allocated</h3><ul><li>jstack -e <pid></li><li>jcmd <pid> Thread.print -e</li><li>以上两个效果一样，-e 代表输出线程额外信息，额外信息中包含 allocated&#x3D;…</li><li>代码中查看<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有活跃线程总共分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getTotalThreadAllocatedBytes();</span><br><span class="line"><span class="comment">// 获取当前调用线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getCurrentThreadAllocatedBytes();</span><br><span class="line"><span class="comment">// 获取线程ID为1的线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getThreadAllocatedBytes(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取线程ID为1、2、3的多个线程分配的内存字节数</span></span><br><span class="line">((com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean()).getThreadAllocatedBytes(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h3><ul><li>该事件默认开启，不需要进行调整</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ThreadAllocationStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Thread Allocation Statistics&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application，Statistics&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;定时事件&lt;/code&gt;: 代表定时采集，没有线程栈信息，因为执行线程都是 &lt;code&gt;JFR Periodic Tasks&lt;/code&gt; 线程，采集这个线程栈没有意义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="线程分配" scheme="https://taeyang0126.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 3.Java堆内存相关设计</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-java-dui-nei-cun-xiang-guan-she-ji/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-java-dui-nei-cun-xiang-guan-she-ji/posts/undefined/</id>
    <published>2025-03-01T09:46:30.000Z</published>
    <updated>2025-03-23T09:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析</p></blockquote><ul><li><a href="https://juejin.cn/post/7225874698906615864">Java 堆内存大小的确认</a></li><li><a href="https://juejin.cn/post/7225874698906714168">压缩对象指针相关机制</a></li><li><a href="https://juejin.cn/post/7225879698952470588">其他 Java 堆内存相关的特殊机制</a></li></ul><h3 id="通用初始化与扩展流程"><a href="#通用初始化与扩展流程" class="headerlink" title="通用初始化与扩展流程"></a>通用初始化与扩展流程</h3><hr><p>目前最新的 JVM，主要根据三个指标初始化堆以及扩展或缩小堆：</p><ul><li>最大堆大小</li><li>最小堆大小</li><li>初始堆大小</li></ul><p>不同的 GC 情况下，初始化以及扩展的流程可能在某些细节不太一样，但是，大体的思路都是：</p><ol><li>初始化阶段，<code>reserve</code> <code>最大堆</code>大小，并且 <code>commit</code> <code>初始堆</code>大小</li><li>在某些 GC 的某些阶段，根据上次 GC 的数据，动态扩展或者缩小堆大小，扩展就是 commit 更多，缩小就是 uncommit 一部分内存。但是，堆大小不会小于<code>最小堆大小</code>，也不会大于<code>最大堆大小</code></li></ol><h3 id="直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式"><a href="#直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式" class="headerlink" title="直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式"></a>直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式</h3><hr><p>这三个指标，直接对应的 JVM 参数是：</p><ul><li><strong>最大堆大小</strong>：<code>MaxHeapSize</code>，如果没有指定的话会有默认<strong>预设值</strong>用于指导 JVM 计算这些指标的大小，<code>预设值为 125MB 左右</code>（96M*13&#x2F;10）</li><li><strong>最小堆大小</strong>：<code>MinHeapSize</code>，默认为 0，0 代表让 JVM 自己计算</li><li><strong>初始堆大小</strong>：<code>InitialHeapSize</code>，默认为 0，0 代表让 JVM 自己计算</li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ScaleForWordSize(x) align_down((x) * 13 / 10, HeapWordSize)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, MaxHeapSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">96</span>*M),                \</span><br><span class="line">  <span class="string">&quot;Maximum heap size (in bytes)&quot;</span>)                                   \</span><br><span class="line">  <span class="built_in">constraint</span>(MaxHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, MinHeapSize, <span class="number">0</span>,                                     \</span><br><span class="line">  <span class="string">&quot;Minimum heap size (in bytes); zero means use ergonomics&quot;</span>)        \</span><br><span class="line">  <span class="built_in">constraint</span>(MinHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, InitialHeapSize, <span class="number">0</span>,                                 \</span><br><span class="line">  <span class="string">&quot;Initial heap size (in bytes); zero means use ergonomics&quot;</span>)        \</span><br><span class="line">  <span class="built_in">constraint</span>(InitialHeapSizeConstraintFunc,AfterErgo)               \</span><br></pre></td></tr></table></figure><p>我们可以通过类似于 <code>-XX:MaxHeapSize=1G</code> 这种启动参数对这三个指标进行设置，但是，我们经常看到的可能是 <code>Xmx</code> 以及 <code>Xms</code> 这两个参数设置这三个指标，这两个参数分别对应：</p><ul><li><code>Xmx</code>：对应 <strong>最大堆大小</strong> 等价于 <code>MaxHeapSize</code></li><li><code>Xms</code>: 相当于同时设置<strong>最小堆大小</strong> <code>MinHeapSize</code> 和<strong>初始堆大小</strong> <code>InitialHeapSize</code></li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/runtime/arguments.cpp">对应JVM源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果设置了 Xms</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-Xms&quot;</span>, &amp;tail)) &#123;</span><br><span class="line">  julong size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//解析 Xms 大小</span></span><br><span class="line">  ArgsRange errcode = <span class="built_in">parse_memory_size</span>(tail, &amp;size, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (errcode != arg_in_range) &#123;</span><br><span class="line">    <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">                <span class="string">&quot;Invalid initial heap size: %s\n&quot;</span>, option-&gt;optionString);</span><br><span class="line">    <span class="built_in">describe_range_error</span>(errcode);</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 MinHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(MinHeapSize, (<span class="type">size_t</span>)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 InitialHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(InitialHeapSize, (<span class="type">size_t</span>)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果设置了 Xmx</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-Xmx&quot;</span>, &amp;tail) || <span class="built_in">match_option</span>(option, <span class="string">&quot;-XX:MaxHeapSize=&quot;</span>, &amp;tail)) &#123;</span><br><span class="line">  julong long_max_heap_size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//解析 Xmx 大小</span></span><br><span class="line">  ArgsRange errcode = <span class="built_in">parse_memory_size</span>(tail, &amp;long_max_heap_size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (errcode != arg_in_range) &#123;</span><br><span class="line">    <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">                <span class="string">&quot;Invalid maximum heap size: %s\n&quot;</span>, option-&gt;optionString);</span><br><span class="line">    <span class="built_in">describe_range_error</span>(errcode);</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将解析的值设置到 MaxHeapSize</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">FLAG_SET_CMDLINE</span>(MaxHeapSize, (<span class="type">size_t</span>)long_max_heap_size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的"><a href="#不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的" class="headerlink" title="不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的"></a>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</h3><hr><p>JVM 会读取 <strong>JVM 可用内存</strong>：首先 JVM 需要知道自己可用多少内存，我们称为可用内存。由此引入第一个 JVM 参数，<code>MaxRAM</code>，这个参数是用来明确指定 JVM 进程可用内存大小的，如果没有指定，JVM 会自己读取系统可用内存。这个可用内存用来指导 JVM 限制最大堆内存。后面我们会看到很多 JVM 参数与这个可用内存相关。</p><p>前面我们还提到了，就算没有指定 <code>MaxHeapSize</code> 或者 <code>Xmx</code>，<code>MaxHeapSize</code> 也有自己预设的一个参考值。源码中这个预设参考值为 125MB 左右（<code>96M*13/10</code>）。但是一般最后不会以这个参考值为准，JVM 初始化的时候会有很复杂的计算计算出合适的值。比如你可以在你的电脑上执行下下面的命令，可以看到类似下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version|grep MaxHeapSize</span><br><span class="line">   size_t MaxHeapSize                              = 17179869184                               &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">   size_t SoftMaxHeapSize                          = 17179869184                            &#123;manageable&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version &quot;21.0.4&quot; 2024-07-16 LTS</span><br><span class="line">OpenJDK Runtime Environment Temurin-21.0.4+7 (build 21.0.4+7-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM Temurin-21.0.4+7 (build 21.0.4+7-LTS, mixed mode)</span><br></pre></td></tr></table></figure><p>可以看到 <code>MaxHeapSize</code> 的大小，以及它的值是通过 <code>ergonomic</code> 决定的。也就是非人工指定而是 JVM 自己算出来的。</p><p>上面提到的那个 125MB 左右的初始参考值，一般用于 JVM 计算。我们接下来就会分析这个计算流程，首先是最大堆内存 MaxHeapSize 的计算流程：<br><img data-src="/images/jvm/memory/09.png" alt="img"><br>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p><ul><li><code>MinRAMPercentage</code>：注意不要被名字迷惑，这个参数是在可用内存比较小的时候生效，即最大堆内存占用为可用内存的这个参数指定的百分比，默认为 50，即 50%</li><li><code>MaxRAMPercentage</code>：注意不要被名字迷惑，这个参数是在可用内存比较大的时候生效，即最大堆内存占用为可用内存的这个参数指定的百分比，默认为 25，即 25%</li><li><code>ErgoHeapSizeLimit</code>：通过自动计算，计算出的最大堆内存大小不超过这个参数指定的大小，默认为 0 即不限制</li><li><code>MinRAMFraction</code>: 已过期，如果配置了会转化为 <code>MinRAMPercentage</code> 换算关系是：<code>MinRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>MinRAMFraction</code>，默认是 2</li><li><code>MaxRAMFraction</code>: 已过期，如果配置了会转化为 <code>MaxRAMPercentage</code> 换算关系是：<code>MaxRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>MaxRAMFraction</code>，默认是 4</li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, MinRAMPercentage, <span class="number">50.0</span>,                             \</span><br><span class="line">  <span class="string">&quot;Minimum percentage of real memory used for maximum heap&quot;</span>         \</span><br><span class="line">  <span class="string">&quot;size on systems with small physical memory size&quot;</span>)                \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, MaxRAMPercentage, <span class="number">25.0</span>,                             \</span><br><span class="line">  <span class="string">&quot;Maximum percentage of real memory used for maximum heap size&quot;</span>)   \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, ErgoHeapSizeLimit, <span class="number">0</span>,                               \</span><br><span class="line">  <span class="string">&quot;Maximum ergonomically set heap size (in bytes); zero means use &quot;</span> \</span><br><span class="line">  <span class="string">&quot;MaxRAM * MaxRAMPercentage / 100&quot;</span>)                                \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(uintx, MinRAMFraction, <span class="number">2</span>,                                   \</span><br><span class="line">  <span class="string">&quot;Minimum fraction (1/n) of real memory used for maximum heap &quot;</span>    \</span><br><span class="line">  <span class="string">&quot;size on systems with small physical memory size. &quot;</span>               \</span><br><span class="line">  <span class="string">&quot;Deprecated, use MinRAMPercentage instead&quot;</span>)                       \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(uintx, MaxRAMFraction, <span class="number">4</span>,                                   \</span><br><span class="line">  <span class="string">&quot;Maximum fraction (1/n) of real memory used for maximum heap &quot;</span>    \</span><br><span class="line">  <span class="string">&quot;size. &quot;</span>                                                          \</span><br><span class="line">  <span class="string">&quot;Deprecated, use MaxRAMPercentage instead&quot;</span>)                       \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br></pre></td></tr></table></figure><p>然后如果我们也没有设置 <code>MinHeapSize</code> 以及 <code>InitialHeapSize</code>，也会经过下面的计算过程计算出来：</p><p><img data-src="/images/jvm/memory/10.png" alt="img"></p><p>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p><ul><li><code>NewSize</code>：初始新生代大小，预设值为 1.3MB 左右（1*13&#x2F;10）</li><li><code>OldSize</code>：老年代大小，预设值为 5.2 MB 左右（4*13&#x2F;10）</li><li><code>InitialRAMPercentage</code>：初始堆内存为可用内存的这个参数指定的百分比，默认为 1.5625，即 1.5625%</li><li><code>InitialRAMFraction</code>: 已过期，如果配置了会转化为 <code>InitialRAMPercentage</code> 换算关系是：<code>InitialRAMPercentage</code> &#x3D; 100.0 &#x2F; <code>InitialRAMFraction</code></li></ul><p><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp">对应源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, NewSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">1</span>*M),                     \</span><br><span class="line">  <span class="string">&quot;Initial new generation size (in bytes)&quot;</span>)                         \</span><br><span class="line">  <span class="built_in">constraint</span>(NewSizeConstraintFunc,AfterErgo)                       \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">size_t</span>, OldSize, <span class="built_in">ScaleForWordSize</span>(<span class="number">4</span>*M),                     \</span><br><span class="line">  <span class="string">&quot;Initial tenured generation size (in bytes)&quot;</span>)                     \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0</span>, max_uintx)                                               \</span><br><span class="line"><span class="built_in">product</span>(<span class="type">double</span>, InitialRAMPercentage, <span class="number">1.5625</span>,                       \</span><br><span class="line">  <span class="string">&quot;Percentage of real memory used for initial heap size&quot;</span>)           \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">0.0</span>, <span class="number">100.0</span>)                                                 \</span><br><span class="line"><span class="built_in">product</span>(uintx, InitialRAMFraction, <span class="number">64</span>,                              \</span><br><span class="line">  <span class="string">&quot;Fraction (1/n) of real memory used for initial heap size. &quot;</span>      \</span><br><span class="line">  <span class="string">&quot;Deprecated, use InitialRAMPercentage instead&quot;</span>)                   \</span><br><span class="line">  <span class="built_in">range</span>(<span class="number">1</span>, max_uintx)                                               \</span><br></pre></td></tr></table></figure><h3 id="压缩对象指针相关机制-UseCompressedOops"><a href="#压缩对象指针相关机制-UseCompressedOops" class="headerlink" title="压缩对象指针相关机制 - UseCompressedOops"></a>压缩对象指针相关机制 - UseCompressedOops</h3><hr><h4 id="压缩对象指针存在的意义"><a href="#压缩对象指针存在的意义" class="headerlink" title="压缩对象指针存在的意义"></a>压缩对象指针存在的意义</h4><p>现代机器大部分是 64 位的，JVM 也从 <code>9</code> 开始仅提供 64 位的虚拟机。在 JVM 中，一个对象指针，对应进程存储这个对象的虚拟内存的起始位置，也是 64 位大小：</p><p>我们知道，对于 32 位寻址，最大仅支持 4GB 内存的寻址，这在现在的 JVM 很可能不够用，可能仅仅堆大小就超过 4GB。所以目前对象指针一般是 <code>64</code> 位大小来支持大内存。但是，这相对 32 位指针寻址来说，<code>性能上却有衰减</code>。我们知道，<code>CPU 仅能处理寄存器里面的数据</code>，寄存器与内存之间，有很多层 CPU 缓存，虽然内存越来越便宜也越来越大，但是 <code>CPU 缓存并没有变大</code>，这就导致如果使用 64 位的指针寻址，相对于之前 32 位的，<code>CPU 缓存能容纳的指针个数小了一倍</code>。</p><p>Java 是面向对象的语言，JVM 中最多的操作，就是对对象的操作，比如 load 一个对象的字段，store 一个对象的字段，<code>这些都离不开访问对象指针</code>。所以 JVM 想尽可能的优化对象指针，这就引入了<code>压缩对象指针</code>，让对象指针在条件满足的情况下保持原来的 32 位。</p><p>对于 32 位的指针，假设<code>每一个 1 代表 1 字节</code>（就是每一位数指向一个字节），那么可以描述 0~2^32-1 这 2^32 字节也就是 <code>4 GB</code>（2^10&#x3D;1024&#x3D;1KB 2^20&#x3D;1024<em>1024&#x3D;1MB 2^30&#x3D;1024</em>1024*1024&#x3D;1GB） 的虚拟内存。<br><img data-src="/images/jvm/memory/11.png" alt="img"></p><p>如果我让<code>每一个 1 代表 8 字节</code>呢？也就是让<code>这块虚拟内存是 8 字节对齐</code>，也就是我在使用这块内存时候，<code>最小的分配单元就是 8 字节</code>。对于 Java 堆内存，也就是一个对象占用的空间，<code>必须是 8 字节的整数倍</code>，不足的话会填充到 8 字节的整数倍用于保证对齐。这样最多可以描述 2^32 * 8 字节也就是 32 GB 的虚拟内存。<br><img data-src="/images/jvm/memory/12.png" alt="img"></p><p>这就是<code>压缩指针</code>的原理，上面提到的相关 JVM 参数是：<code>ObjectAlignmentInBytes</code>，这个 JVM 参数表示 <code>Java 堆中的每个对象，需要按照几字节对齐</code>，也就是堆按照几字节对齐，值范围是 8 ~ 256，必须是 2 的 n 次方，因为 2 的 n 次方能简化很多运算，例如对于 2 的 n 次方取余数就可以简化成对于 2 的 n 次方减一取与运算，乘法和除法可以简化移位。</p><p>如果配置最大堆内存超过 32 GB（当 JVM 是 8 字节对齐），那么压缩指针会失效（其实不是超过 32GB，会略小于 32GB 的时候就会失效，还有其他的因素影响，下一节会讲到）。 但是，这个 32 GB 是和字节对齐大小相关的，也就是 <code>-XX:ObjectAlignmentInBytes=8</code> 配置的大小(默认为8字节，也就是 Java 默认是 8 字节对齐)。如果你配置 <code>-XX:ObjectAlignmentInBytes=16</code>，那么最大堆内存超过 64 GB 压缩指针才会失效，如果你配置 <code>-XX:ObjectAlignmentInBytes=32</code>，那么最大堆内存超过 128 GB 压缩指针才会失效.</p><h4 id="压缩对象指针与压缩类指针的关系演进"><a href="#压缩对象指针与压缩类指针的关系演进" class="headerlink" title="压缩对象指针与压缩类指针的关系演进"></a>压缩对象指针与压缩类指针的关系演进</h4><p>老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是从 <strong>Java 15 Build 23</strong> 开始， <code>UseCompressedClassPointers</code> 已经不再依赖 <code>UseCompressedOops</code> 了，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。参考 <a href="https://link.juejin.cn/?target=https://bugs.openjdk.java.net/browse/JDK-8241825">JDK ISSUE</a></p><h4 id="压缩对象指针的不同模式与寻址优化机制"><a href="#压缩对象指针的不同模式与寻址优化机制" class="headerlink" title="压缩对象指针的不同模式与寻址优化机制"></a>压缩对象指针的不同模式与寻址优化机制</h4><p>JVM 需要从虚拟内存的某一点开始申请内存，并且，需要预留出足够多的空间，给可能的一些系统调用机制使用，比如前面我们 native memory tracking 中看到的一些 malloc 内存，其实某些就在这个预留空间中分配的。<code>JVM会首先确保在操作系统提供的内存空间中分配足够的内存给Java堆</code>，在确保Java堆内存需求后，JVM才会考虑为元空间、代码缓存等分配内存。</p><p>JVM 在 <code>Reserve</code> 分配 Java 堆空间的时候，会一下子 Reserve <code>最大 Java 堆空间的大小</code>，然后在此基础上 Reserve 分配其他的存储空间。之后分配 Java 对象，在 Reserve 的 Java 堆内存空间内 <code>Commit</code> 然后<code>写入数据映射物理内存</code>分配 Java 对象。根据前面说的 Java 堆大小的伸缩策略，决定继续 Commit 占用更多物理内存还是 UnCommit 释放物理内存：<br><img data-src="/images/jvm/memory/13.png" alt="img"></p><p>Java 是一个面向对象的语言，JVM 中执行最多的就是访问这些对象，<code>在 JVM 的各种机制中，必须无时无刻考虑怎么优化访问这些对象的速度</code>，对于压缩对象指针，JVM 就考虑了很多优化。如果我们要使用压缩对象指针，那么需要将这个 64 位的地址，转换为 32 位的地址。然后在读取压缩对象指针所指向的对象信息的时候，需要将这个 32 位的地址，解析为 64 位的地址之后寻址读取。这个转换公式，如下所示：</p><ol><li><code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>压缩对象指针 = (64 位地址 - 基址) &gt;&gt; 对象对齐偏移</code></li></ol><p>基址其实就是对象地址的开始，注意，<code>这个基址不一定是 Java 堆的开始地址</code>，我们后面就会看到。对象对齐偏移与前面提到的 <code>ObjectAlignmentInBytes</code> 相关，例如 <code>ObjectAlignmentInBytes=8</code> 的情况下，对象对齐偏移就是 3 （因为 8 是 2 的 3 次方）。我们针对这个公式进行优化：</p><p>首先，我们考虑把<code>基址和对象对齐偏移</code>去掉，那么压缩对象指针可以直接作为对象地址使用。什么情况下可以这样呢？那么就是对象地址从 0 开始算，并且<code>最大堆内存 + Java 堆起始位置不大于 4GB</code>。因为这种情况下，Java 堆中对象的最大地址不会超过 4GB，那么压缩对象指针的范围可以直接表示所有 Java 堆中的对象。可以直接使用压缩对象指针作为对象实际内存地址使用。这里为啥是最大堆内存 + Java 堆起始位置不大于 4GB？因为前面的分析，我们知道进程可以申请的空间，是原生堆空间。所以，Java 堆起始位置，肯定不会从 <code>0x0000 0000 0000 0000</code> 开始。<br><img data-src="/images/jvm/memory/14.png" alt="img"></p><p>如果最大堆内存 + Java 堆起始位置大于 4GB，第一种优化就不能用了，<code>对象地址偏移就无法避免了</code>。但是如果可以保证<code>最大堆内存 + Java 堆起始位置小于 32位 * ObjectAlignmentInBytes</code>，默认 <code>ObjectAlignmentInBytes=8</code> 的情况即 32GB，我们还是可以让基址等于 0（因为最大对象内存大小也不会超过32GB，所以相当于对象可以从0开始），这样 <code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/15.png" alt="img"></p><p>但是，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果最大堆内存太大，接近 32GB，想要保证最大堆内存 + Java 堆起始位置小于 32GB，那么 Java 堆起始位置其实就快接近 0 了，这显然不行。所以在最大堆内存接近 32GB 的时候，上面第二种优化也就失效了。但是我们可以让 Java 堆从一个与 <code>32GB 地址完全不相交的地址</code>开始（因为如果地址在32GB之内，由于系统需要一些虚拟内存，所以堆占用的内存肯定就小于32GB了，如果从完全不想交的地址开始，那么整个32GB都能用作堆内存，这样就不需要使用基址相加，而是取或即可），这样加法就可以优化为取或运算，即<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/16.png" alt="img"></p><p>最后，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，那么就无法优化了，只能 <code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code><br><img data-src="/images/jvm/memory/17.png" alt="img"></p><p>总结下，上面我们说的那四种模式，对应 JVM 中的压缩对象指针的四种模式（以下叙述基于 <code>ObjectAlignmentInBytes=8</code> 的情况，即默认情况）：</p><ol><li><code>32-bit</code> 压缩指针模式：最大堆内存 + Java 堆起始位置不大于 4GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = 压缩对象指针</code></li><li><code>Zero based</code> 压缩指针模式：最大堆内存 + Java 堆起始位置不大于 32GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>Non-zero disjoint</code> 压缩指针模式：<code>最大堆内存不大于 32GB</code>，由于要保证 Java 堆起始位置不能太小，最大堆内存 + Java 堆起始位置大于 32GB，<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li><li><code>Non-zero based</code> 压缩指针模式：用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是<code>最大堆内存没有超过 32GB</code>，<code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li></ol><h3 id="为何预留第-0-页，压缩对象指针-null-判断擦除的实现"><a href="#为何预留第-0-页，压缩对象指针-null-判断擦除的实现" class="headerlink" title="为何预留第 0 页，压缩对象指针 null 判断擦除的实现"></a>为何预留第 0 页，压缩对象指针 null 判断擦除的实现</h3><hr><p>前面我们知道，JVM 中的压缩对象指针有四种模式。对于地址非从 0 开始的那两种，即 <code>Non-zero disjoint</code> 和 <code>Non-zero based</code> 这两种，堆的实际地址并不是从 <code>HeapBaseMinAddress</code> 开始，而是有一页预留下来，被称为第 0 页，这一页不映射实际内存，如果访问这一页内部的地址，会有 Segment Fault 异常。那么为什么要预留这一页呢？主要是为了 null 判断优化，实现 null 判断擦除。</p><p>要预留第 0 页，不映射内存，实际就是为了让对于基址进行访问可以触发 <code>Segment Fault</code>，JVM 会捕捉这个信号，查看触发这个信号的内存地址是否属于第一页，如果属于那么 JVM 就知道了这个是对象为 null 导致的。不过从前面看，我们其实只是为了不映射基址对应的地址，那为啥要保留一整页呢？这个是处于内存对齐与寻址访问速度的考量，里面映射物理内存都是以页为单位操作的，所以内存需要按页对齐。</p><h3 id="结合压缩对象指针与前面提到的堆内存限制的初始化的关系"><a href="#结合压缩对象指针与前面提到的堆内存限制的初始化的关系" class="headerlink" title="结合压缩对象指针与前面提到的堆内存限制的初始化的关系"></a>结合压缩对象指针与前面提到的堆内存限制的初始化的关系</h3><hr><p>前面我们说明了不手动指定三个指标的情况下，这三个指标 (MinHeapSize,MaxHeapSize,InitialHeapSize) 是如何计算的，但是没有涉及压缩对象指针。如果压缩对象指针开启，那么堆内存限制的初始化之后，会根据参数确定压缩对象指针是否开启：</p><ol><li>首先，确定 Java 堆的起始位置：<ol><li>第一步，在不同操作系统不同 CPU 环境下，<code>HeapBaseMinAddress</code> 的默认值不同，大部分环境下是 <code>2GB</code></li><li>将 <code>DefaultHeapBaseMinAddress</code> 设置为 <code>HeapBaseMinAddress</code> 的默认值，即 <code>2GB</code></li><li>如果用户在启动参数中指定了 <code>HeapBaseMinAddress</code>，如果 <code>HeapBaseMinAddress</code> 小于 <code>DefaultHeapBaseMinAddress</code>，将 <code>HeapBaseMinAddress</code> 设置为 <code>DefaultHeapBaseMinAddress</code></li></ol></li><li>计算压缩对象指针堆的最大堆大小:<ol><li>读取对象对齐大小 <code>ObjectAlignmentInBytes</code> 参数的值，默认为 8</li><li>对 <code>ObjectAlignmentInBytes</code> 取 2 的对数，记为 <code>LogMinObjAlignmentInBytes</code></li><li>将 32 位左移 <code>LogMinObjAlignmentInBytes</code> 得到 <code>OopEncodingHeapMax</code> 即不考虑预留区的最大堆大小</li><li>如果需要预留区，即 <code>Non-Zero Based Disjoint</code> 以及 <code>Non-Zero Based</code> 这两种模式下，需要刨除掉预留区即第 0 页的大小，即 <code>OopEncodingHeapMax</code> - 第 0 页的大小</li></ol></li><li>读取当前 JVM 配置的最大堆大小</li><li>如果 JVM 配置的最大堆小于压缩对象指针堆的最大堆大小，并且没有通过 JVM 启动参数明确关闭压缩对象指针，则开启压缩对象指针。否则，关闭压缩对象指针</li><li>如果压缩对象指针关闭，根据前面分析过的是否压缩类指针强依赖压缩对象指针，如果是，关闭压缩类指针</li></ol><h3 id="各种压缩指针模式的开启"><a href="#各种压缩指针模式的开启" class="headerlink" title="各种压缩指针模式的开启"></a>各种压缩指针模式的开启</h3><hr><h4 id="32-bit-压缩指针模式"><a href="#32-bit-压缩指针模式" class="headerlink" title="32-bit 压缩指针模式"></a>32-bit 压缩指针模式</h4><blockquote><p>最大堆内存 + Java 堆起始位置不大于 4GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = 压缩对象指针</code></p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li><code>maxHeapSize</code> &lt; <code>4GB</code> - <code>HeapBaseMinAddress</code> </li><li>eg: -Xmx32M</li><li><code>Java 堆会从界限减去最大堆大小的位置开始 reserve</code>，也就是在 <code>-Xmx32M</code> 下，堆的起始位置是 <code>0x0000 0000 fe00 0000</code> （0x0000 0000 fe00 0000 + 32M &#x3D; 4GB）</li></ol><h4 id="Zero-based-压缩指针模式"><a href="#Zero-based-压缩指针模式" class="headerlink" title="Zero based 压缩指针模式"></a>Zero based 压缩指针模式</h4><blockquote><p>最大堆内存 + Java 堆起始位置不大于 32GB（并且 Java 堆起始位置不能太小），64 位地址 &#x3D; （压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li><code>maxHeapSize</code> &gt; <code>4GB</code> - <code>HeapBaseMinAddress</code> </li><li><code>maxHeapSize</code> &lt; <code>32GB</code> - <code>HeapBaseMinAddress</code> </li><li>eg: -Xmx2050M</li></ol><h4 id="Non-zero-disjoint-压缩指针模式"><a href="#Non-zero-disjoint-压缩指针模式" class="headerlink" title="Non-zero disjoint 压缩指针模式"></a>Non-zero disjoint 压缩指针模式</h4><blockquote><p>最大堆内存不大于 32GB，由于要保证 Java 堆起始位置不能太小，最大堆内存 + Java 堆起始位置大于 32GB，64 位地址 &#x3D; 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li>java 堆起始位置与32GB完全不相交的地址(0x0000001000000000(64GB))，32GB地址&#x3D;0x0000000800000000</li><li>-Xmx31G</li></ol><h4 id="Non-zero-based-压缩指针模式"><a href="#Non-zero-based-压缩指针模式" class="headerlink" title="Non-zero based 压缩指针模式"></a>Non-zero based 压缩指针模式</h4><blockquote><p>用户通过 HeapBaseMinAddress 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，64 位地址 &#x3D; 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</p></blockquote><p>从上一节能看出来，<code>HeapBaseMinAddress</code> 在不设置时默认是 <code>2GB</code>（大部分环境下）:</p><ol><li>自己指定了 Java 堆开始的地址，并且与 32GB 地址相交 <code>-XX:HeapBaseMinAddress=2G</code></li><li>最大堆内存 + Java 堆起始位置大于 32GB <code>-Xmx31G</code></li></ol><h3 id="各模式选择条件总结"><a href="#各模式选择条件总结" class="headerlink" title="各模式选择条件总结"></a>各模式选择条件总结</h3><hr><table><thead><tr><th>模式</th><th>堆基址条件</th><th>最大堆限制</th><th>选择逻辑</th></tr></thead><tbody><tr><td>32-bit</td><td>堆空间完全在4GB范围内</td><td>&lt; 4GB - HeapBaseMinAddress</td><td>适用于堆需求较小的应用</td></tr><tr><td>Zero-based</td><td>任意堆基址</td><td>HeapBaseMinAddress + Xmx &gt; 4GB 且 &lt; 32GB</td><td>当堆总大小超过4GB但小于32GB时使用</td></tr><tr><td>Non-zero based</td><td>~2GB</td><td>&lt;32GB</td><td>平衡系统内存布局需求的通用模式</td></tr><tr><td>Non-zero disjoint</td><td><code>&gt;=32GB</code> (如64GB)</td><td>&lt;32GB</td><td>适用于特定的内存布局需求</td></tr></tbody></table><h3 id="堆大小的动态伸缩"><a href="#堆大小的动态伸缩" class="headerlink" title="堆大小的动态伸缩"></a>堆大小的动态伸缩</h3><hr><ul><li><code>MinHeapFreeRatio</code>: 目标最小堆空闲比例，如果某次 GC 之后堆的某个区域（在某些 GC 是整个堆）空闲比例小于这个比例，那么就考虑将这个区域扩容。默认是 40，即默认是 <code>40%</code>，但是某些 GC 如果你不设置就会变成 0%。0% 代表从来不会因为没有达到目标最小堆空闲比例而扩容，配置为 0% 一般是为了堆的大小稳定。</li><li><code>MaxHeapFreeRatio</code>: 目标最大堆空闲比例，如果某次 GC 之后堆的某个区域（在某些 GC 是整个堆）空闲比例大于这个比例，那么就考虑将这个区域缩小。默认是 70，即默认是 <code>70%</code>，但是某些 GC 如果你不设置就会变成 100%。100% 代表从来不会因为没有达到目标最大堆空闲比例而扩容，配置为 100% 一般是为了堆的大小稳定。</li><li><code>MinHeapDeltaBytes</code>: 当扩容时，至少扩展多大的内存。默认是 <code>166.4 KB</code>（128*13&#x2F;10）</li></ul><h4 id="上诉几个参数在不同-GC-下的表现"><a href="#上诉几个参数在不同-GC-下的表现" class="headerlink" title="上诉几个参数在不同 GC 下的表现"></a>上诉几个参数在不同 GC 下的表现</h4><ul><li><code>SerialGC</code>: 在 SerialGC 的情况下，<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code> 指的仅仅是老年代的目标空闲比例，<code>仅对老年代生效</code>。在触发涉及老年代的 GC 的时候（其实就是 FullGC），GC 结束时，会查看当前老年代的空闲比例，与 MinHeapFreeRatio 和 MaxHeapFreeRatio比较 判断是否扩容或者缩小老年代的大小</li><li><code>ParallelGC</code>: 在 ParallelGC 的情况下，<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code> 指的是<code>整个堆</code>的大小。并且，如果这两个 JVM 参数没有明确指定的话，那么 MinHeapFreeRatio 就是 0，MaxHeapFreeRatio 就是 100（相当于不会根据这两个参数调整堆大小。并且，如果 <code>UseAdaptiveSizePolicy</code> 是 false 的话，这两个参数也不会生效。</li><li><code>ShenandoahGC</code>: 这三个参数不生效</li><li><code>ZGC</code>: 这三个参数不生效</li></ul><h3 id="适用于长期运行并且尽量将所有可用内存被堆使用的-JVM-参数-AggressiveHeap"><a href="#适用于长期运行并且尽量将所有可用内存被堆使用的-JVM-参数-AggressiveHeap" class="headerlink" title="适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap"></a>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 <code>AggressiveHeap</code></h3><hr><p><code>AggressiveHeap</code> 是一种激进地让 JVM 使用当前系统的<code>剩余内存</code>的一种配置，开启会根据系统可用内存，自动设置堆大小等内存参数，将内存的一半分配给堆，另一半留给堆外其他的子系统占用内存，通过强制使用 ParallelGC 这种不会占用太多堆外内存的 GC 算法这种类似的思路限制堆外内存的使用（只能使用这个 GC，你指定其他 GC 的话会启动报错 Error occurred during initialization of VM. Multiple garbage collectors selected）。默认为 false 即不开启，可以通过 -XX:+AggressiveHeap 开启。开启这个参数会强制设置以下参数：</p><p><code>目标堆大小 = Math.min(系统可用内存/2, 系统可用内存 - 160MB)</code></p><ul><li>MaxHeapSize 最大堆内存为目标堆大小</li><li>InitialHeapSize 初始堆内存为目标堆大小</li><li>NewSize 和 MaxNewSize 新生代为目标堆大小 * 八分之三</li><li>BaseFootPrintEstimate 堆外内存占用大小预估为目标堆大小，用于指导一些堆外内存结构的初始化</li><li>UseLargePages 为开启，使用大页内存分配，增加实际物理内存的连续性</li><li>TLABSize 为 256K，即初始 TLAB 大小为 256 K，但是下面我们设置了 ResizeTLAB 为 false，所以 TLAB 就会保持为 256K</li><li>ResizeTLAB 为 false，也就是 TLAB 大小不再随着 GC 以及分配特征的改变而改变，减少没必要的计算，反正进程要长期存在了，就在初始就指定一个比较大的 TLAB 的值。</li><li>UseParallelGC 为 true，强制使用 ParallelGC</li><li>ThresholdTolerance 为最大值 100，ThresholdTolerance 用于动态控制对象晋升到老年代需要存活过的 GC 次数，如果 1 + ThresholdTolerance&#x2F;100 * MinorGC 时间大于 MajorGC 的时间，我们就认为 MinorGC 占比过大，需要将更多对象晋升到老年代。反之，如果 1 + ThresholdTolerance&#x2F;100 * MajorGC 时间大于 MinorGC 的时间，就认为 MajorGC 时间占比过多，需要将更少的对象晋升到老年代。调整成 100 可以实现这个晋升界限基本不变保持稳定。</li><li>ScavengeBeforeFullGC 设置为 false，在 FullGC 之前，先尝试执行一次 YoungGC。因为长期运行的应用，会经常 YoungGC 并晋升对象，需要 FullGC 的时候一般 YoungGC 无法回收那么多内存避免 FullGC，关闭它更有利于避免无效扫描弄脏 CPU 缓存。</li></ul><h3 id="JVM-参数-AlwaysPreTouch-的作用"><a href="#JVM-参数-AlwaysPreTouch-的作用" class="headerlink" title="JVM 参数 AlwaysPreTouch 的作用"></a>JVM 参数 <code>AlwaysPreTouch</code> 的作用</h3><hr><p>JVM 申请内存的流程，内存并不是在 <code>JVM commit</code> 一块内存之后就立刻被操作系统分配实际的物理内存的，只有真正往里面写数据的时候，才会关联实际的物理内存。所以对于 JVM 堆内存，我们也可以推测出，堆内存随着对象的分配才会关联实际的物理内存。那我们有没有办法<code>提前强制</code>让 committed 的内存关联实际的物理内存呢？很简单，往这些 committed 的内存中写入假数据就行了（一般是填充 0）。</p><p>对于不同的 GC，由于不同 GC 对于堆内存的设计不同，所以对于 AlwaysPreTouch 的处理也略有不同，在以后的系列我们详细解析每一种 GC 的时候，会详细分析每种 GC 的堆内存设计，这里我们就简单列举通用的 AlwaysPreTouch 处理。AlwaysPreTouch 打开后，所有新 commit 的堆内存，都会往里面填充 0，相当于写入空数据让 commit 的内存真正被分配。</p><h3 id="JVM-参数-UseContainerSupport-JVM-如何感知到容器内存限制"><a href="#JVM-参数-UseContainerSupport-JVM-如何感知到容器内存限制" class="headerlink" title="JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制"></a>JVM 参数 <code>UseContainerSupport</code> - JVM 如何感知到容器内存限制</h3><hr><p>让 JVM 感知容器环境的相关 JVM 参数是 <code>UseContainerSupport</code>，默认值为 true，这个配置默认开启，在开启的情况下，JVM 会通过下面的流程读取内存限制：<br><img data-src="/../../../images/jvm/memory/18.png" alt="img.png"></p><h3 id="SoftMaxHeapSize-用于平滑迁移更耗内存的-GC-使用"><a href="#SoftMaxHeapSize-用于平滑迁移更耗内存的-GC-使用" class="headerlink" title="SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用"></a><code>SoftMaxHeapSize</code> - 用于平滑迁移更耗内存的 GC 使用</h3><hr><p>由于那种完并发的 GC（目标是完全无 Stop the world 暂停或者是亚毫秒暂停的 GC），例如 ZGC ，需要在堆外使用比 G1GC 以及 ParallelGC 多的多的空间（指的就是我们后面会分析到的 Native Memory Tracking 的 GC 部分占用的内存），并且由于 ZGC 这种目前是未分代的（Java 20 之后会引入分代 ZGC），导致 GC 在堆外占用的内存会更多。所以我们一般认为，在从 G1GC，或者 ParallelGC 切换到 ZGC  的时候，就算最大堆大小等各种 JVM 参数不变，JVM 也会需要更多的物理内存。但是，在实际的生产中，修改 JVM GC 是比较简单的，修改下启动参数就行了，但是给 JVM 加内存是比较困难的，因为是实际要消耗的资源。如果不修改 JVM 内存限制参数，也不加可用内存，线上可能会在换 GC 后经常出现被 OOMkiller 干掉的情况。</p><p>为了能让大家更平滑的切换 GC，以及对于线上应用，我们可能实际不一定需要用原来配置的堆大小的空间，JVM 针对 ShenandoahGC 以及 ZGC 引入了 <code>SoftMaxHeapSize</code> 这个参数（目前这个参数只对于这种专注于避免全局暂停的 GC 生效）。这个参数虽然默认是 0，但是如果没有指定的话，会自动设置为前文提到的 MaxHeapSize 大小。</p><p>ZGC 与 ShenandoahGC 的堆设计，都有软最大大小限制的概念。这个软最大大小是随着时间与 GC 表现（例如分配速率，空闲率等）不断变化的，这两个 GC 会在堆扩展到软最大大小之后，尽量就不扩展堆大小，尽量通过激进的 GC 回收空间。只有在暂停世界都完全无法回收足够内存用以分配的时候，才会尝试扩展，这之后最大限制就到了 MaxHeapSize。SoftMaxHeapSize 会给这个软最大大小一个指导值，让软最大大小不要超过这个值。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225874698906615864&quot;&gt;Java 堆内存大小的确认&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225874698906714168&quot;&gt;压缩对象指针相关机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225879698952470588&quot;&gt;其他 Java 堆内存相关的特殊机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;通用初始化与扩展流程&quot;&gt;&lt;a href=&quot;#通用初始化与扩展流程&quot; class=&quot;headerlink&quot; title=&quot;通用初始化与扩展流程&quot;&gt;&lt;/a&gt;通用初始化与扩展流程&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="堆内存" scheme="https://taeyang0126.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 2.JVM 内存申请与使用流程</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-jvm-nei-cun-shen-qing-yu-shi-yong/posts/undefined/</id>
    <published>2025-03-01T07:46:30.000Z</published>
    <updated>2025-03-01T07:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</p></blockquote><ul><li><a href="https://juejin.cn/post/7225875600644407357">JVM 内存申请与使用流程</a></li></ul><h2 id="Linux-下内存管理模型简述"><a href="#Linux-下内存管理模型简述" class="headerlink" title="Linux 下内存管理模型简述"></a>Linux 下内存管理模型简述</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21&key=d9f8952995f1859ec52d8f5d9e6ab4720ffabd5403c103322ee7ec6f45279c0d6ff004df4d91e603b8da30fc862da32560064a1680e06e498f1478dedf8d24cd54abfe5bbf80610ac6a1ecfcadeceb1ce74fd27e061bc962a5e9d18c369786619a9ac7ad030b16a0f350638aed32ec61ad2c47b2df53b2fffac6419c8a55feb1&ascene=2&uin=MTQxMDM0OTkyNA==&devicetype=Windows+11+x64&version=6308011a&exportkey=n_ChQIAhIQLReSAiPPBq/rjeEsvhWLGhLpAQIE97dBBAEAAAAAAPboBnzhWE0AAAAOpnltbLcz9gKNyK89dVj0LB8MByB+LnarvTJ9k5LjHnaHSiRCVUH6zSSXMnbZ9AQCusp6IDK5hwtnugd9Du4BG2pqPuJHPIkVIcUMia320lXFN61yM/+2MKyl86soaJUlu0zu8x69eop1Fbdi4YBaoocZrDbr+Buq4hsy+Kf6ElIQw+6gPfQqllJ5R86pa0DoVOjdnD2bi7ZuxdMyvcOPEu3pDa5H/BgY1A+DcifqtVZlp+5LoJKYNhtlZg1zOS06RY15Ry0DdonN38efMsG2Req/&acctmode=0&pass_ticket=ywhUvrTZ0ZCaWLuvLdidNGnNwyS7T41V+KEL2N0td3RvwmPJ+ZREM3Zc0lit4wDxNhALtKqF2gPCKD6sLdagzA==&wx_header=1&fontgear=2">bin神系列文章深入理解linux内存</a></li></ul><p>CPU 是通过寻址来访问内存的，目前大部分 CPU 都是 64 位的，即寻址范围是：<code>0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF</code>，即可以管理 16EB 的内存。但是，实际程序并不会直接通过 CPU 寻址访问到实际的物理内存，而是通过引入 <code>MMU</code>（Memory Management Unit 内存管理单元）与实际物理地址隔了一层虚拟内存的抽象。这样，程序申请以及访问的其实是<code>虚拟内存地址</code>，MMU 会将这个虚拟内存地址<code>映射</code>为实际的物理内存地址。同时，<code>为了减少内存碎片，以及增加内存分配效率</code>，在 MMU 的基础上 Linux 抽象了<code>内存分页（Paging）</code>的概念，将虚拟地址按固定大小分割成<code>页</code>（默认是 4K，如果平台支持更多更大的页大小 JVM 也是可以利用的，我们后面分析相关的 JVM 参数会看到），并在页被实际使用写入数据的时候，<code>映射同样大小的实际的物理内存</code>（页帧，Page Frame），或者是在物理内存不足的时候，将某些不常用的页<code>转移到其他存储设备比如磁盘上</code>。</p><p>一般系统中会有多个进程使用内存，每个进程都有自己独立的虚拟内存空间，假设我们这里有三个进程，进程 A 访问的虚拟地址可以与进程 B 和进程 C 的虚拟地址相同，那么操作系统如何区分呢？即操作系统如何将这些虚拟地址转换为物理内存。这就需要页表了，页表也是每个进程独立的，操作系统会在给进程映射物理内存用来保存用户数据的时候，将物理内存保存到进程的页表里面。然后，进程访问虚拟内存空间的时候，通过页表找到物理内存：<br><img data-src="/images/jvm/memory/01.png" alt="img"></p><p>页表如何将一个虚拟内存地址（我们需要注意一点，目前虚拟内存地址，用户空间与内核空间可以使用从 <code>0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF</code> 的地址，即 256TB），转化为物理内存的呢？下面我们举一个在 x86，64 位环境下四级页表的结构视图：<br><img data-src="/images/jvm/memory/02.png" alt="img"></p><p>在这里，页表分为四个级别：PGD（Page Global Directory），PUD（Page Upper Directory），PMD（Page Middle Directory），PTE（Page Table Entry）。每个页表，里面的页表项，保存了指向下一个级别的页表的引用，除了最后一层的 PTE 里面的页表项保存的是指向用户数据内存的指针。如何将虚拟内存地址通过页表找到对应用户数据内存从而读取数据，过程是：<br><img data-src="/images/jvm/memory/03.png" alt="img"></p><ol><li>取虚拟地址的 <code>39 ~ 47</code> 位（因为用户空间与内核空间可以使用从 0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF 的地址，即 47 位以下的地址）作为 offset，在<code>唯一</code>的 PGD 页面根据 offset 定位到 PGD 页表项 <code>pgd_t</code></li><li>使用 <code>pgd_t</code> 定位到具体的 PUD 页面</li><li>取虚拟地址的 <code>30 ~ 38</code> 位作为 offset，在对应的 PUD 页面根据 offset 定位到 PUD 页表项 <code>pud_t</code></li><li>使用 <code>pud_t</code> 定位到具体的 PMD 页面</li><li>取虚拟地址的 <code>21 ~ 29</code> 位作为 offset，在对应的 PMD 页面根据 offset 定位到 PMD 页表项 <code>pmd_t</code></li><li>使用 <code>pmd_t</code> 定位到具体的 PTE 页面</li><li>取虚拟地址的 <code>12 ~ 20</code> 位作为 offset，在对应的 PTE 页面根据 offset 定位到 PTE 页表项 <code>pte_t</code></li><li>使用 <code>pte_t</code> 定位到具体的用户数据物理内存页面</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset</li></ol><p>如果每次访问虚拟内存，都需要访问这个页表翻译成实际物理内存的话，性能太差。所以一般 CPU 里面都有一个 <code>TLB</code>（Translation Lookaside Buffer，翻译后备缓冲）存在，一般它属于 CPU 的 MMU 的一部分。<code>TLB 负责缓存虚拟内存与实际物理内存的映射关系</code>，一般 TLB 容量很小。每次访问虚拟内存，先查看 TLB 中是否有缓存，如果没有才会去页表查询。<br><img data-src="/images/jvm/memory/04.png" alt="img"><br>默认情况下，TLB 缓存的 key 为地址的 <code>12 ~ 47</code> 位，value 是实际的物理内存页面。这样前面从<code>第 1 到第 7 步</code>就可以被替换成访问 TLB 了：</p><ol><li>取虚拟地址的 <code>12 ~ 47</code> 位作为 key，访问 TLB，定位到具体的用户数据物理内存页面。</li><li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset。<br><img data-src="/images/jvm/memory/05.png" alt="img"></li></ol><p>TLB 整体可以容纳个数不多；页大小越大，TLB 能容纳的个数越少。但是整体看，TLB 能容纳的页大小还是增多的（比如 Nehalem 的 iTLB，页大小 4K 的时候，一共可以容纳 128 * 4 &#x3D; 512K 的内存，页大小 2M 的时候，一共可以容纳 2 * 7 &#x3D; 14M 的内存）</p><p>JVM 中很多地方需要知道页大小，JVM 在初始化的时候，通过系统调用 <code>sysconf(_SC_PAGESIZE)</code> 读取出页大小，并保存下来以供后续使用。参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp">https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置全局默认页大小，通过 Linux::page_size() 可以获取全局默认页大小</span></span><br><span class="line">Linux::<span class="built_in">set_page_size</span>(<span class="built_in">sysconf</span>(_SC_PAGESIZE));</span><br><span class="line"><span class="keyword">if</span> (Linux::<span class="built_in">page_size</span>() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;</span>,</span><br><span class="line">      os::<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将默认页大小加入可选的页大小列表，在涉及大页分配的时候有用</span></span><br><span class="line">_page_sizes.<span class="built_in">add</span>(Linux::<span class="built_in">page_size</span>());</span><br></pre></td></tr></table></figure><h2 id="JVM-主要内存申请分配流程"><a href="#JVM-主要内存申请分配流程" class="headerlink" title="JVM 主要内存申请分配流程"></a>JVM 主要内存申请分配流程</h2><h3 id="每个子系统-Reserve-内存"><a href="#每个子系统-Reserve-内存" class="headerlink" title="每个子系统 Reserve 内存"></a>每个子系统 <code>Reserve</code> 内存</h3><p><strong>第一步，JVM 的每个子系统</strong>（例如 Java 堆，元空间，JIT 代码缓存，GC 等等等等），<strong>如果需要的话，在初始化的时候首先 <code>Reserve</code> 要分配区域的最大限制大小的内存</strong>（这个最大大小，需要按照<code>页大小对齐</code>（即是页大小的整数倍），默认页大小是前面提到的 <code>Linux::page_size()</code>），例如对于 Java 堆，就是最大堆大小（通过 <code>-Xmx</code> 或者 <code>-XX:MaxHeapSize</code>限制），还有对于代码缓存，也是最大代码缓存大小（通过 <code>-XX:ReservedCodeCacheSize</code> 限制）。Reserve 的目的是在虚拟内存空间划出一块内存专门给某个区域使用，这样做的好处是：</p><ol><li>隔离每个 JVM 子系统使用的内存的<code>虚拟空间</code>，这样在 JVM 代码有 bug 的时候（例如发生 Segment Fault 异常），通过报错中的<code>虚拟内存地址</code>可以快速定位到是哪个子系统出了问题。</li><li>可以很方便的限制这个区域使用的最大内存大小。</li><li>便于管理，<code>Reserve 不会触发操作系统分配映射实际物理内存</code>，这个区域可以在 Reserve 的区域内按需伸缩。</li><li>便于一些 JIT 优化，例如我们故意将这个区域保留起来但是故意不将这个区域的虚拟内存映射物理内存，访问这块内存会造成 Segment Fault 异常。JVM 会预设 Segment Fault 异常的处理器，在处理器里面检查发生 Segment Fault 异常的内存地址属于哪个子系统的 Reserve 的区域，判断要做什么操作。后面我们会看到，null 检查抛出 <code>NullPointerException</code> 异常的优化，全局安全点，抛出 <code>StackOverflowError</code> 的实现，都和这个机制有关。</li></ol><p>在 Linux 的环境下，Reserve 通过  <code>mmap(2)</code> 系统调用实现，参数传入 <code>prot = PROT_NONE</code>，<code>PROT_NONE</code> 代表不会使用，即<code>不能做任何操作，包括读和写</code>。如果 JVM 使用这块内存，会发生 Segment Fault 异常。</p><h3 id="每个子系统按照各自策略向操作系统申请映射物理内存"><a href="#每个子系统按照各自策略向操作系统申请映射物理内存" class="headerlink" title="每个子系统按照各自策略向操作系统申请映射物理内存"></a>每个子系统按照各自策略向操作系统申请映射物理内存</h3><p><strong>第二步，JVM 的每个子系统，按照各自的策略，通过 <code>Commit</code> 第一步 Reserve 的区域的<code>一部分扩展内存</code>（大小也一般页大小对齐的），从而<code>向操作系统申请映射物理内存</code>，通过 <code>Uncommit</code> 已经 Commit 的内存来释放物理内存给操作系统</strong></p><p>Commit 内存之后，<code>并不是操作系统会立刻分配物理内存</code>，而是在向 <code>Commit 的内存里面写入数据的时候，操作系统才会实际映射内存</code>，JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数。</p><h3 id="JVM-commit-的内存与实际占用内存的差异"><a href="#JVM-commit-的内存与实际占用内存的差异" class="headerlink" title="JVM commit 的内存与实际占用内存的差异"></a>JVM commit 的内存与实际占用内存的差异</h3><p>前面一节我们知道了，JVM 中大块内存，基本都是先 <code>reserve</code> 一大块，之后 <code>commit</code> 其中需要的一小块，然后开始读写处理内存，在 Linux 环境下，底层基于 <code>mmap(2)</code> 实现。但是需要注意一点的是，commit 之后，内存并不是立刻被分配了物理内存，而是真正往内存中 <code>store</code> 东西的时候，才会真正映射物理内存，如果是 load 读取也是可能不映射物理内存的。</p><p>这其实是可能你平常看到但是忽略的现象，如果你使用的是 SerialGC，ParallelGC 或者 CMS GC，老年代的内存在有对象晋升到老年代之前，可能是不会映射物理内存的，虽然这块内存已经被 commit 了。并且年轻代可能也是随着使用才会映射物理内存。如果你用的是 ZGC，G1GC，或者 ShenandoahGC，那么内存用的会更激进些（主要因为分区算法划分导致内存被写入），<code>这是你在换 GC 之后看到物理内存内存快速上涨的原因之一</code>。JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数，这个参数我们后面会详细分析以及历史版本存在的缺陷。还有的差异，主要来源于在 uncommit 之后，系统可能还没有来的及将这块物理内存真正回收。</p><p>所以，JVM 认为自己 commit 的内存，与实际系统分配的物理内存，<code>可能是有差异的</code>，可能 JVM 认为自己 commit 的内存比系统分配的物理内存多，也可能少。这就是为啥 <code>Native Memory Tracking（JVM 认为自己 commit 的内存）与实际其他系统监控中体现的物理内存使用指标对不上的原因</code>。</p><h2 id="大页分配-UseLargePages"><a href="#大页分配-UseLargePages" class="headerlink" title="大页分配 UseLargePages"></a>大页分配 UseLargePages</h2><p>前面提到了虚拟内存需要映射物理内存才能使用，这个映射关系被保存在内存中的<code>页表（Page Table）</code>。现代 CPU 架构中一般有 <code>TLB</code> （Translation Lookaside Buffer，翻译后备缓冲，也称为页表寄存器缓冲）存在，在里面保存了经常使用的页表映射项。TLB 的大小有限，一般 TLB 如果只能容纳小于 100 个页表映射项。 我们能让程序的虚拟内存对应的页表映射项都处于 TLB 中，那么能大大提升程序性能，这就要尽量减少页表映射项的个数：<code>页表项个数 = 程序所需内存大小 / 页大小</code>。我们要么缩小程序所需内存，要么增大页大小。我们一般会考虑<code>增加页大小</code>，这就大页分配的由来，JVM 对于堆内存分配也支持大页分配，用于优化大堆内存的分配。那么 Linux 环境中有哪些大页分配的方式呢？</p><h3 id="Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs"><a href="#Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs" class="headerlink" title="Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)"></a>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">相关的 Linux 内核文档</a></p><p>这是出现的比较早的大页分配方式，其实就是在之前提到的页表映射上面做文章：</p><p><strong>默认 4K 页大小</strong>：<br><img data-src="/images/jvm/memory/03.png" alt="img"></p><p><strong>PMD 直接映射实际物理页面，页面大小为 <code>4K * 2^9 = 2M</code></strong>：<br><img data-src="/images/jvm/memory/06.png" alt="img"></p><p><strong>PUD 直接映射实际物理页面，页面大小为 <code>2M * 2^9 = 1G</code></strong>：<br><img data-src="/images/jvm/memory/07.png" alt="img"></p><p>但是，要想使用这个特性，需要操作系统构建的时候开启 <code>CONFIG_HUGETLBFS</code> 以及 <code>CONFIG_HUGETLB_PAGE</code>。之后，大的页面通常是通过系统管理控制预先分配并放入池里面的。然后，可以通过 <code>mmap</code> 系统调用或者 <code>shmget,shmat</code> 这些 SysV 的共享内存系统调用使用大页分配方式从池中申请内存。</p><p>这种大页分配的方式，需要系统预设开启大页，预分配大页之外，对于代码也是有一定侵入性的，在灵活性上面查一些。但是带来的好处就是，性能表现上更加可控。另一种灵活性很强的 Transparent Huge Pages (THP) 方式，总是可能在性能表现上有一些意想不到的情况。</p><h3 id="Linux-大页分配方式-Transparent-Huge-Pages-THP"><a href="#Linux-大页分配方式-Transparent-Huge-Pages-THP" class="headerlink" title="Linux 大页分配方式 - Transparent Huge Pages (THP)"></a>Linux 大页分配方式 - Transparent Huge Pages (THP)</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">相关的 Linux 内核文档</a></p><p>THP 是一种使用大页的第二种方法，它支持页面大小的自动升级和降级，这样对于用户使用代码基本没有侵入性，非常灵活。但是，前面也提到过，这种系统自己去做页面大小的升级降级，并且系统一般考虑通用性，所以在某些情况下会出现意想不到的性能瓶颈。</p><h3 id="JVM-大页分配相关参数与机制"><a href="#JVM-大页分配相关参数与机制" class="headerlink" title="JVM 大页分配相关参数与机制"></a>JVM 大页分配相关参数与机制</h3><p>相关的参数如下：</p><ul><li><code>UseLargePages</code>：明确指定是否开启大页分配，如果关闭，那么下面的参数就都不生效。<code>在 linux 下默认为 false</code>。</li><li><code>UseHugeTLBFS</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>mmap</code> 系统调用分配内存。在 linux 下默认为 false。</li><li><code>UseSHM</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>shmget,shmat</code> 系统调用分配内存。在 linux 下默认为 false。</li><li><code>UseTransparentHugePages</code>：明确指定是否使用前面第二种大页分配方式 THP。在 linux 下默认为 false。</li><li><code>LargePageSizeInBytes</code>：指定明确的大页的大小，仅适用于前面第一种大页分配方式 hugetlbfs，并且必须属于操作系统支持的页大小否则不生效。默认为 0，即不指定</li></ul><p>首先，需要对以上参数做一个简单的判断：如果没有指定 <code>UseLargePages</code>，那么使用对应系统的默认 <code>UseLargePages</code> 的值，在 linux 下是 false，那么就不会启用大页分配。如果启动参数明确指定 <code>UseLargePages</code> 不启用，那么也不会启用大页分配。如果读取 <code>/proc/meminfo</code> 获取默认大页大小读取不到或者为 0，则代表系统也不支大页分配，大页分配也不启用。</p><p>那么如果大页分配启用的话，我们需要初始化并验证大页分配参数可行性，流程是：<br><img data-src="/images/jvm/memory/08.png" alt="img"></p><p>首先，JVM 会读取根据当前所处的平台与系统环境读取支持的页的大小，当然，这个是针对前面第一种大页分配方式 <code>hugetlbfs</code> 的。在 Linux 环境下，JVM 会从 <code>/proc/meminfo</code> 读取默认的 <strong><code>Hugepagesize</code></strong>，从 <code>/sys/kernel/mm/hugepages</code> 目录下检索<strong>所有支持的大页大小</strong>，这块可以参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp%E3%80%82">https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp。</a><br>有关这些文件或者目录的详细信息，请参考前面章节提到的 Linux 内核文档：<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p><p>如果操作系统开启了 hugetlbfs，<code>/sys/kernel/mm/hugepages</code> 目录下的结构类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tree /sys/kernel/mm/hugepages</span><br><span class="line">/sys/kernel/mm/hugepages</span><br><span class="line">├── hugepages-1048576kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">├── hugepages-2048kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">├── hugepages-32768kB</span><br><span class="line">│   ├── demote</span><br><span class="line">│   ├── demote_size</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">└── hugepages-64kB</span><br><span class="line">    ├── free_hugepages</span><br><span class="line">    ├── nr_hugepages</span><br><span class="line">    ├── nr_hugepages_mempolicy</span><br><span class="line">    ├── nr_overcommit_hugepages</span><br><span class="line">    ├── resv_hugepages</span><br><span class="line">    └── surplus_hugepages</span><br></pre></td></tr></table></figure><p>这个 <code>hugepages-1048576kB</code> 就代表支持大小为 <code>1GB</code> 的页，<code>hugepages-2048kB</code> 就代表支持大小为 2MB 的页。</p><p>如果没有设置 <code>UseHugeTLBFS</code>，也没有设置 <code>UseSHM</code>，也没有设置 <code>UseTransparentHugePages</code>，那么其实就是走默认的，默认使用 <code>hugetlbfs</code> 方式，不使用 <code>THP</code> 方式，因为如前所述， THP 在某些场景下有意想不到的性能瓶颈表现，在大型应用中，稳定性优先于峰值性能。之后，默认优先尝试 <code>UseHugeTLBFS</code>（即使用 <code>mmap</code> 系统调用通过 hugetlbfs 方式大页分配），不行的话再尝试 <code>UseSHM</code>（即使用 <code>shmget</code> 系统调用通过 hugetlbfs 方式大页分配）。这里只是验证下这些大页内存的分配方式是否可用，只有可用后面真正分配内存的时候才会采用那种可用的大页内存分配方式。</p><h2 id="JVM内存申请与分配机制分析"><a href="#JVM内存申请与分配机制分析" class="headerlink" title="JVM内存申请与分配机制分析"></a>JVM内存申请与分配机制分析</h2><h3 id="内存管理的多级层次"><a href="#内存管理的多级层次" class="headerlink" title="内存管理的多级层次"></a>内存管理的多级层次</h3><p><strong><code>Reserve</code></strong> (预留) → <strong><code>Commit</code></strong> (提交) → <strong><code>Physical Allocation</code></strong> (物理分配)</p><ol><li>Reserve阶段：<ul><li>JVM向操作系统预留一块连续的虚拟地址空间</li><li>此时仅分配地址空间，不分配物理内存或交换空间</li><li>对应参数如 -Xmx 设置的最大堆内存</li></ul></li><li>Commit阶段：<ul><li>JVM向操作系统提交请求，准备使用之前预留的部分虚拟空间</li><li>操作系统标记这部分空间为”已提交”，准备关联物理内存</li><li>对应初始堆大小，如 -Xms 设置的内存</li></ul></li><li>物理分配阶段:<ul><li>当JVM实际写入数据到已提交的内存时，操作系统才分配物理内存页</li><li>这符合现代操作系统的”按需分页”(demand paging)机制</li><li>因此，已提交内存不等于实际使用的物理内存</li></ul></li></ol><h3 id="内存监控与差异"><a href="#内存监控与差异" class="headerlink" title="内存监控与差异"></a>内存监控与差异</h3><p><code>NMT(Native Memory Tracking)</code>显示的提交内存与进程实际使用的物理内存确实存在差异。</p><ol><li>NMT观察到的内存：<ul><li>显示已提交(committed)的内存量</li><li>包括已向操作系统申请但可能尚未使用的内存</li><li>命令: jcmd <pid> VM.native_memory</li></ul></li><li>实际物理内存使用<ul><li>通过 &#x2F;proc&#x2F;<pid>&#x2F;smaps_rollup 中的 PSS(Proportional Set Size)查看</li><li>PSS比VSS和RSS更准确地反映进程实际的物理内存使用</li><li>PSS &#x3D; 私有内存 + 按比例分摊的共享内存</li></ul></li></ol><h3 id="内存监控的最佳实践"><a href="#内存监控的最佳实践" class="headerlink" title="内存监控的最佳实践"></a>内存监控的最佳实践</h3><ol><li>JVM层面<ul><li>NMT: jcmd <pid> VM.native_memory</li><li>JConsole&#x2F;VisualVM可视化监控</li></ul></li><li>OS层面<ul><li>&#x2F;proc&#x2F;<pid>&#x2F;smaps_rollup中的PSS</li><li>top&#x2F;htop命令的RES&#x2F;RSS列</li><li>numastat -p <pid>查看NUMA内存分布</li></ul></li><li>高级监控<ul><li>perf工具分析内存访问模式</li><li>BPF&#x2F;eBPF工具追踪内存分配</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225875600644407357&quot;&gt;JVM 内存申请与使用流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Linux-下内存管理模型简述&quot;&gt;&lt;a href=&quot;#Linux-下内存管理模型简述&quot; class=&quot;headerlink&quot; title=&quot;Linux 下内存管理模型简述&quot;&gt;&lt;/a&gt;Linux 下内存管理模型简述&lt;/h2&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="linux内存" scheme="https://taeyang0126.github.io/tags/linux%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Statistics/Class Loading Statistics</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/8.jvm-yu-jfr-shi-jian-class-loading-statistics/posts/undefined/</id>
    <published>2025-03-01T03:01:52.000Z</published>
    <updated>2025-03-01T03:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ClassLoadingStatistics</code></li><li>Label(Event Type，用于显示): Class Loading Statistics</li><li>Category(用于分类显示): Java Application，Statistics</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>定时事件</code>: 代表定时采集，没有线程栈信息，因为执行线程都是 <code>JFR Periodic Tasks</code> 线程，采集这个线程栈没有意义</li><li><code>JVM内部事件</code></li></ul></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ClassLoadingStatistics&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;period&quot;</span>&gt;</span>1000 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li><code>Loaded Class Count</code>: 加载类的个数 _class_loaded_count + _shard_classes_loaded_count</li><li><code>UnLoaded Class Count</code>: 卸载类的个数 _class_unloaded_count + _shard_classes_unloaded_count</li><li>这两个字段都是类似于 <code>OpenTelemetry</code> 中的 <code>Gauge</code> 类型字段，瞬时值</li><li>由此可以推测出，当前 JVM 内存中有多少个类 &#x3D; <code>Loaded Class Count - UnLoaded Class Count</code></li></ul><h3 id="采集原理"><a href="#采集原理" class="headerlink" title="采集原理"></a>采集原理</h3><ul><li>每隔 1000ms（默认配置），生成 <code>jdk.ClassLoadingStatistics</code> 事件</li><li>即在 JVM 层面，读取 <code>ClassLoadingService</code> 中的统计数据:<ul><li>加载类的个数: _class_loaded_count + _shard_classes_loaded_count</li><li>卸载类的个数: _class_unloaded_count + _shard_classes_unloaded_count</li></ul></li></ul><h3 id="统计数据的更新时机"><a href="#统计数据的更新时机" class="headerlink" title="统计数据的更新时机"></a>统计数据的更新时机</h3><ul><li>_classes_loaded_count: 每次通过非 CDS 方式加载一个类的时候 +1</li><li>_shard_classes_loaded_count: 每次通过 CDS 方式加载一个类的时候 +1</li><li>_class_unloaded_count: 每次卸载一个非 CDS 类的时候 +1</li><li>_shard_classes_unloaded_count: 每次卸载一个 CDS 类的时候 +1</li></ul><h3 id="什么是-CDS（Class-Data-Sharing）"><a href="#什么是-CDS（Class-Data-Sharing）" class="headerlink" title="什么是 CDS（Class Data Sharing）"></a>什么是 CDS（Class Data Sharing）</h3><ul><li><a href="https://openjdk.org/jeps/310">CDS</a></li><li>Java 10 引入，允许多个 Java 应用程序共享相同的类数据，这样可以减少内存占用</li><li>在启动时，JVM 可以从共享的类数据存储中加载类元数据，而不是每次都从 JAR 文件或类文件中读取</li></ul><h3 id="jfr事件观察"><a href="#jfr事件观察" class="headerlink" title="jfr事件观察"></a>jfr事件观察</h3><blockquote><p>使用 <code>spring-petclinic</code> 项目测试</p></blockquote><ul><li><img data-src="/images/jfr/27.png" alt="img"></li><li>使用图表类型，将两个指标放在折线图中，同时将默认的柱状图隐藏</li></ul><h3 id="还有哪些地方能看到这个事件相同的指标数据？"><a href="#还有哪些地方能看到这个事件相同的指标数据？" class="headerlink" title="还有哪些地方能看到这个事件相同的指标数据？"></a>还有哪些地方能看到这个事件相同的指标数据？</h3><ul><li>_classes_loaded_count，_shard_classes_loaded_count，_classes_unloaded_count，_shard_classes_unloaded_count 这四个在 JVM内部<br>都是通过 <code>PerfDataManager</code> 实现</li><li>所有 <code>PerfDataManager</code> 的数据，JVM 通过下面的虚拟文件暴露出来了<ul><li>默认位置: 临时文件目录 <code>/hsperfdata_用户/进程号</code><br><img data-src="/images/jfr/28.png" alt="img"></li></ul></li><li>很多 JVM 监控工具，比如 Jvisualvm，JConsole 等等，都会访问这个虚拟文件拿实时指标</li><li>Jstat 类加载数据也是读取这个<br><img data-src="/images/jfr/29.png" alt="img"></li><li>Java Mbean 里面也是读取的这些指标<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ManagementFactory.getClassLoadingMXBean().getTotalLoadedClassCount(); <span class="comment">// 等同于事件中的 loadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount(); <span class="comment">// 等同于事件中的 unloadedClassCount</span></span><br><span class="line">ManagementFactory.getClassLoadingMXBean().getLoadedClassCount(); <span class="comment">// 即 loadedClassCount - unloadedClassCount</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h3><ul><li>该事件默认开启，1s采集一次，消耗很小很小，是读取一个现成的 JVM 内部指标，不是通过遍历某个数据结构计数实现。</li><li>使用下面的视图，可以发现类加载和类卸载急剧变化的时候<br><img data-src="/images/jfr/27.png" alt="img"></li><li>一般用来定位：<ol><li>异常大量类加载的问题: 一些反序列化框架，例如老版本 fastjson，利用ASM 定义类加速反序列化，但是由于缓存设计有问题，导致某些情况<br>反序列化会加载大量的类</li><li>大量类的反复加载与卸载的性能问题: 有大量这样的类: 同一个类，一会加载，一会卸载。一般发生在使用大量 lambda 表达式的时候。</li></ol></li><li>需要结合哪些东西一起定位:<ul><li>由于这个事件只能找到变化大的时间段</li><li>具体要定位是哪些类，可以:<ul><li>添加类加载和类卸载日志: <code>-Xlog:class+load,class+unload</code> 这两个，默认的 info 级别就够<br><img data-src="/images/jfr/30.png" alt="img"></li><li>结合其他类加载相关 JFR 事件一起</li></ul></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ClassLoadingStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Class Loading Statistics&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application，Statistics&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;定时事件&lt;/code&gt;: 代表定时采集，没有线程栈信息，因为执行线程都是 &lt;code&gt;JFR Periodic Tasks&lt;/code&gt; 线程，采集这个线程栈没有意义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="类加载" scheme="https://taeyang0126.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Z Allocation Stall</title>
    <link href="https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/03/01/jfr/7.jvm-yu-jfr-shi-jian-z-allocation-stall/posts/undefined/</id>
    <published>2025-03-01T02:01:52.000Z</published>
    <updated>2025-03-01T02:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ZAllocationStall</code></li><li>Label(Event Type，用于显示): Z Allocation Stall</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java15</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>ZGC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足</li><li><code>ZGC</code> 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，<br>不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 <code>Allocation Stall</code>（从而被<code>Z Allocation Stall</code>这个事件采集到），<br>但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>ZGC</code></li><li>在 GC 速度跟不上应用线程分配对象的速度时，应用线程尝试分配内存但是内存不足以分配的时候，该线程遇到 <code>Allocation Stall</code>，从而触发这个事件</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Duration</code>: 线程因 Allocation Stall 被阻塞等待 GC 回收足够内存的时间</li><li><code>Size</code>: 触发事件的分配大小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li><code>Type</code>: 从哪个区域分配（不同区域的分配策略，以及扫描回收的策略不一样）<ul><li>small: 小对象在这个区域分配</li><li>medium: 如果最大堆内存大于一定程度，就没必须有 medium。大于一定程度的堆内存，需要在 small 和 large 之间再增加一个区域粒度进行分配和管理</li><li>large: 大对象在这个区域分配</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）<br>启动参数使用 ZGC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// -Xmx32m</span></span><br><span class="line">      <span class="comment">// jdk 23</span></span><br><span class="line">      <span class="comment">// -XX:+UseZGC</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件和 JavaErrorThrow 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">      <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// jfr 启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个 8 * 1G 的数组（ZGC无法使用压缩指针），超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">        Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Z Allocation Stall</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/25.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZAllocationStall</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">      <span class="comment">// 启用 ZAllocationStall 事件</span></span><br><span class="line">      recording.enable(<span class="string">&quot;jdk.ZAllocationStall&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz();</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM();</span><br><span class="line">  </span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">      T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">            objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">            <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">              objects.clear();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">      Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/26.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>保持打开这个事件的采集<ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 Allocation Stall 基本就能采集到，针对大对象，大概率可以采集到，如果对象大小大于 Java 堆内存，必定可以采集到</li><li>对于持续小对象的内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，看到的噪声比较多。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ZAllocationStall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Z Allocation Stall&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java15&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;ZGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发内存不足&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZGC&lt;/code&gt; 思路与其他 GC 不同，ZGC 的实现思路是尽量避免阻塞线程。其他 GC 或多或少有需要全局安全点（SafePoint）的阶段，阻塞所有应用线程，&lt;br&gt;不管应用线程是否需要分配对象。但是 ZGC 在 GC 跟不上应用线程分配内存的速度的时候，触发 &lt;code&gt;Allocation Stall&lt;/code&gt;（从而被&lt;code&gt;Z Allocation Stall&lt;/code&gt;这个事件采集到），&lt;br&gt;但是只有当前尝试分配内存的线程会遇到，没有尝试分配内存的线程会继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Virtual Machine/GC/Detailed/Allocation Requiring GC</title>
    <link href="https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/24/jfr/6.jvm-yu-jfr-shi-jian-allocation-requiring-gc/posts/undefined/</id>
    <published>2025-02-24T12:55:52.000Z</published>
    <updated>2025-02-24T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.AllocationRequiringGC</code></li><li>Label(Event Type，用于显示): Allocation Requiring GC</li><li>Category(用于分类显示): Java Virtual Machine，GC，Detailed</li><li>事件从<code>Java11</code>引入</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件是基于使用的GC是 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的<code>核心区别</code><ul><li>如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配<code>不会</code>被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到</li><li>但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到</li></ul></li></ul><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><ul><li>使用 <code>SerialGC，ParallelGC 或者 G1GC</code></li><li>触发<a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程-路径四</a>分配，<code>在 GC 之前</code>，会触发这个事件的采集</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：线程的名字</li><li><code>Pending GC Identifier</code>: 即将触发的 GC ID(每次发生垃圾回收时，JVM 会生成一个全局自增 GC ID，以便于跟踪和分析不同的垃圾回收事件)</li><li>Size: 触发事件的分配发小<ul><li>对于小对象，很可能不是对象大小，大概率是 <code>TLAB</code> 大小</li><li>对于大对象（超过 TLAB 大小），是实际大小</li></ul></li><li>线程栈</li></ul><h3 id="模拟突发分配大块内存"><a href="#模拟突发分配大块内存" class="headerlink" title="模拟突发分配大块内存"></a>模拟突发分配大块内存</h3><blockquote><p>分配大块内存，甚至超过 Java 对象堆内存（类似于显示错误扫描全表，大查询等等）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// -Xmx32m</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 JFR 记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件和 JavaErrorThrow 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line">        <span class="comment">// JavaErrorThrow 会采集所有的Error，只有 OutOfMemoryError 不会采集(因为内存都不够了，再采集很大概率也采集不到)</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.JavaErrorThrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jfr 启动</span></span><br><span class="line">        recording.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分配一个 4 * 1G 的数组，超过 Xmx，抛出 OutOfMemoryError</span></span><br><span class="line">            <span class="comment">// 为什么这里分配1g的数组，实际对象有4g呢？</span></span><br><span class="line">            <span class="comment">// 1. 如果对象引用启用了压缩指针，那么是4字节</span></span><br><span class="line">            <span class="comment">// 2. 如果使用的是ZGC，由于ZGC没法使用压缩指针，所以是8字节</span></span><br><span class="line">            <span class="comment">// 3. 如果超过32g的内存，也是没法使用压缩指针的，因为四字节就不够用了(无法寻址)</span></span><br><span class="line">            Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                    <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                            + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                            + ProcessHandle.current().pid()</span><br><span class="line">                            + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">            ).toPath();</span><br><span class="line">            recording.dump(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 JFR，发现 Java Error 中并没有采集到 <code>OutOfMemoryError</code><br><img data-src="/images/jfr/22.png" alt="img"></li><li>因为 JDK 的设计，对于 <code>OutOfMemoryError</code>，故意让 Java Error 采集不到，这有这个 Error（以及子类），Java Error 采集不到。<br>因为发生 OutOfMemoryError 的时候，是内存不足的时候，再产生 JFR 事件很可能失败，所以估计忽略这个 Error</li><li>查看 <code>Allocation Requiring GC</code> 事件，可以看到这个分配<br><img data-src="/images/jfr/23.png" alt="img"></li></ul><h3 id="模拟热点分配情况下发生内存泄漏"><a href="#模拟热点分配情况下发生内存泄漏" class="headerlink" title="模拟热点分配情况下发生内存泄漏"></a>模拟热点分配情况下发生内存泄漏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationRequiringGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 事件，每秒最多采样 5 个对象</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;5/s&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationOutsideTLAB 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line">        <span class="comment">// 启用 AllocationRequiringGC 事件</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestAllocationSample.TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img data-src="/images/jfr/24.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>默认没有打开，<code>非常建议打开这个事件的采集</code><ul><li>对于显示那种异常的大查询，无论分配成功与否，只要触发 GC <code>基本就能采集到</code>，针对大对象，大概率可以采集到。如果对象大小<br>大于 Java 对象堆内存，必定可以采集到</li><li>对于持续小对象内存泄漏，很可能也是因为放入一个容器导致。这个容器扩容的时候，大概率触发这个事件。但是对于这个场景，会看到噪声比较多。</li></ul></li><li>该事件适合定位的问题<ul><li><code>大对象分配</code>：适合度<code>80%</code>。无论是否分配成功，只要触发了 GC 就都会上报这个事件。对于由于分配大对象导致的<br>OufOfMemoryError（比如一不小心执行了一个扫描全表的 SQL 返回数据的时候），特别合适</li><li><code>Java 堆对象内存泄漏</code>：适合度<code>60%</code>。对于大对象直接导致的 OufOfMemoryError 比较好定位。对于较大对象堆积导致的内存泄漏最终触发 OufOfMemoryError，<br>也比较合适，因为大概率会被采集到。但是对于持续小对象的内存泄漏，这个事件的适合度就比较低了，可能被正常分配导致 GC 的事件覆盖掉了。</li><li><code>GC 过于频繁</code>：适合度<code>50%</code>。对于 GC 过于频繁（比如 GC 暂停时间占应用运行时间的比例超过的一定比例），可以通过这个事件的上报，找到是哪个对象触发导致的<br>GC过于频繁，一般触发的对象比较大或者某一类对象出现的过于频繁，就可以考虑优化这个调用栈去减少 GC。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.AllocationRequiringGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Allocation Requiring GC&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Virtual Machine，GC，Detailed&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java11&lt;/code&gt;引入&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件是基于使用的GC是 &lt;code&gt;SerialGC，ParallelGC 或者 G1GC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此事件与 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample的&lt;code&gt;核心区别&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果对象分配失败，比如 java 对象堆内存不足抛出 OufOfMemoryError，那么这个分配&lt;code&gt;不会&lt;/code&gt;被 Object Allocation In New TLAB，Object Allocation Outside TLAB，Object Allocation Sample 采集到&lt;/li&gt;
&lt;li&gt;但是对于最后分配失败的对象，在尝试分配前，很大概率会触发 GC 从而被 Allocation Requiring GC 这个事件采集到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="GC" scheme="https://taeyang0126.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>java在容器中运行的脚本解析</title>
    <link href="https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/java/rong-qi-zhong-yun-xing-java-de-jiao-ben-jie-xi/posts/undefined/</id>
    <published>2025-02-23T09:46:30.000Z</published>
    <updated>2025-02-23T09:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/files/java/run.sh">run.sh</a></li></ul><h3 id="基础运行命令"><a href="#基础运行命令" class="headerlink" title="基础运行命令"></a>基础运行命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./run.sh           # 直接运行Java应用</span><br><span class="line">./run.sh run       # 同上</span><br><span class="line">./run.sh options   # 打印可用的Java选项</span><br></pre></td></tr></table></figure><h3 id="通过环境变量启用的功能"><a href="#通过环境变量启用的功能" class="headerlink" title="通过环境变量启用的功能"></a>通过环境变量启用的功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试相关</span></span><br><span class="line">export JAVA_ENABLE_DEBUG=true    # 启用远程调试</span><br><span class="line">export JAVA_DEBUG_PORT=5005      # 设置调试端口(默认5005)</span><br><span class="line">export JAVA_DEBUG_SUSPEND=y      # 启动时暂停等待调试器连接</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存相关</span></span><br><span class="line">export JAVA_MAX_MEM_RATIO=80     # 设置最大堆内存占比(默认50%)</span><br><span class="line">export JAVA_INIT_MEM_RATIO=25    # 设置初始堆内存占比</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">诊断相关</span></span><br><span class="line">export JAVA_DIAGNOSTICS=true     # 启用诊断功能</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">效果：启用GC日志、内存跟踪等</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代理相关</span></span><br><span class="line">export HTTP_PROXY=&quot;http://proxy:8080&quot;    # 设置HTTP代理</span><br><span class="line">export HTTPS_PROXY=&quot;https://proxy:8080&quot;   # 设置HTTPS代理</span><br><span class="line">export NO_PROXY=&quot;localhost,127.0.0.1&quot;     # 设置不使用代理的地址</span><br><span class="line"></span><br><span class="line">export JAVA_APP_NAME=&quot;myapp&quot;    # 设置进程名称</span><br><span class="line">export JAVA_MAIN_CLASS=&quot;com.example.Main&quot;  # 指定主类</span><br><span class="line">export JAVA_APP_JAR=&quot;app.jar&quot;   # 指定JAR包</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">===================================================================================</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个用于在容器中运行Java应用的通用启动脚本</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Usage:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="comment"># 可以直接运行Java应用:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh 参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#    # 可以获取Java选项:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ./run.sh options</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This script will pick up either a <span class="string">&#x27;fat&#x27;</span> jar <span class="built_in">which</span> can be run with <span class="string">&quot;-jar&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or you can sepcify a JAVA_MAIN_CLASS.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 脚本来自于以下项目:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at https://github.com/fabric8io-images/run-java-sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Env-variables evaluated in this script:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># JAVA_OPTIONS: Checked for already set options(设置java参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_MAX_MEM_RATIO: Ratio use to calculate a default maximum Memory, <span class="keyword">in</span> percent.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    用于计算默认最大内存的比例 容器内存*JAVA_MAX_MEM_RATIO=-Xmx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    默认情况下容器内存&lt;300，设置为25，超过则设置为50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                    For a good overviews what tuning options are available --&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://youtu.be/Vt4G-pHXfs4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://www.youtube.com/watch?v=w1rZOY5gbvk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            https://vimeo.com/album/4133413/video/181900266</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还请注意，堆只是 JVM 使用的内存的一小部分。还有很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他内存区域（元数据、线程、代码缓存等），这会增加整体</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大小。当您的容器因 OOM 而终止时，您应该调整</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绝对值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JAVA_INIT_MEM_RATIO：用于计算默认初始堆内存的比例（百分比）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下未设置此值。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 以下变量将暴露给您的 Java 应用程序：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># CONTAINER_MAX_MEMORY：容器的最大内存（如果在容器内运行）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAX_CORE_LIMIT：容器可用的内核数（如果在容器内运行）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">==========================================================</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fail on a single failed <span class="built_in">command</span> <span class="keyword">in</span> a pipeline (<span class="keyword">if</span> supported)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查并启用pipefail选项(如果支持) - 使管道中任一命令失败时整个管道都失败</span></span><br><span class="line">(set -o | grep -q pipefail) &amp;&amp; set -o pipefail</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遇到错误就终止执行，使用未定义变量时报错</span></span><br><span class="line">set -eu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存所有传入的参数到ARGS变量</span></span><br><span class="line">ARGS=&quot;$@&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否在ksh环境</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是,将<span class="built_in">local</span>命令别名为<span class="built_in">typeset</span>(ksh使用<span class="built_in">typeset</span>声明局部变量)</span></span><br><span class="line">if [ -n &quot;$&#123;KSH_VERSION:-&#125;&quot; ]; then</span><br><span class="line">  alias local=typeset</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Error is indicated with a prefix <span class="keyword">in</span> the <span class="built_in">return</span> value 错误检查函数</span></span><br><span class="line">check_error() &#123;</span><br><span class="line">  local error_msg=&quot;$1&quot;</span><br><span class="line">  if echo &quot;$&#123;error_msg&#125;&quot; | grep -q &quot;^ERROR:&quot;; then</span><br><span class="line">    echo &quot;$&#123;error_msg&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The full qualified directory <span class="built_in">where</span> this script is located <span class="keyword">in</span> 获取脚本所在目录</span></span><br><span class="line">script_dir() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Default is current directory</span></span><br><span class="line">  local dir=$(dirname &quot;$0&quot;)</span><br><span class="line">  local full_dir=$(cd &quot;$&#123;dir&#125;&quot; &amp;&amp; pwd)</span><br><span class="line">  echo $&#123;full_dir&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Try hard to find a sane default jar-file</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动检测JAR文件</span></span><br><span class="line">auto_detect_jar_file() &#123;</span><br><span class="line">  local dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Filter out temporary jars from the shade plugin <span class="built_in">which</span> start with <span class="string">&#x27;original-&#x27;</span></span></span><br><span class="line">  local old_dir=&quot;$(pwd)&quot;</span><br><span class="line">  cd $&#123;dir&#125;</span><br><span class="line">  if [ $? = 0 ]; then</span><br><span class="line">    # NB: Find both (single) JAR *or* WAR &lt;https://github.com/fabric8io-images/run-java-sh/issues/79&gt;</span><br><span class="line">    local nr_jars=&quot;$(ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27; | wc -l | awk &#x27;&#123;print $1&#125;&#x27;)&quot;</span><br><span class="line">    if [ &quot;$&#123;nr_jars&#125;&quot; = 1 ]; then</span><br><span class="line">      ls 2&gt;/dev/null | grep -e &#x27;.*\.jar$&#x27; -e &#x27;.*\.war$&#x27; | grep -v &#x27;^original-&#x27;</span><br><span class="line">      exit 0</span><br><span class="line">    fi</span><br><span class="line">    cd &quot;$&#123;old_dir&#125;&quot;</span><br><span class="line">    echo &quot;ERROR: Neither JAVA_MAIN_CLASS nor JAVA_APP_JAR is set and $&#123;nr_jars&#125; found in $&#123;dir&#125; (1 expected)&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;ERROR: No directory $&#123;dir&#125; found for auto detection&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check directories (arg 2...n) <span class="keyword">for</span> a jar file (arg 1) 在指定目录中查找jar文件</span></span><br><span class="line">find_jar_file() &#123;</span><br><span class="line">  local jar=&quot;$1&quot;</span><br><span class="line">  shift;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Absolute path check <span class="keyword">if</span> jar specifies an absolute path</span></span><br><span class="line">  if [ &quot;$&#123;jar&#125;&quot; != $&#123;jar#/&#125; ]; then</span><br><span class="line">    if [ -f &quot;$&#123;jar&#125;&quot; ]; then</span><br><span class="line">      echo &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;ERROR: No such file $&#123;jar&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    for dir in $*; do</span><br><span class="line">      if [ -f &quot;$&#123;dir&#125;/$jar&quot; ]; then</span><br><span class="line">        echo &quot;$&#123;dir&#125;/$jar&quot;</span><br><span class="line">        return</span><br><span class="line">      fi</span><br><span class="line">    done</span><br><span class="line">    echo &quot;ERROR: No $&#123;jar&#125; found in $*&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generic formula evaluation based on awk 数学计算函数</span></span><br><span class="line">calc() &#123;</span><br><span class="line">  local formula=&quot;$1&quot;</span><br><span class="line">  shift</span><br><span class="line">  echo &quot;$@&quot; | awk &#x27;</span><br><span class="line">    function ceil(x) &#123;</span><br><span class="line">      return x % 1 ? int(x) + 1 : x</span><br><span class="line">    &#125;</span><br><span class="line">    function log2(x) &#123;</span><br><span class="line">      return log(x)/log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    function max2(x, y) &#123;</span><br><span class="line">      return x &gt; y ? x : y</span><br><span class="line">    &#125;</span><br><span class="line">    function round(x) &#123;</span><br><span class="line">      return int(x + 0.5)</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;print &#x27;&quot;int($&#123;formula&#125;)&quot;&#x27;&#125;</span><br><span class="line">  &#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Based on the cgroup limits, figure out the max number of core we should utilize</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算容器的CPU核心限制</span></span><br><span class="line">core_limit() &#123;</span><br><span class="line">  local cpu_period_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;</span><br><span class="line">  local cpu_quota_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;</span><br><span class="line">  if [ -r &quot;$&#123;cpu_period_file&#125;&quot; ]; then</span><br><span class="line">    local cpu_period=&quot;$(cat $&#123;cpu_period_file&#125;)&quot;</span><br><span class="line"></span><br><span class="line">    if [ -r &quot;$&#123;cpu_quota_file&#125;&quot; ]; then</span><br><span class="line">      local cpu_quota=&quot;$(cat $&#123;cpu_quota_file&#125;)&quot;</span><br><span class="line">      # cfs_quota_us == -1 --&gt; no restrictions</span><br><span class="line">      if [ $&#123;cpu_quota:-0&#125; -ne -1 ]; then</span><br><span class="line">        echo $(calc &#x27;ceil($1/$2)&#x27; &quot;$&#123;cpu_quota&#125;&quot; &quot;$&#123;cpu_period&#125;&quot;)</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确定容器的最大内存限制</span></span><br><span class="line">max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">High number <span class="built_in">which</span> is the max <span class="built_in">limit</span> <span class="keyword">until</span> <span class="built_in">which</span> memory is supposed to be</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">unbounded.</span></span><br><span class="line">  local mem_file=&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</span><br><span class="line">  if [ -r &quot;$&#123;mem_file&#125;&quot; ]; then</span><br><span class="line">    local max_mem_cgroup=&quot;$(cat $&#123;mem_file&#125;)&quot;</span><br><span class="line">    local max_mem_meminfo_kb=&quot;$(cat /proc/meminfo | awk &#x27;/MemTotal/ &#123;print $2&#125;&#x27;)&quot;</span><br><span class="line">    local max_mem_meminfo=&quot;$(expr $max_mem_meminfo_kb \* 1024)&quot;</span><br><span class="line">    if [ $&#123;max_mem_cgroup:-0&#125; != -1 ] &amp;&amp; [ $&#123;max_mem_cgroup:-0&#125; -lt $&#123;max_mem_meminfo:-0&#125; ]</span><br><span class="line">    then</span><br><span class="line">      echo &quot;$&#123;max_mem_cgroup&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化容器限制相关的环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取并设置CPU核心限制，获取并设置内存限制，这些变量后续会被Java应用使用</span></span><br><span class="line">init_limit_env_vars() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Read <span class="keyword">in</span> container limits and <span class="built_in">export</span> the as environment variables</span></span><br><span class="line">  local core_limit=&quot;$(core_limit)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;core_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_CORE_LIMIT=&quot;$&#123;core_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local mem_limit=&quot;$(max_memory)&quot;</span><br><span class="line">  if [ -n &quot;$&#123;mem_limit&#125;&quot; ]; then</span><br><span class="line">    export CONTAINER_MAX_MEMORY=&quot;$&#123;mem_limit&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取Java主版本号</span></span><br><span class="line">init_java_major_version() &#123;</span><br><span class="line">    # Initialize JAVA_MAJOR_VERSION variable if missing</span><br><span class="line">    if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ]; then</span><br><span class="line">        local full_version=&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Parse JAVA_VERSION variable available in containers</span><br><span class="line">        if [ -n &quot;$&#123;JAVA_VERSION:-&#125;&quot; ]; then</span><br><span class="line">            full_version=&quot;$JAVA_VERSION&quot;</span><br><span class="line">        elif [ -n &quot;$&#123;JAVA_HOME:-&#125;&quot; ] &amp;&amp; [ -r &quot;$&#123;JAVA_HOME&#125;/release&quot; ]; then</span><br><span class="line">            full_version=&quot;$(grep -e &#x27;^JAVA_VERSION=&#x27; $&#123;JAVA_HOME&#125;/release | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)&quot;</span><br><span class="line">        else</span><br><span class="line">            full_version=$(java -version 2&gt;&amp;1 | head -1 | sed -e &#x27;s/.*\&quot;\([0-9.]\&#123;1,\&#125;\).*/\1/&#x27;)</span><br><span class="line">        fi</span><br><span class="line">        export JAVA_MAJOR_VERSION=$(echo $full_version | sed -e &#x27;s/[^0-9]*\(1\.\)\&#123;0,1\&#125;\([0-9]\&#123;1,\&#125;\).*/\2/&#x27;)</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载环境配置</span></span><br><span class="line">load_env() &#123;</span><br><span class="line">  local script_dir=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Configuration stuff is <span class="built_in">read</span> from this file</span></span><br><span class="line">  local run_env_sh=&quot;run-env.sh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Load default default config</span></span><br><span class="line">  if [ -f &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;script_dir&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Check also <span class="variable">$JAVA_APP_DIR</span>. Overrides other defaults</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">It<span class="string">&#x27;s valid to set the app dir in the default script</span></span></span><br><span class="line">  JAVA_APP_DIR=&quot;$&#123;JAVA_APP_DIR:-$&#123;script_dir&#125;&#125;&quot;</span><br><span class="line">  if [ -f &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot; ]; then</span><br><span class="line">    . &quot;$&#123;JAVA_APP_DIR&#125;/$&#123;run_env_sh&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  export JAVA_APP_DIR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JAVA_LIB_DIR defaults to JAVA_APP_DIR</span></span></span><br><span class="line">  export JAVA_LIB_DIR=&quot;$&#123;JAVA_LIB_DIR:-$&#123;JAVA_APP_DIR&#125;&#125;&quot;</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] &amp;&amp; [ -z &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    JAVA_APP_JAR=&quot;$(auto_detect_jar_file $&#123;JAVA_APP_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">    local jar=&quot;$(find_jar_file $&#123;JAVA_APP_JAR&#125; $&#123;JAVA_APP_DIR&#125; $&#123;JAVA_LIB_DIR&#125;)&quot;</span><br><span class="line">    check_error &quot;$&#123;jar&#125;&quot;</span><br><span class="line">    export JAVA_APP_JAR=&quot;$&#123;jar&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    export JAVA_MAIN_CLASS</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for standard /opt/run-java-options first, fallback to run-java-options in the path if not existing</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">获取Java运行选项(优先 /opt/run-java-options)</span></span></span><br><span class="line">run_java_options() &#123;</span><br><span class="line">  if [ -f &quot;/opt/run-java-options&quot; ]; then</span><br><span class="line">    echo &quot;$(. /opt/run-java-options)&quot;</span><br><span class="line">  else</span><br><span class="line">    which run-java-options &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    if [ $? = 0 ]; then</span><br><span class="line">      echo &quot;$(run-java-options)&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置java debug，远程debug</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">JAVA_ENABLE_DEBUG = true</span></span></span><br><span class="line">debug_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_ENABLE_DEBUG:-&#125;&quot; ] || [ -n &quot;$&#123;JAVA_DEBUG_ENABLE:-&#125;&quot; ] ||  [ -n &quot;$&#123;JAVA_DEBUG:-&#125;&quot; ]; then</span><br><span class="line">  local debug_port=&quot;$&#123;JAVA_DEBUG_PORT:-5005&#125;&quot;</span><br><span class="line">    local suspend_mode=&quot;n&quot;</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_DEBUG_SUSPEND:-&#125;&quot; ]; then</span><br><span class="line">      if ! echo &quot;$&#123;JAVA_DEBUG_SUSPEND&#125;&quot; | grep -q -e &#x27;^\(false\|n\|no\|0\)$&#x27;; then</span><br><span class="line">        suspend_mode=&quot;y&quot;</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local address_prefix=&quot;&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;9&quot; ]; then</span><br><span class="line">      address_prefix=&quot;*:&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=$&#123;suspend_mode&#125;,address=$&#123;address_prefix&#125;$&#123;debug_port&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read in a classpath either from a file with a single line, colon separated</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">or given line-by-line in separate lines</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Arg 1: path to claspath (must exist), optional arg2: application jar, which is stripped from the classpath in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">multi line arrangements</span></span></span><br><span class="line">format_classpath() &#123;</span><br><span class="line">  local cp_file=&quot;$1&quot;</span><br><span class="line">  local app_jar=&quot;$&#123;2:-&#125;&quot;</span><br><span class="line"></span><br><span class="line">  local wc_out=&quot;$(wc -l $1 2&gt;&amp;1)&quot;</span><br><span class="line">  if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;Cannot read lines in $&#123;cp_file&#125;: $wc_out&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local nr_lines=$(echo $wc_out | awk &#x27;&#123; print $1 &#125;&#x27;)</span><br><span class="line">  if [ $&#123;nr_lines&#125; -gt 1 ]; then</span><br><span class="line">    local sep=&quot;&quot;</span><br><span class="line">    local classpath=&quot;&quot;</span><br><span class="line">    while read file; do</span><br><span class="line">      local full_path=&quot;$&#123;JAVA_LIB_DIR&#125;/$&#123;file&#125;&quot;</span><br><span class="line">      # Don&#x27;t include app jar if include in list</span><br><span class="line">      if [ &quot;$&#123;app_jar&#125;&quot; != &quot;$&#123;full_path&#125;&quot; ]; then</span><br><span class="line">        classpath=&quot;$&#123;classpath&#125;$&#123;sep&#125;$&#123;full_path&#125;&quot;</span><br><span class="line">      fi</span><br><span class="line">      sep=&quot;:&quot;</span><br><span class="line">    done &lt; &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">    echo &quot;$&#123;classpath&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    # Supposed to be a single line, colon separated classpath file</span><br><span class="line">    cat &quot;$&#123;cp_file&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==========================================================================</span></span></span><br><span class="line"></span><br><span class="line">memory_options() &#123;</span><br><span class="line">  echo &quot;$(calc_init_memory) $(calc_max_memory)&quot;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set max heap size if needed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">根据不同条件自动计算并设置JVM的最大堆内存(-Xmx参数)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">主要逻辑：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">优先级判断：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已在JAVA_OPTIONS中设置了-Xmx，则保持用户设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果没有设置容器最大内存(CONTAINER_MAX_MEMORY)，则不进行设置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">堆内存计算规则(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果设置了JAVA_MAX_MEM_RATIO：使用指定比例计算</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果是Java 10+且未设置JAVA_MAX_MEM_RATIO：不设置最大内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 ≤ 300MB：设为容器内存的25%</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果容器内存 &gt; 300MB：设为容器内存的50%</span></span></span><br><span class="line">calc_max_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xmx is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xmx&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check for the &#x27;</span>real memory size<span class="string">&#x27; and calculate Xmx from the ratio</span></span></span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAX_MEM_RATIO:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">      # Explicitely switched off</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_MAX_MEM_RATIO&#125;&quot; &quot;mx&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">When JAVA_MAX_MEM_RATIO not set and JVM &gt;= 10 no max_memory</span></span></span><br><span class="line">  elif [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  elif [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">    # Restore the one-fourth default heap size instead of the one-half below 300MB threshold</span><br><span class="line">    # See https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;25&quot; &quot;mx&quot;</span><br><span class="line">  else</span><br><span class="line">    calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;50&quot; &quot;mx&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for memory options and set initial heap size if requested</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">calc_init_memory 的核心功能：计算并设置JVM的初始堆内存大小(-Xms参数)。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断逻辑(按优先级)：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS中已有-Xms，使用用户设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果未设置JAVA_INIT_MEM_RATIO或容器内存，不设置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果设置了上述参数，用公式计算：初始堆内存 = 容器内存 × (JAVA_INIT_MEM_RATIO/100)</span></span></span><br><span class="line">calc_init_memory() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -Xms is already given in JAVA_OPTIONS.</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-Xms&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check if value set</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_INIT_MEM_RATIO:-&#125;&quot; ] || [ -z &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ] || [ &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; -eq 0 ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Calculate Xms from the ratio given</span></span></span><br><span class="line">  calc_mem_opt &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; &quot;$&#123;JAVA_INIT_MEM_RATIO&#125;&quot; &quot;ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xmx -Xms</span></span></span><br><span class="line">calc_mem_opt() &#123;</span><br><span class="line">  local max_mem=&quot;$1&quot;</span><br><span class="line">  local fraction=&quot;$2&quot;</span><br><span class="line">  local mem_opt=&quot;$3&quot;</span><br><span class="line"></span><br><span class="line">  local val=$(calc &#x27;round($1*$2/100/1048576)&#x27; &quot;$&#123;max_mem&#125;&quot; &quot;$&#123;fraction&#125;&quot;)</span><br><span class="line">  echo &quot;-X$&#123;mem_opt&#125;$&#123;val&#125;m&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">当容器内存 ≤ 300MB (314572800字节) 时，禁用C2编译器</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">其他情况启用</span></span></span><br><span class="line">c2_disabled() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_MAX_MEMORY:-&#125;&quot; ]; then</span><br><span class="line">    # Disable C2 compiler when container memory &lt;=300MB</span><br><span class="line">    if [ &quot;$&#123;CONTAINER_MAX_MEMORY&#125;&quot; -le 314572800 ]; then</span><br><span class="line">      echo true</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo false</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">jit_options 函数决定JVM的即时编译器(JIT)级别：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">判断流程：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">如果JAVA_OPTIONS已有TieredStopAtLevel配置则用用户配置</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">内存≤300MB时，返回 -XX:TieredStopAtLevel=1，只用C1编译器节省内存</span></span></span><br><span class="line">jit_options() &#123;</span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Check whether -XX:TieredStopAtLevel is already given in JAVA_OPTIONS</span></span></span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:TieredStopAtLevel&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line">  if [ $(c2_disabled) = true ]; then</span><br><span class="line">    echo &quot;-XX:TieredStopAtLevel=1&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Switch on diagnostics except when switched off</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11+版本：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-Xlog:gc*:stdout:time            // 统一日志格式输出GC日志</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Java 11以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:NativeMemoryTracking=summary  // 跟踪JVM本地内存使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGC                      // 打印GC信息</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCDateStamps           // 打印GC时间戳</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+PrintGCTimeStamps           // 打印GC耗时</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UnlockDiagnosticVMOptions   // 解锁诊断选项</span></span></span><br><span class="line">diagnostics_options() &#123;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_DIAGNOSTICS:-&#125;&quot; ]; then</span><br><span class="line">    if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;11&quot; ]; then</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -Xlog:gc*:stdout:time -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &quot;-XX:NativeMemoryTracking=summary -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UnlockDiagnosticVMOptions&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Replicate thread ergonomics for tiered compilation.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This could ideally be skipped when tiered compilation is disabled.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The algorithm is taken from:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">OpenJDK / jdk8u / jdk8u / hotspot</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">src/share/vm/runtime/advancedThresholdPolicy.cpp</span></span></span><br><span class="line">ci_compiler_count() &#123;</span><br><span class="line">  local core_limit=&quot;$1&quot;</span><br><span class="line">  local log_cpu=$(calc &#x27;log2($1)&#x27; &quot;$core_limit&quot;)</span><br><span class="line">  local loglog_cpu=$(calc &#x27;log2(max2($1,1))&#x27; &quot;$log_cpu&quot;)</span><br><span class="line">  local count=$(calc &#x27;max2($1*$2,1)*3/2&#x27; &quot;$log_cpu&quot; &quot;$loglog_cpu&quot;)</span><br><span class="line">  local c1_count=$(calc &#x27;max2($1/3,1)&#x27; &quot;$count&quot;)</span><br><span class="line">  local c2_count=$(calc &#x27;max2($1-$2,1)&#x27; &quot;$count&quot; &quot;$c1_count&quot;)</span><br><span class="line">  [ $(c2_disabled) = true ] &amp;&amp; echo &quot;$c1_count&quot; || echo $(calc &#x27;$1+$2&#x27; &quot;$c1_count&quot; &quot;$c2_count&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">Java 10+ 不处理(因为能自动识别容器CPU限制)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">当设置了容器CPU限制时，配置以下参数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ParallelGCThreads=核心数     // 并行GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:ConcGCThreads=核心数        // 并发GC线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-Djava.util.concurrent.ForkJoinPool.common.parallelism=核心数  // ForkJoin池线程数</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:CICompilerCount=动态计算值   // JIT编译器线程数</span></span></span><br><span class="line">cpu_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">JVMs &gt;= 10 know about CPU limits</span></span></span><br><span class="line">  if [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -ge &quot;10&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local core_limit=&quot;$&#123;JAVA_CORE_LIMIT:-&#125;&quot;</span><br><span class="line">  if [ &quot;$core_limit&quot; = &quot;0&quot; ]; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$&#123;CONTAINER_CORE_LIMIT:-&#125;&quot; ]; then</span><br><span class="line">    if [ -z $&#123;core_limit&#125; ]; then</span><br><span class="line">      core_limit=&quot;$&#123;CONTAINER_CORE_LIMIT&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;-XX:ParallelGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:ConcGCThreads=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-Djava.util.concurrent.ForkJoinPool.common.parallelism=$&#123;core_limit&#125; &quot; \</span><br><span class="line">         &quot;-XX:CICompilerCount=$(ci_compiler_count $core_limit)&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MinHeapFreeRatio=20  These parameters tell the heap to shrink aggressively and to grow conservatively.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:MaxHeapFreeRatio=40  Thereby optimizing the amount of memory available to the operating system.</span></span></span><br><span class="line">heap_ratio() &#123;</span><br><span class="line">  echo &quot;-XX:MinHeapFreeRatio=20 -XX:MaxHeapFreeRatio=40&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">These parameters are necessary when running parallel GC if you want to use the Min and Max Heap Free ratios.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Skip setting gc_options if any other GC is set in JAVA_OPTIONS.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果用户已配置GC(比如-XX:UseG1GC)则不处理</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">对Java 10以下版本</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:+UseParallelGC                  # 使用并行GC</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:GCTimeRatio=4                   # GC时间占比不超过20%</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-XX:AdaptiveSizePolicyWeight=90     # GC自适应策略权重</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">$(heap_ratio)                       # 堆内存比例配置</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">非Java7版本 -XX:+ExitOnOutOfMemoryError        # OOM时直接退出JVM</span></span></span><br><span class="line">gc_options() &#123;</span><br><span class="line">  if echo &quot;$&#123;JAVA_OPTIONS:-&#125;&quot; | grep -q -- &quot;-XX:.*Use.*GC&quot;; then</span><br><span class="line">    return</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  local opts=&quot;&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">for JVMs &lt; 10 set GC settings</span></span></span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-0&#125;&quot; -lt &quot;10&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+UseParallelGC -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90 $(heap_ratio)&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; ] || [ &quot;$&#123;JAVA_MAJOR_VERSION:-&#125;&quot; != &quot;7&quot; ]; then</span><br><span class="line">    opts=&quot;$&#123;opts&#125; -XX:+ExitOnOutOfMemoryError&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo $opts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_default_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Echo options, trimming trailing and multiple spaces</span></span></span><br><span class="line">  echo &quot;$(memory_options) $(jit_options) $(diagnostics_options) $(cpu_options) $(gc_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">parse the URL</span></span></span><br><span class="line">parse_url() &#123;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="string">[scheme://][user[:password]@]host[:port][/path][?params]</span></span></span><br><span class="line">  echo &quot;$1&quot; | sed -e &quot;s+^\(\([^:]*\)://\)\?\(\([^:@]*\)\(:\([^@]*\)\)\?@\)\?\([^:/?]*\)\(:\([^/?]*\)\)\?.*$+ local scheme=&#x27;\2&#x27; username=&#x27;\4&#x27; password=&#x27;\6&#x27; hostname=&#x27;\7&#x27; port=&#x27;\9&#x27;+&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_proxy_options() &#123;</span><br><span class="line">  local url=&quot;$1&quot;</span><br><span class="line">  local transport=&quot;$2&quot;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$url&quot; ] ; then</span><br><span class="line">    eval $(parse_url &quot;$url&quot;)</span><br><span class="line">    if [ -n &quot;$hostname&quot; ] ; then</span><br><span class="line">      ret=&quot;-D$&#123;transport&#125;.proxyHost=$&#123;hostname&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$port&quot; ] ; then</span><br><span class="line">      ret=&quot;$ret -D$&#123;transport&#125;.proxyPort=$&#123;port&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$username&quot; -o -n &quot;$password&quot; ] ; then</span><br><span class="line">      echo &quot;WARNING: Proxy URL for $&#123;transport&#125; contains authentication credentials, these are not supported by java&quot; &gt;&amp;2</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for proxy options and echo if enabled.</span></span></span><br><span class="line">proxy_options() &#123;</span><br><span class="line">  local ret=&quot;&quot;</span><br><span class="line">  ret=&quot;$(java_proxy_options &quot;$&#123;https_proxy:-$&#123;HTTPS_PROXY:-&#125;&#125;&quot; https)&quot;</span><br><span class="line">  ret=&quot;$ret $(java_proxy_options &quot;$&#123;http_proxy:-$&#123;HTTP_PROXY:-&#125;&#125;&quot; http)&quot;</span><br><span class="line"></span><br><span class="line">  local noProxy=&quot;$&#123;no_proxy:-$&#123;NO_PROXY:-&#125;&#125;&quot;</span><br><span class="line">  if [ -n &quot;$noProxy&quot; ] ; then</span><br><span class="line">    ret=&quot;$ret -Dhttp.nonProxyHosts=$(echo &quot;|$noProxy&quot; | sed -e &#x27;s/,[[:space:]]*/|/g&#x27; | sed -e &#x27;s/[[:space:]]//g&#x27; | sed -e &#x27;s/|\./|\*\./g&#x27; | cut -c 2-)&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$ret&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set process name if possible</span></span></span><br><span class="line">exec_args() &#123;</span><br><span class="line">  EXEC_ARGS=&quot;&quot;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_APP_NAME:-&#125;&quot; ]; then</span><br><span class="line">    # Not all shells support the &#x27;exec -a newname&#x27; syntax..</span><br><span class="line">    if $(exec -a test true 2&gt;/dev/null); then</span><br><span class="line">      echo &quot;-a &#x27;$&#123;JAVA_APP_NAME&#125;&#x27;&quot;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Combine all java options</span></span></span><br><span class="line">java_options() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Normalize spaces with awk (i.e. trim and elimate double spaces)</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">See e.g. https://www.physicsforums.com/threads/awk-1-1-1-file-txt.658865/ for an explanation</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">of this awk idiom</span></span></span><br><span class="line">  echo &quot;$&#123;JAVA_OPTIONS:-&#125; $(run_java_options) $(debug_options) $(proxy_options) $(java_default_options)&quot; | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fetch classpath from env or from a local &quot;run-classpath&quot; file</span></span></span><br><span class="line">classpath() &#123;</span><br><span class="line">  local cp_path=&quot;.&quot;</span><br><span class="line">  if [ &quot;$&#123;JAVA_LIB_DIR&#125;&quot; != &quot;$&#123;JAVA_APP_DIR&#125;&quot; ]; then</span><br><span class="line">    cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_LIB_DIR&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  if [ -z &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ] &amp;&amp; [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ]; then</span><br><span class="line">    if [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ -f &quot;$&#123;JAVA_LIB_DIR&#125;/classpath&quot; ]; then</span><br><span class="line">      # Classpath is pre-created and stored in a &#x27;run-classpath&#x27; file</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$(format_classpath $&#123;JAVA_LIB_DIR&#125;/classpath $&#123;JAVA_APP_JAR:-&#125;)&quot;</span><br><span class="line">    else</span><br><span class="line">      # No order implied</span><br><span class="line">      cp_path=&quot;$&#123;cp_path&#125;:$&#123;JAVA_APP_DIR&#125;/*&quot;</span><br><span class="line">    fi</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_CLASSPATH:-&#125;&quot; ]; then</span><br><span class="line">    # Given from the outside</span><br><span class="line">    cp_path=&quot;$&#123;JAVA_CLASSPATH&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$&#123;cp_path&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Checks if a flag is present in the arguments.</span></span></span><br><span class="line">hasflag() &#123;</span><br><span class="line">    local filters=&quot;$@&quot;</span><br><span class="line">    for var in $ARGS; do</span><br><span class="line">        for filter in $filters; do</span><br><span class="line">          if [ &quot;$var&quot; = &quot;$filter&quot; ]; then</span><br><span class="line">              echo &#x27;true&#x27;</span><br><span class="line">              return</span><br><span class="line">          fi</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">==============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">开启对应的配置</span></span></span><br><span class="line">options() &#123;</span><br><span class="line">    if [ -z $&#123;1:-&#125; ]; then</span><br><span class="line">      java_options</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    local ret=&quot;&quot;</span><br><span class="line">    if [ $(hasflag --debug) ]; then</span><br><span class="line">      ret=&quot;$ret $(debug_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --proxy) ]; then</span><br><span class="line">      ret=&quot;$ret $(proxy_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --java-default) ]; then</span><br><span class="line">      ret=&quot;$ret $(java_default_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --memory) ]; then</span><br><span class="line">      ret=&quot;$ret $(memory_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --jit) ]; then</span><br><span class="line">      ret=&quot;$ret $(jit_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --diagnostics) ]; then</span><br><span class="line">      ret=&quot;$ret $(diagnostics_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --cpu) ]; then</span><br><span class="line">      ret=&quot;$ret $(cpu_options)&quot;</span><br><span class="line">    fi</span><br><span class="line">    if [ $(hasflag --gc) ]; then</span><br><span class="line">      ret=&quot;$ret $(gc_options)&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo $ret | awk &#x27;$1=$1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Start JVM</span></span></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Initialize environment</span></span></span><br><span class="line">  load_env $(script_dir)</span><br><span class="line"></span><br><span class="line">  local args</span><br><span class="line">  cd $&#123;JAVA_APP_DIR&#125;</span><br><span class="line">  if [ -n &quot;$&#123;JAVA_MAIN_CLASS:-&#125;&quot; ] ; then</span><br><span class="line">     args=&quot;$&#123;JAVA_MAIN_CLASS&#125;&quot;</span><br><span class="line">  elif [ -n &quot;$&#123;JAVA_APP_JAR:-&#125;&quot; ]; then</span><br><span class="line">     args=&quot;-jar $&#123;JAVA_APP_JAR&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">     echo &quot;Either JAVA_MAIN_CLASS or JAVA_APP_JAR needs to be given&quot;</span><br><span class="line">     exit 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != 1 ] &amp;&amp; [ &quot;$&#123;HIDE_CMD_LINE:-&#125;&quot; != true ]; then</span><br><span class="line">    echo exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Don&#x27;</span>t put <span class="variable">$&#123;args&#125;</span> <span class="keyword">in</span> quotes, otherwise it would be interpreted as a single arg.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">However it could be two args (see above). zsh doesn<span class="string">&#x27;t like this btw, but zsh is not</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">supported anyway.</span></span></span><br><span class="line">  exec $(exec_args) java $(java_options) -cp &quot;$(classpath)&quot; $&#123;args&#125; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">=============================================================================</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Fire up</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Initialize JAVA_MAJOR_VERSION variable if missing</span></span></span><br><span class="line">init_java_major_version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Set env vars reflecting limits</span></span></span><br><span class="line">init_limit_env_vars</span><br><span class="line"></span><br><span class="line">first_arg=$&#123;1:-&#125;</span><br><span class="line">if [ &quot;$&#123;first_arg&#125;&quot; = &quot;options&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Print out options only</span></span></span><br><span class="line">  shift</span><br><span class="line">  options $@</span><br><span class="line">  exit 0</span><br><span class="line">elif [ &quot;$&#123;first_arg&#125;&quot; = &quot;run&quot; ]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Run is the default command, but can be given to allow &quot;options&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">as first argument to your</span></span></span><br><span class="line">  shift</span><br><span class="line">fi</span><br><span class="line">run &quot;$@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/files/java/run.sh&quot;&gt;run.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础运行命令&quot;&gt;&lt;a href=&quot;#基础运行命令&quot; class=&quot;headerlink&quot; title=&quot;基础运行命令&quot;&gt;&lt;/a&gt;基础运行命令&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./run.sh           # 直接运行Java应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh run       # 同上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./run.sh options   # 打印可用的Java选项&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://taeyang0126.github.io/tags/JAVA/"/>
    
    <category term="run.sh" scheme="https://taeyang0126.github.io/tags/run-sh/"/>
    
    <category term="运行脚本" scheme="https://taeyang0126.github.io/tags/%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存解析 - 1.Native Memory Tracking</title>
    <link href="https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/23/jvm/nei-cun-jie-xi/jvm-nei-cun-jie-xi-native-memory-tracking/posts/undefined/</id>
    <published>2025-02-23T01:46:30.000Z</published>
    <updated>2025-02-23T01:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考张哥 -&gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</p></blockquote><ul><li><a href="https://juejin.cn/post/7225871227743043644">Native Memory Tracking</a></li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>Native Memory Tracking 主要是用来通过在 <code>JVM 向系统申请内存的时候进行埋点实现的</code>。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是有不小消耗的，这个 Native Memory Tracking 默认是不开启的，并且<code>无法动态开启</code>（因为这是埋点采集统计的，如果可以动态开启那么没开启的时候的内存分配没有记录无法知晓，所以无法动态开启），目前只能通过在启动 JVM 的时候通过启动参数开启。即通过 <code>-XX:NativeMemoryTracking</code> 开启:</p><ul><li><code>-XX:NativeMemoryTracking=off</code>:这是默认值，即关闭 Native Memory Tracking</li><li><code>-XX:NativeMemoryTracking=summary</code>: 开启 Native Memory Tracking，但是仅仅按照各个 JVM 子系统去统计内存占用情况</li><li><code>-XX:NativeMemoryTracking=detail</code>: 开启 Native Memory Tracking，从每次 JVM 中申请内存的不同调用路径的维度去统计内存占用情况。注意，开启 detail 比开启 summary 的消耗要大不少，因为 detail 每次都要解析 CallSite 分辨调用位置。我们一般用不到这么详细的内容，除非是 JVM 开发。</li></ul><p>开启之后，我们可以通过 jcmd 命令去查看 Native Memory Tracking 的信息，即<code>jcmd &lt;pid&gt; VM.native_memory</code>：</p><ul><li><code>jcmd &lt;pid&gt; VM.native_memory</code>或者<code>jcmd &lt;pid&gt; VM.native_memory summary</code>：两者是等价的，即查看 Native Memory Tracking 的 summary 信息。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory summary scale&#x3D;MB</li><li><code>jcmd &lt;pid&gt; VM.native_memory detail</code>：查看 Native Memory Tracking 的 detail 信息，包括 summary 信息，以及按照虚拟内存映射分组的内存使用信息，还有按照不同 CallSite 调用分组的内存使用情况。默认单位是 KB，可以指定单位为其他，例如 jcmd <pid> VM.native_memory detail scale&#x3D;MB</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>我们只关心并且查看 Native Memory Tracking 的 summary 信息即可，detail 信息一般是供 JVM 开发人员使用的，我们不用太关心</p></blockquote><p>一般地，只有遇到问题的时候，我们才会考虑开启 Native Memory Tracking，并且在定位出问题后，我们想把它关闭，可以通过 <code>jcmd &lt;pid&gt; VM.native_memory shutdown</code> 进行关闭并清理掉之前 Native Memory tracking 使用的埋点以及占用的内存。如前面所述，我们无法动态开启 Native Memory tracking，所以只要动态关闭了，这个进程就无法再开启了。</p><p>jcmd 本身提供了简单的对比功能，例如：</p><ol><li>使用 <code>jcmd &lt;pid&gt; VM.native_memory baseline</code> 记录当前内存占用信息</li><li>之后过一段时间 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 会输出当前 Native Memory Tracking 的 summary 信息，如果与第一步 baseline 的有差异，会在对应位将差异输出</li></ol><p>但是这个工具本身比较粗糙，我们有时候并不知道何时调用 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 合适，因为我们不确定什么时候会有我们想看到的内存使用过大的问题。所以我们一般做成一种持续监控的方式</p><h3 id="summary-信息每部分含义"><a href="#summary-信息每部分含义" class="headerlink" title="summary 信息每部分含义"></a>summary 信息每部分含义</h3><p>以下是一个 Native Memory Tracking 的示例输出：</p><ol><li>压测 <a href="https://github.com/spring-projects/spring-petclinic.git">spring-petclinic</a> 项目</li><li>jdk21</li><li>vm options</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">(Omitting categories weighting less than 1KB)</span><br><span class="line"></span><br><span class="line">Total: reserved=1751414KB, committed=470662KB</span><br><span class="line">       malloc: 104634KB #545587</span><br><span class="line">       mmap:   reserved=1646780KB, committed=366028KB</span><br><span class="line"></span><br><span class="line">-                 Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">                            (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">                            (classes #21948)</span><br><span class="line">                            (  instance classes #20377, array classes #1571)</span><br><span class="line">                            (malloc=1935KB #58688) (peak=1999KB #58351) </span><br><span class="line">                            (mmap: reserved=1048576KB, committed=15232KB, at peak) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=131072KB, committed=91072KB)</span><br><span class="line">                            (    used=90300KB)</span><br><span class="line">                            (    waste=772KB =0.85%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=14704KB)</span><br><span class="line">                            (    waste=528KB =3.46%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">                            (threads #58)</span><br><span class="line">                            (stack: reserved=117420KB, committed=117420KB, peak=117420KB)</span><br><span class="line">                            (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">                            (arena=67KB #114) (peak=3010KB #121)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">                            (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">                            (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=33KB #1)</span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">                            (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">                            (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br><span class="line"> </span><br><span class="line">-                 GCCardSet (reserved=70KB, committed=70KB)</span><br><span class="line">                            (malloc=70KB #778) (peak=483KB #1344) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=230KB, committed=230KB)</span><br><span class="line">                            (malloc=100KB #711) (peak=142KB #1118) </span><br><span class="line">                            (arena=130KB #2) (peak=10244KB #9)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">                            (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=108KB, committed=108KB)</span><br><span class="line">                            (malloc=108KB #18) (peak=130KB #20) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">                            (malloc=33100KB #285200) (peak=33111KB #284967) </span><br><span class="line">                            (arena=6017KB #1) (at peak)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                            (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                            (tracking overhead=8525KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">                            (malloc=199KB #306) (peak=16383KB #630) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">                            (malloc=21522KB #12431) (at peak) </span><br><span class="line">                            (arena=0KB #0) (peak=32KB #1)</span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=0KB, committed=0KB)</span><br><span class="line">                            (malloc=0KB #2) (peak=6KB #4) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=276KB, committed=276KB)</span><br><span class="line">                            (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"> </span><br><span class="line">-           Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                            (malloc=3462KB #66139) (peak=3479KB #66484) </span><br><span class="line"> </span><br><span class="line">-            Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                            (malloc=2837KB #33552) (peak=2850KB #33877) </span><br><span class="line"> </span><br><span class="line">-                 Metaspace (reserved=131503KB, committed=91503KB)</span><br><span class="line">                            (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">                            (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br><span class="line"> </span><br><span class="line">-      String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #8) (at peak) </span><br><span class="line"> </span><br><span class="line">-           Object Monitors (reserved=24KB, committed=24KB)</span><br><span class="line">                            (malloc=24KB #116) (peak=162KB #798) </span><br><span class="line"> </span><br><span class="line">-                   Unknown (reserved=0KB, committed=0KB)</span><br><span class="line">                            (mmap: reserved=0KB, committed=0KB, peak=32KB) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Java堆内存-Java-Heap"><a href="#Java堆内存-Java-Heap" class="headerlink" title="Java堆内存(Java Heap)"></a>Java堆内存(Java Heap)</h4><blockquote><p>所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 堆内存占用，reserve 了 262144KB=256M，当前 commit 了 82944KB(81M) 用于实际使用</span><br><span class="line">// 发现 申请的内存大小正好等于=-Xmx256m，预留内存空间（不实际分配物理内存），只是为了让操作系统选择地址，预留大小。commit才是实际使用的物理内存</span><br><span class="line">Java Heap (reserved=262144KB, committed=82944KB)</span><br><span class="line">    // 堆内存都是通过 mmap 系统调用方式分配的，peak=最大使用量</span><br><span class="line">    (mmap: reserved=262144KB, committed=82944KB, peak=262144KB) </span><br></pre></td></tr></table></figure><h4 id="元空间-Class"><a href="#元空间-Class" class="headerlink" title="元空间(Class)"></a>元空间(Class)</h4><blockquote><p>JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。对应的 Java 反射类 Class 还是在堆内存空间中</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Class 是类元空间总占用，reserve 了 1050511KB(1025M)，当前 commit 了 17167KB(16MB) 用于实际使用</span><br><span class="line">// 总共 reserved 1050511KB = mmap reserved 1048576KB(1024) + malloc 1935KB(1.8)</span><br><span class="line">// 总共 committed 17167KB = mmap committed 15232KB + malloc 1999KB</span><br><span class="line"> Class (reserved=1050511KB, committed=17167KB)</span><br><span class="line">        (classes #21948) //一共加载了 21948 个类</span><br><span class="line">        (  instance classes #20377, array classes #1571)    //其中 20377 个实体类，1571 个数组类</span><br><span class="line">        (malloc=1935KB #58688) (peak=1999KB #58351)  //通过 malloc 系统调用方式一共分配了 1935KB，一共调用了 58688 次 malloc</span><br><span class="line">        (mmap: reserved=1048576KB, committed=15232KB, at peak)  //通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 15232KB 用于实际使用</span><br><span class="line">        (  Metadata:   ) //注意，MetaData 这块不属于类元空间，属于数据元空间</span><br><span class="line">        (    reserved=131072KB, committed=91072KB) //数据元空间当前 reserve 了 131072KB，commit 了 91072KB 用于实际使用</span><br><span class="line">        (    used=90300KB) //但是实际从 MetaChunk 的角度去看使用，只有 90300KB 用于实际数据的分配，有 772KB 的浪费</span><br><span class="line">        (    waste=772KB =0.85%)</span><br><span class="line">        (  Class space:)</span><br><span class="line">        (    reserved=1048576KB, committed=15232KB) //类元空间当前 reserve 了 1048576KB，commit 了 15232KB 用于实际使用 </span><br><span class="line">        (    used=14704KB)  //但是实际从 MetaChunk 的角度去看使用，只有 14704KB 用于实际数据的分配，有 528KB 的浪费</span><br><span class="line">        (    waste=528KB =3.46%)</span><br><span class="line">Module (reserved=276KB, committed=276KB) //加载并记录模块占用空间，当前 reserve 了 276KB，commit 了 276KB 用于实际使用</span><br><span class="line">        (malloc=276KB #4515) (peak=303KB #4521) </span><br><span class="line">Metaspace (reserved=131503KB, committed=91503KB) //等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 131503KB，commit 了 91503KB 用于实际使用</span><br><span class="line">        (malloc=431KB #186) (peak=443KB #226) </span><br><span class="line">        (mmap: reserved=131072KB, committed=91072KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="C-字符串即符号-Symbol-占用空间"><a href="#C-字符串即符号-Symbol-占用空间" class="headerlink" title="C++ 字符串即符号(Symbol)占用空间"></a>C++ 字符串即符号(Symbol)占用空间</h4><blockquote><p>前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复。所以统一放入符号表(Symbol table)复用。元空间中保存的是针对符号表中符号的引用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Symbol (reserved=39117KB, committed=39117KB)</span><br><span class="line">        (malloc=33100KB #285200) (peak=33111KB #284967)  //通过 malloc 系统调用方式一共分配了 33100KB，一共调用了 285200 次 malloc</span><br><span class="line">        (arena=6017KB #1) (at peak) //通过 arena 系统调用方式一共分配了 6017KB，一共调用了 1 次 arena</span><br></pre></td></tr></table></figure><h4 id="线程占用内存-Thread"><a href="#线程占用内存-Thread" class="headerlink" title="线程占用内存(Thread)"></a>线程占用内存(Thread)</h4><blockquote><p>主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 总共 reserve 了 117590KB(114M)，commit 了 117590KB(114M)</span><br><span class="line">Thread (reserved=117590KB, committed=117590KB)</span><br><span class="line">    (threads #58) //当前线程数量是 58</span><br><span class="line">    (stack: reserved=117420KB, committed=117420KB, peak=117420KB) //线程栈占用的空间: 每个线程实际占用 ≈ 1MB(栈) + 2MB(Guard Pages) 58个线程总占用 ≈ 58 * (1MB + 2MB) ≈ 174MB，实际看到117MB比理论值小，因为Guard Pages可能共享</span><br><span class="line">    (malloc=103KB #350) (peak=123KB #391) </span><br><span class="line">    (arena=67KB #114) (peak=3010KB #121)</span><br></pre></td></tr></table></figure><h4 id="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code"><a href="#JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间-Code" class="headerlink" title="JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)"></a>JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间(Code)</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code (reserved=52246KB, committed=27478KB)</span><br><span class="line">    (malloc=2710KB #9638) (peak=2833KB #13764) </span><br><span class="line">    (mmap: reserved=49536KB, committed=24768KB, at peak) </span><br><span class="line">    (arena=0KB #0) (peak=33KB #1)</span><br></pre></td></tr></table></figure><h4 id="Arena-数据结构占用空间-Arena-Chunk"><a href="#Arena-数据结构占用空间-Arena-Chunk" class="headerlink" title="Arena 数据结构占用空间(Arena Chunk)"></a>Arena 数据结构占用空间(Arena Chunk)</h4><blockquote><p> Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arena Chunk (reserved=199KB, committed=199KB)</span><br><span class="line">            (malloc=199KB #306) (peak=16383KB #630) </span><br></pre></td></tr></table></figure><h4 id="JVM-Tracing-占用内存"><a href="#JVM-Tracing-占用内存" class="headerlink" title="JVM Tracing 占用内存"></a>JVM Tracing 占用内存</h4><blockquote><p>包括 JVM perf 以及 JFR 占用的空间。其中 JFR 占用的空间可能会比较大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tracing (reserved=21522KB, committed=21522KB)</span><br><span class="line">    (malloc=21522KB #12431) (at peak) </span><br><span class="line">    (arena=0KB #0) (peak=32KB #1)</span><br></pre></td></tr></table></figure><h4 id="写-JVM-日志占用的内存-Logging"><a href="#写-JVM-日志占用的内存-Logging" class="headerlink" title="写 JVM 日志占用的内存(Logging)"></a>写 JVM 日志占用的内存(Logging)</h4><blockquote><p>-Xlog 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志-Xlog:async，异步日志所需的 buffer 也在这里</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logging (reserved=0KB, committed=0KB)</span><br><span class="line">        (malloc=0KB #2) (peak=6KB #4) </span><br></pre></td></tr></table></figure><h4 id="JVM-参数占用内存-Arguments"><a href="#JVM-参数占用内存-Arguments" class="headerlink" title="JVM 参数占用内存(Arguments)"></a>JVM 参数占用内存(Arguments)</h4><blockquote><p>我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">(malloc=31KB #90) </span><br></pre></td></tr></table></figure><h4 id="JVM-安全点占用内存-Safepoint"><a href="#JVM-安全点占用内存-Safepoint" class="headerlink" title="JVM 安全点占用内存(Safepoint)"></a>JVM 安全点占用内存(Safepoint)</h4><blockquote><p>是固定的两页内存（我这里是一页是 16KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Safepoint (reserved=32KB, committed=32KB)</span><br><span class="line">           (mmap: reserved=32KB, committed=32KB, at peak) </span><br></pre></td></tr></table></figure><h4 id="Java-同步机制-Synchronization"><a href="#Java-同步机制-Synchronization" class="headerlink" title="Java 同步机制(Synchronization)"></a>Java 同步机制(Synchronization)</h4><blockquote><p>例如 synchronized，还有 AQS 的基础 LockSupport 底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Synchronization (reserved=3462KB, committed=3462KB)</span><br><span class="line">                (malloc=3462KB #66139) (peak=3479KB #66484) </span><br></pre></td></tr></table></figure><h4 id="JVM-TI-相关内存-Serviceability"><a href="#JVM-TI-相关内存-Serviceability" class="headerlink" title="JVM TI 相关内存(Serviceability)"></a>JVM TI 相关内存(Serviceability)</h4><blockquote><p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏检测工具等等。这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serviceability (reserved=2837KB, committed=2837KB)</span><br><span class="line">                (malloc=2837KB #33552) (peak=2850KB #33877) </span><br></pre></td></tr></table></figure><h4 id="Java-字符串去重占用内存-String-Deduplication"><a href="#Java-字符串去重占用内存-String-Deduplication" class="headerlink" title="Java 字符串去重占用内存(String Deduplication)"></a>Java 字符串去重占用内存(String Deduplication)</h4><blockquote><p>Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 <code>G1GC</code> 以及 <code>ZGC</code> 中，所以默认是关闭的，可以通过 <code>-XX:+UseStringDeduplication</code> 来启用</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                    (malloc=1KB #8) (at peak) </span><br></pre></td></tr></table></figure><h4 id="JVM-GC需要的数据结构与记录信息占用的空间-GC"><a href="#JVM-GC需要的数据结构与记录信息占用的空间-GC" class="headerlink" title="JVM GC需要的数据结构与记录信息占用的空间(GC)"></a>JVM GC需要的数据结构与记录信息占用的空间(GC)</h4><blockquote><p>这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 <code>ZGC</code>。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC (reserved=58006KB, committed=54566KB)</span><br><span class="line">    (malloc=20038KB #14233) (peak=20310KB #15935) </span><br><span class="line">    (mmap: reserved=37968KB, committed=34528KB, peak=37968KB) </span><br></pre></td></tr></table></figure><h4 id="JVM内部与其他占用"><a href="#JVM内部与其他占用" class="headerlink" title="JVM内部与其他占用"></a>JVM内部与其他占用</h4><blockquote><p>JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Internal (reserved=2904KB, committed=2904KB)</span><br><span class="line">        (malloc=2872KB #56765) (peak=2920KB #57573) </span><br><span class="line">        (mmap: reserved=32KB, committed=32KB, at peak) </span><br><span class="line"></span><br><span class="line"> Other (reserved=108KB, committed=108KB)</span><br><span class="line">        (malloc=108KB #18) (peak=130KB #20) </span><br></pre></td></tr></table></figure><h4 id="开启-Native-Memory-Tracking-本身消耗的内存"><a href="#开启-Native-Memory-Tracking-本身消耗的内存" class="headerlink" title="开启 Native Memory Tracking 本身消耗的内存"></a>开启 Native Memory Tracking 本身消耗的内存</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking (reserved=8633KB, committed=8633KB)</span><br><span class="line">                    (malloc=108KB #1942) (peak=109KB #1948) </span><br><span class="line">                    (tracking overhead=8525KB)</span><br></pre></td></tr></table></figure><h3 id="Native-Memory-Tracking-的-summary-信息的持续监控"><a href="#Native-Memory-Tracking-的-summary-信息的持续监控" class="headerlink" title="Native Memory Tracking 的 summary 信息的持续监控"></a>Native Memory Tracking 的 summary 信息的持续监控</h3><p>现在 JVM 一般大部分部署在 k8s 这种云容器编排的环境中，每个 JVM 进程内存是受限的。如果超过限制，那么会触发 OOMKiller 将这个 JVM 进程杀掉。我们一般都是由于自己的 JVM 进程被 OOMKiller杀掉，才会考虑打开 <code>NativeMemoryTracking</code> 去看看哪块内存占用比较多以及如何调整的。</p><p><code>OOMKiller 是积分制</code>，并不是你的 JVM 进程一超过限制就立刻会被杀掉，而是超过的话会累积分，累积到一定程度，就可能会被 OOMKiller 杀掉。所以，我们可以通过<code>定时输出</code> Native Memory Tracking的 summary 信息，从而抓到超过内存限制的点进行分析</p><p>但是，我们不能仅通过 Native Memory Tracking 的数据就判断 JVM 占用的内存，因为在后面的 JVM 内存申请与使用流程的分析我们会看到，<code>JVM 通过 mmap 分配的大量内存都是先 reserve 再 commit 之后实际往里面写入数据的时候，才会真正分配物理内存</code>。同时，JVM 还会动态释放一些内存，这些内存可能不会立刻被操作系统回收。<code>Native Memory Tracking 是 JVM 认为自己向操作系统申请的内存，与实际操作系统分配的内存是有所差距的</code>，所以我们不能只查看 Native Memory Tracking 去判断，我们还需要查看能体现真正内存占用指标。这里可以查看 linux 进程监控文件 smaps_rollup 看出具体的内存占用，例如 (一般不看 Rss，因为如果涉及多个虚拟地址映射同一个物理地址的话会有不准确，所以主要关注 <code>Pss</code> 即可，但是 Pss 更新不是实时的，但也差不多，这就可以理解为进程占用的实际物理内存)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/1/smaps_rollup </span><br><span class="line">f8000000-ffffe5c27000 ---p 00000000 00:00 0                              [rollup]</span><br><span class="line">Rss:              198904 kB</span><br><span class="line">Pss:              197331 kB</span><br><span class="line">Pss_Dirty:        181900 kB</span><br><span class="line">Pss_Anon:         181880 kB</span><br><span class="line">Pss_File:          15451 kB</span><br><span class="line">Pss_Shmem:             0 kB</span><br><span class="line">Shared_Clean:       1864 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:     15140 kB</span><br><span class="line">Private_Dirty:    181900 kB</span><br><span class="line">Referenced:       198904 kB</span><br><span class="line">Anonymous:        181880 kB</span><br><span class="line">KSM:                   0 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FilePmdMapped:         0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure><p>通过在每个 Spring Cloud 微服务进程加入下面的代码，来实现定时的进程内存监控，主要通过 <code>smaps_rollup</code> 查看实际的物理内存占用找到内存超限的时间点，Native Memory Tracking 查看 JVM 每块内存占用的多少，用于指导优化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.bootstrap.BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorMemoryRSS</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">INITIALIZED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBootstrapContext(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (INITIALIZED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZED.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取 smaps_rollup</span></span><br><span class="line">                    List&lt;String&gt; strings = FileUtils.readLines(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/smaps_rollup&quot;</span>));</span><br><span class="line">                    log.info(<span class="string">&quot;MonitorMemoryRSS, smaps_rollup: &#123;&#125;&quot;</span>, strings.stream().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    <span class="comment">//读取 Native Memory Tracking 信息</span></span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;jcmd&quot;</span>, pid + <span class="string">&quot;&quot;</span>, <span class="string">&quot;VM.native_memory&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()))) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;MonitorMemoryRSS, native_memory: &#123;&#125;&quot;</span>, reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            INITIALIZED.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBootstrapContext</span><span class="params">(ApplicationReadyEvent applicationEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationEvent.getApplicationContext().getEnvironment().getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考张哥 -&amp;gt; 全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7225871227743043644&quot;&gt;Native Memory Tracking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开启&quot;&gt;&lt;a href=&quot;#开启&quot; class=&quot;headerlink&quot; title=&quot;开启&quot;&gt;&lt;/a&gt;开启&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM内存解析" scheme="https://taeyang0126.github.io/categories/JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="内存" scheme="https://taeyang0126.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="NMT" scheme="https://taeyang0126.github.io/tags/NMT/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Sample</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/5.jvm-yu-jfr-shi-jian-object-allocation-sample/posts/undefined/</id>
    <published>2025-02-22T12:55:52.000Z</published>
    <updated>2025-02-22T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationSample</code></li><li>Label(Event Type，用于显示): Object Allocation Sample</li><li>Category(用于分类显示): Java Application</li><li>事件从<code>Java16</code>引入(目的是想有一个采集消耗不像 <code>ObjectAllocationInNewTLAB</code> 这么大的事件)</li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二、路径三、路径四</code></li><li><code>路径二、路径三</code> 分配一定进入采样中，<code>路径四</code> 分配失败不会进入采样中</li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>150/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>300/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二、三、四分配然后被采集到的线程的名称</li><li>Object Class：发生路径二、三、四分配然后被采集到的对象大小类型</li><li><code>Sample Weight</code><ul><li>采样到的采样权重</li><li>每个线程都有一个采样数据记录了分配了多少对象，对象的总大小</li><li>这个采样权重就是这个线程当前分配对象总大小减去上次这个线程被采样到的时候的分配对象的总大小</li><li>其实就是近似的任务，这个线程这个期间分配的对象都是 Object Class 类型，大小是采样权重这么大</li><li>单独一个 Object Allocation Sample 事件的 weight 仅代表当前这个线程上次触发 Object Allocation Sample 之后，<br>这个线程分配的对象大小，所以<code>单独看一个事件的这个值没有参考意义</code></li><li><code>它的参考意义主要在于</code>，按照线程和 Object Class 分组，将所有 weight 相加，统计这个线程分配的对象的总大小，这个值可以<br>用于分析这个线程在这段时间的分配压力，以及这个线程的分配对象的类型分布情况</li></ul></li><li>线程栈：发生路径二、三、四分配然后被采集到的线程栈，默认是采集的</li></ul><h3 id="事件采集原理"><a href="#事件采集原理" class="headerlink" title="事件采集原理"></a>事件采集原理</h3><pre><code class="mermaid">%%{init: {&#39;theme&#39;: &#39;default&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#2B6CB0&#39; }}}%%flowchart TD    A1[当前分配的对象触发申请新的 TLAB 分配并且成功分配后-路径二]    A2[当前分配的对象触发 TLAB 外分配并且分配成功后-路径三]    B[生成 Object Allocation Sample 事件]    C[设置事件的 objectClass 为分配对象的 class]    A1 --&gt; B    A2 --&gt; |重复n次，n &#x3D; 分配的对象大小除以 TLAB 大小，用于让大对象更容易生成 Object Allocation Sample-更容易被采集到| B    B --&gt; C    C --&gt; D[设置事件的 weight 为当前线程已经分配的总内存减去上次触发 Object Allocation Sample 事件当前线程已经分配的总内存]    D --&gt; E[记录当前线程已经分配的总内存用于下次计算 weight]</code></pre><h3 id="编写测试代码-使用虚拟线程"><a href="#编写测试代码-使用虚拟线程" class="headerlink" title="编写测试代码(使用虚拟线程)"></a>编写测试代码(使用虚拟线程)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocationSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 初始化jfr记录</span></span><br><span class="line">        <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">        <span class="comment">// 启用 ObjectAllocationSample 和 ObjectAllocationOutsideTLAB 事件，用于对比</span></span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>).with(<span class="string">&quot;throttle&quot;</span>, <span class="string">&quot;150/s&quot;</span>);</span><br><span class="line">        recording.enable(<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JFR 记录启动</span></span><br><span class="line">        recording.start();</span><br><span class="line">        <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">        <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">        runBiz();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">        runOOM();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">                <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                        + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                        + ProcessHandle.current().pid()</span><br><span class="line">                        + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">        ).toPath();</span><br><span class="line">        recording.dump(path);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        T1, T2, T3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟正常业务运行，多线程并发分配对象，朝生夕死</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建虚拟线程的 Builder，前缀是 biz，编号从 0 开始</span></span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;biz&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 分配普通 Object 和 Enum 对象数组</span></span><br><span class="line">                    objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    objects.add(TestEnum.values());</span><br><span class="line">                    <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        objects.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i].interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threads[i].getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，一直不回收，但是不触发 OutOfMemoryError</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        Thread.Builder.<span class="type">OfVirtual</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;oom&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = builder.start(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object Allocation Sample 定位可能的内存泄漏，并不是太合适，容易被热点对象吞没<br><img data-src="/images/jfr/15.png" alt="img"></li><li>Object Allocation Sample <code>非常适合定位热点分配对象中有没有哪些意料之外的频繁对象分配</code>，从而优化性能<ul><li>以 Object Allocation Sample 创建新的标签页<br><img data-src="/images/jfr/16.png" alt="img"></li><li>在标签页，首页按照线程分组<br><img data-src="/images/jfr/17.png" alt="img"></li><li>在上个分组基础上按照对象类型分组<br><img data-src="/images/jfr/18.png" alt="img"></li></ul></li><li>从JFR可以看出，<code>.values</code>遍历数组每次都会新创建一个数组对象，造成非常频繁的对象分配，影响性能(jdk21)<br><img data-src="/images/jfr/19.png" alt="img"></li><li>jdk23下，发现Object分配比Enum还多，这是个奇特的点！<br><img data-src="/images/jfr/20.png" alt="img"></li><li>将 Object Allocation Sample 的 throttle 改为 1&#x2F;s，效果如下(jdk21)<br><img data-src="/images/jfr/21.png" alt="img"></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>建议维持打开 Object Allocation Sample</li><li>但是 throttle 设置为 1&#x2F;s ~ 5&#x2F;s 即可，基本可以定位到分配热点以及意想不到的分配，进行代码优化</li><li>这个事件适合定位什么问题？<ul><li>大对象分配：适合度50%。这个只会采集分配成功的对象，对于大对象分配，如果触发 OutOfMemoryError 代表分配失败，那采集不到。</li><li>意想不到大量对象分配：适合度 90% 。通过 weight 统计，可以找到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。<br>在做定期性能优化的时候，可以经常看看。</li><li>Java 堆对象内存泄漏：适合度 10% 。仅仅可以定位热点分配的对象类型和堆栈，但是内存泄漏如果不是热点对象导致的，就不太好定位了。</li><li>GC 过于频繁：适合度 100% 。可以定位到哪个线程分配了大量的对象，以及这个线程分配的对象的类型和堆栈的分布情况。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationSample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Sample&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从&lt;code&gt;Java16&lt;/code&gt;引入(目的是想有一个采集消耗不像 &lt;code&gt;ObjectAllocationInNewTLAB&lt;/code&gt; 这么大的事件)&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径二、路径三、路径四&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;路径二、路径三&lt;/code&gt; 分配一定进入采样中，&lt;code&gt;路径四&lt;/code&gt; 分配失败不会进入采样中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>画图工具</title>
    <link href="https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/gong-ju/hua-tu-gong-ju/posts/undefined/</id>
    <published>2025-02-22T11:55:52.000Z</published>
    <updated>2025-02-22T11:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mermaid-live.nodejs.cn/">mermaid在线画图</a></li><li><a href="https://www.min2k.com/tools/mermaid/">中文mermaid在线画图</a></li><li><a href="https://www.mermaidchart.com/">mermaid画图</a></li><li><a href="https://mermaid.nodejs.cn/intro/">mermaid中文网</a></li><li><a href="https://excalidraw.com/">手绘风格画图</a></li><li><a href="https://fskpf.github.io/">svg图片转手绘风格</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mermaid-live.nodejs.cn/&quot;&gt;mermaid在线画图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.min2k.com/tools/mermaid/&quot;&gt;中文mermaid在线画图&lt;/a&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://taeyang0126.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="画图" scheme="https://taeyang0126.github.io/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-你可能没必要 Heap Dump</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/jvm-yu-jfr-shi-jian-ni-ke-neng-mei-bi-yao-heap-dump/posts/undefined/</id>
    <published>2025-02-22T07:25:52.000Z</published>
    <updated>2025-02-22T07:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><blockquote><p>很多情况会导致 Java 应用抛出 <code>OutOfMemoryError</code> <a href="https://zhuanlan.zhihu.com/p/265039643">参考 StackOverflowError 与 OutOfMemoryError</a></p></blockquote><h4 id="会触发HeapDumpOnOutOfMemoryError"><a href="#会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="会触发HeapDumpOnOutOfMemoryError"></a>会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><code>OutOfMemoryError: Java heap space</code> 和 <code>OutOfMemoryError: GC overhead limit exceeded</code> ：这两个都是 Java 对象堆内存不够了，一个是分配的时候发现剩余空间不足，一个是到达某一界限</li><li><code>OutOfMemoryError: Requested array size exceeds VM limit</code> ：当申请的数组大小超过堆内存限制，就会抛出这个异常</li><li><code>OutOfMemoryError: Compressed class space</code> 和 <code>OutOfMemoryError: Metaspace</code> ：这两个都和元空间相关（<a href="https://juejin.cn/post/7225879724545835045">底层原理</a>）</li><li><code>Shenandoah</code> 分配区域位图，内存的时候，触发的 OutOfMemoryError</li></ul><h4 id="不会触发HeapDumpOnOutOfMemoryError"><a href="#不会触发HeapDumpOnOutOfMemoryError" class="headerlink" title="不会触发HeapDumpOnOutOfMemoryError"></a>不会触发<code>HeapDumpOnOutOfMemoryError</code></h4><ul><li><strong>OutOfMemoryError: unable to create native thread</strong> ：无法创建新的平台线程</li><li><strong>OutOfMemoryError: Cannot reserve xxx bytes of direct buffer memory (allocated: xxx, limit: xxx)</strong> ：在 DirectByteBuffer 中，首先向 Bits 类申请额度， Bits 类有一个全局的 totalCapacity 变量，记录着全部DirectByteBuffer 的总大小，每次申请，都先看看是否超限，可用 <code>-XX:MaxDirectMemorySize</code> 限制（未指定默认与-Xmx相同）</li><li><strong>OutOfMemoryError: map failed</strong> ：这个是 File MMAP （文件映射内存）时，如果系统内存不足，就会抛出这个异常</li><li>OutOfMemoryError: Native heap allocation failed ，这个 Message 可能不同操作系统不一样，但是一般都有 native heap 。这个就和 Java 对象堆一般没关系，而是其他块内存无法申请导致的</li></ul><h3 id="为什么不建议打开HeapDumpOnOutOfMemoryError"><a href="#为什么不建议打开HeapDumpOnOutOfMemoryError" class="headerlink" title="为什么不建议打开HeapDumpOnOutOfMemoryError"></a>为什么不建议打开<code>HeapDumpOnOutOfMemoryError</code></h3><h4 id="HeapDumpOnOutOfMemoryError-的原理"><a href="#HeapDumpOnOutOfMemoryError-的原理" class="headerlink" title="HeapDumpOnOutOfMemoryError 的原理"></a><code>HeapDumpOnOutOfMemoryError</code> 的原理</h4><ul><li>进入安全点，所有应用线程暂停，针对 HeapDumpOnOutOfMemoryError，单线程（如果是 jcmd jmap 可以多线程）dump 堆为线程个数个文件。退出安全点。</li><li>将上面的多个文件，合并为一个，压缩。</li></ul><h4 id="HeapDumpOnOutOfMemoryError-的瓶颈"><a href="#HeapDumpOnOutOfMemoryError-的瓶颈" class="headerlink" title="HeapDumpOnOutOfMemoryError 的瓶颈"></a><code>HeapDumpOnOutOfMemoryError</code> 的瓶颈</h4><blockquote><p>这里的瓶颈主要在于第一步写入，并且，主要瓶颈在磁盘 IO</p></blockquote><ul><li><a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html">AWS EFS （普通存储）</a></li><li><a href="https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html">AWS EBS （对标 SSD ）</a></li><li>对于一个 4G 大小的 Java 对象堆内存，如果是 EFS ，对标的应该是 100G 以内的磁盘，写入最少<br>也需要大概 4 * 1024 &#x2F; 300 &#x3D; 13.65 秒（注意，这个是峰值性能），如果当时峰值性能被用完了，那<br>么需要： 4 * 1024 &#x2F; 15 &#x3D; 273 秒。如果用 EBS ，那么也需要 4 * 1024 &#x2F; 1000 &#x3D; 4 秒。注意，这个<br>计算的时间，是应用线程个完全处于安全点（即 Stop-the-world ）的时间，还没有考虑一个<br>机器上部署多个容器实例的情况，考虑成本我们也不能堆每个微服务都使用 AWS EBS 这种（对标<br>SSD ）。所以，建议还是不要打开 <code>HeapDumpOnOutOfMemoryError</code></li></ul><h3 id="为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？"><a href="#为什么觉得-90-以上的内存泄漏问题没必要-Heap-Dump-就能通过-JFR-定位到？" class="headerlink" title="为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？"></a>为什么觉得 90% 以上的内存泄漏问题没必要 Heap Dump 就能通过 JFR 定位到？</h3><h4 id="jfr配置"><a href="#jfr配置" class="headerlink" title="jfr配置"></a>jfr配置</h4><ul><li>jfc配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationSample&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;object-allocation-enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;throttle&quot;</span> <span class="attr">control</span>=<span class="string">&quot;allocation-profiling&quot;</span>&gt;</span>5/s<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.AllocationRequiringGC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ZAllocationStall&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;threshold&quot;</span>&gt;</span>0 ms<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ObjectAllocationOutsideTLAB：TLAB外的分配</li><li>ObjectAllocationSample：TLAB外的以及申请新的TLAB的采样</li><li>AllocationRequiringGC：某个对象分配失败导致gc采集，针对serial、parallel、G1 gc</li><li>ZAllocationStall：ZGC中使用，当一个线程分配对象发现内存不够了，就会阻塞，从而生成此事件。”threshold”&gt;0 阻塞0ms以上都采集<br>ZGC Allocation Stall事件为啥看不到触发内存溢出的业务代码呢？jdk23才可以</li><li>JVM参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stackdepth=256 是为了演示效果，一般不需要这么大</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxchunksize=128m 是为了演示效果，一般不需要这么大</span></span><br><span class="line">-Xmx256m</span><br><span class="line">-XX:StartFlightRecording=disk=true,maxsize=5000m,maxage=2d,settings=./default.jfc</span><br><span class="line">-XX:FlightRecorderOptions=maxchunksize=128m,repository=./,stackdepth=256</span><br></pre></td></tr></table></figure></li></ul><h4 id="大对象分配导致的问题"><a href="#大对象分配导致的问题" class="headerlink" title="大对象分配导致的问题"></a>大对象分配导致的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote><p>某个请求有 bug，导致全表扫描，冲爆了 Java 对象堆内存。抛出了 OutOfMemoryError ，但是这是异常情况，可能无法输出堆栈日志，在茫茫众多的请求中很难找到这个请求</p></blockquote><ul><li>模拟了一个方法，从db返回结果非常大，直接导致OOM，输出的jfr如下</li><li><img data-src="/images/jfr/08.png" alt="img"></li><li><img data-src="/images/jfr/09.png" alt="img"></li><li>ZGC查看如下图<br><img data-src="/images/jfr/10.png" alt="img"></li></ul><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote><p>用户累计订单量随着你的系统成熟越来越多，大历史订单量的用户越来越多。之前的代码有 bug ，用户订单列表实际是拉取每个用户的所有订单 内存分页。可能两个大历史订单量的用户同时查询的时候就会抛出 OutOfMemoryError ，就算不抛出也会频繁 GC 影响性能。</p></blockquote><ul><li>模拟了一个方法，多个大订单量的用户并发查询，可能没有导致OOM，但是会频繁的GC，输出的jfr如下</li><li><img data-src="/images/jfr/11.png" alt="img"></li><li><img data-src="/images/jfr/12.png" alt="img"></li></ul><h4 id="小对象分配导致的问题"><a href="#小对象分配导致的问题" class="headerlink" title="小对象分配导致的问题"></a>小对象分配导致的问题</h4><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote><p>某个请求会触发分配一个小对象放入类似于缓存的地方，但是这个小对象一直没有被回收，日积月累导致 FullGC 越来越频繁，最后<br>OutOfMemoryError</p></blockquote><ul><li>这种情况，可能导致 JFR 事件丢失，但是大概率不影响我们定位问题，因为是一连串的趋势可以看出来</li><li><img data-src="/images/jfr/13.png" alt="img"></li><li><img data-src="/images/jfr/14.png" alt="img"></li></ul><h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote><p>由于虚拟线程的引入，原来进程内处理请求的数量一定程度受限于 IO 以及线程数量，现在则是受限于 Java 对象堆内存大小，如何识别这种<code>背压</code>问题。</p></blockquote><h3 id="为什么抛出-OutOfMemoryError-的微服务最好下线重启？"><a href="#为什么抛出-OutOfMemoryError-的微服务最好下线重启？" class="headerlink" title="为什么抛出 OutOfMemoryError 的微服务最好下线重启？"></a>为什么抛出 OutOfMemoryError 的微服务最好下线重启？</h3><ul><li>因为包括 JDK 的源码在内，都没有在每一个分配内存的代码的地方考虑会出现 OutOfMemoryError ，这样会导致代码<br>状态不一致，例如 hashmap 的 rehash ，如果里面某行抛出 OutOfMemoryError ，前面更新的状态就不对了。</li><li>还有其他很多库，就不用说了，都很少有 catch Throwable 的，大部分是 catch Exception 的。并且，在每一个分配内<br>存的代码的地方考虑会出现 OutOfMemoryError 也是不现实的，所以为了防止 OutOfMemoryError 带来意想不到的<br>一致性问题，还是下线重启比较好。</li></ul><h3 id="如何实现抛出-OutOfMemoryError-的微服务下线重启？"><a href="#如何实现抛出-OutOfMemoryError-的微服务下线重启？" class="headerlink" title="如何实现抛出 OutOfMemoryError 的微服务下线重启？"></a>如何实现抛出 OutOfMemoryError 的微服务下线重启？</h3><ul><li>一般通过 -XX:OnOutOfMemoryError&#x3D;”&#x2F;path&#x2F;to&#x2F;script.sh” 指定脚本，脚本执行<ul><li>微服务的下线</li><li>微服务的重启(可以依赖k8s)</li></ul></li><li>针对 spring boot ，可以考虑开启允许本地访问 &#x2F;actuator&#x2F;shutdown 来关闭微服务（有群友反应抛出<br>OutOfMemoryError 的时候调用这个会卡死，这是因为前面说的原因，你可能开启了<br>HeapDumpOnOutOfMemoryError 导致的）， k8s 会自动拉起一个新的。<ul><li>因为<code>HeapDump</code>需要进入安全点，所有线程都 STW 了，导致k8s健康检查失败，从而k8s会自动拉起一个新的，导致dump失败</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;OutOfMemoryError&quot;&gt;&lt;a href=&quot;#OutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;OutOfMemoryError&quot;&gt;&lt;/a&gt;OutOfMemoryError&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多情况会导致 Java 应用抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/265039643&quot;&gt;参考 StackOverflowError 与 OutOfMemoryError&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="OOM" scheme="https://taeyang0126.github.io/tags/OOM/"/>
    
    <category term="Heap Dump" scheme="https://taeyang0126.github.io/tags/Heap-Dump/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation Outside TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/4.jvm-yu-jfr-shi-jian-object-allocation-outside-tlab/posts/undefined/</id>
    <published>2025-02-22T06:25:52.000Z</published>
    <updated>2025-02-22T06:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationOutsideTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation Outside TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径三</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径三分配的线程的名称</li><li>Allocation Size：触发路径三分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径三分配的对象类型</li><li>线程栈：发生路径三的线程栈，默认是采集的<br><img data-src="/images/jfr/07.png" alt="img"></li></ul><h3 id="编写代码模拟内存泄漏业务"><a href="#编写代码模拟内存泄漏业务" class="headerlink" title="编写代码模拟内存泄漏业务"></a>编写代码模拟内存泄漏业务</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocOutsideTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationOutsideTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟正常业务运行分配对象</span></span><br><span class="line">      runBiz(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Start to create OOM&quot;</span>);</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM，看看 Allocation  Outside TLAB 是否可以捕捉到</span></span><br><span class="line">      runOOM(<span class="literal">true</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runBiz</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟正常业务运行，三个线程并发分配对象，朝生夕死</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">bizRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              objects.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">              <span class="keyword">if</span> (objects.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                  objects.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;biz-&quot;</span> + i)</span><br><span class="line">                      .unstarted(bizRunnable);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(bizRunnable);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                  threads[i].interrupt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOOM</span><span class="params">(<span class="type">boolean</span> virtualThreadFlag)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 模拟并发向 ConcurrentHashMap 分配对象，但是不触发 OOM</span></span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">      Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">oomRun</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">              map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (virtualThreadFlag) &#123;</span><br><span class="line">              threads[i] = Thread.ofVirtual().name(<span class="string">&quot;oom-&quot;</span> + i)</span><br><span class="line">                      .unstarted(oomRun);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(oomRun);</span><br><span class="line">          &#125;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">          threads[i].join();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否建议开启这个事件的采集"><a href="#是否建议开启这个事件的采集" class="headerlink" title="是否建议开启这个事件的采集"></a>是否建议开启这个事件的采集</h3><ul><li>建议开启<ul><li>上面提到的Java内存分配路径，对于一般的JVM应用，<code>TLAB</code>内分配的量远大于申请新的TLAB分配的量，同时申请新的TLAB的量又远大于在TLAB外分配的量。除非你的应用分配大量的大对象，否则这个事件发生的应该比较少</li><li>对于一般的JVM应用，建议还是开启这个事件的采集，这样能采集到在你应用的所有大对象分配。只要你的应用不是大对象分配过多，这个事件的采集对于性能的影响应该是可以接受的。</li><li>路径三分配一般会包含核心问题点：<ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li></ul></li><li>与其他哪些事件是否有重合<ul><li><code>Object Allocation Sample</code>: 虽然 Object Allocation Sample 官方默认开启，但是对于大部分小对象朝生夕死的应用，其实更应该开启 Object Allocation Outside TLAB，而不是Object Allocation Sample。大部分应用，采集到的 Object Allocation Outside TLAB 会比默认的 Object Allocation Sample 少很多很多，性能消耗小很多很多。建议将 Object Allocation Sample 的采样率调很低，主要用于看意向不到的对象分配。</li><li><code>Allocation Requiring GC 以及 ZAllocation Stall</code>: 后续分析这些事件我们会看到，有内存泄漏嫌疑的对象分配相关的对象分配路径，基本上很少会被这两个事件以及 Object Allocation Outside TLAB 采集到</li></ul></li></ul><h3 id="这个事件适合定位什么问题？"><a href="#这个事件适合定位什么问题？" class="headerlink" title="这个事件适合定位什么问题？"></a>这个事件适合定位什么问题？</h3><ul><li>大对象分配：适合度70%<ul><li>对于大于TLAB大小的对象，如果分配成功一定可以采集到</li><li>对于大于TLAB最大浪费比例的对象，分配成功有概率可以采集到，因为有一部分在TLAB内分配成功</li><li>这个<code>只会采集分配成功</code>的对象，对于大对象分配，如果触发 <code>OutOfMemoryError</code> 代表分配失败，那采集不到</li><li>比如前面的代码示例，可以看到 HashMap 不断扩容，但是如果扩容触发 OutOfMemoryError，那这次就采集不到，但是通过前面的事件也能推测出来</li></ul></li><li>Java 堆对象内存泄漏: 适合度50%。针对不断分配小对象并且不释放的场景比较合适。比如多线程不断向一个 ConcurrentHashMap 塞入对象，但是不释放，这个事件可以采集 ConcurrentHashMap 在不断扩容。</li><li><code>意想不到的大对象分配</code>: 适合度100%。可以定期回顾下这个事件的采集，看看有没有意想不到的大对象分配，以及是否可以优化，或者有利于加深对于JDK的理解</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Type(JVM,JDK内部唯一标识，用于jfr配置): &lt;code&gt;jdk.ObjectAllocationOutsideTLAB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Label(Event Type，用于显示): Object Allocation Outside TLAB&lt;/li&gt;
&lt;li&gt;Category(用于分类显示): Java Application&lt;/li&gt;
&lt;li&gt;事件从哪个版本引入？&lt;ul&gt;
&lt;li&gt;Java11：即一开始就存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;埋点事件：即满足某些条件会触发的采集事件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM内部事件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此事件对应 &lt;a href=&quot;https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D&quot;&gt;Java对象分配过程&lt;/a&gt; 中的&lt;code&gt;路径三&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-Java Application/Object Allocation In New TLAB</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jfr/3.jvm-yu-jfr-shi-jian-object-allocation-in-new-tlab/posts/undefined/</id>
    <published>2025-02-22T06:20:52.000Z</published>
    <updated>2025-02-22T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><p><img data-src="/images/jfr/04.png" alt="img"><br><img data-src="/images/jfr/05.png" alt="img"></p><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><ul><li>Type(JVM,JDK内部唯一标识，用于jfr配置): <code>jdk.ObjectAllocationInNewTLAB</code></li><li>Label(Event Type，用于显示): Object Allocation In New TLAB</li><li>Category(用于分类显示): Java Application</li><li>事件从哪个版本引入？<ul><li>Java11：即一开始就存在</li></ul></li><li>事件类型<ul><li><code>埋点事件：即满足某些条件会触发的采集事件</code></li><li><code>JVM内部事件</code></li></ul></li><li>此事件对应 <a href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/?highlight=%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D">Java对象分配过程</a> 中的<code>路径二</code></li></ul><h3 id="jfc配置"><a href="#jfc配置" class="headerlink" title="jfc配置"></a>jfc配置</h3><ul><li>default.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Profiling.jfc 配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">name</span>=<span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">control</span>=<span class="string">&quot;gc-enabled-high&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;stackTrace&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件字段"><a href="#事件字段" class="headerlink" title="事件字段"></a>事件字段</h3><ul><li>Event Thread：发生路径二分配的线程的名称</li><li>Allocation Size：触发路径二分配的对象大小（实际占用，考虑了对象对其）</li><li>Object Class：触发路径二分配的对象类型</li><li>TLAB Size：触发路径二分配，申请新的TLAB的大小</li><li>线程栈：发生路径二的线程栈，默认是采集的<br><img data-src="/images/jfr/06.png" alt="img"></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAllocInNewTLAB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于字节数组对象头占用16字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_ARRAY_OVERHEAD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 测试的对象大小是KB</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OBJECT_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 字节数组对象名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BYTE_ARRAY_CLASS_NAME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>].getClass().getName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[] 会被全部省略，只剩最后一次的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;jdk.ObjectAllocationInNewTLAB&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">      <span class="comment">// 初始化jfr记录</span></span><br><span class="line">      <span class="type">Recording</span> <span class="variable">recording</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Recording</span>();</span><br><span class="line">      recording.enable(EVENT_TYPE);</span><br><span class="line">      <span class="comment">// JFR 记录启动</span></span><br><span class="line">      recording.start();</span><br><span class="line">      <span class="comment">// 强制 fullgc 防止程序接下来发生 gc</span></span><br><span class="line">      <span class="comment">// 同时可以区分初始化带来的其他线程的TLAB相关的日志</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小1KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 强制 fullgc 回收所以 TLAB</span></span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line">      <span class="comment">// 分配对象，大小100KB</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[OBJECT_SIZE * <span class="number">100</span> - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">      &#125;</span><br><span class="line">      whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 jfr 记录到一个文件</span></span><br><span class="line">      <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath(),</span><br><span class="line">              <span class="string">&quot;recording-&quot;</span> + recording.getId()</span><br><span class="line">                      + <span class="string">&quot;-pid&quot;</span></span><br><span class="line">                      + ProcessHandle.current().pid()</span><br><span class="line">                      + <span class="string">&quot;.jfr&quot;</span></span><br><span class="line">      ).toPath();</span><br><span class="line">      recording.dump(path);</span><br><span class="line">      <span class="comment">// 统计事件类型</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf1KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">countOf100KBObjectAllocationInNewTLAB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 读取文件中的所有 JFR 事件</span></span><br><span class="line">      <span class="keyword">for</span> (RecordedEvent event : RecordingFile.readAllEvents(path)) &#123;</span><br><span class="line">          <span class="comment">// 获取分配的对象类型</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> event.getString(<span class="string">&quot;objectClass.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确保分配类型是byte</span></span><br><span class="line">          <span class="keyword">if</span> (BYTE_ARRAY_CLASS_NAME.equals(className)) &#123;</span><br><span class="line">              <span class="type">RecordedFrame</span> <span class="variable">recordedFrame</span> <span class="operator">=</span> event.getStackTrace().getFrames().get(<span class="number">0</span>);</span><br><span class="line">              <span class="comment">// 同时必须是main方法分配的对象，并且是java堆栈中的main方法</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                      recordedFrame.isJavaFrame()</span><br><span class="line">                              &amp;&amp; <span class="string">&quot;main&quot;</span>.equalsIgnoreCase(recordedFrame.getMethod().getName())</span><br><span class="line">              ) &#123;</span><br><span class="line">                  <span class="comment">// 获取分配对象大小</span></span><br><span class="line">                  <span class="type">long</span> <span class="variable">allocationSize</span> <span class="operator">=</span> event.getLong(<span class="string">&quot;allocationSize&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (EVENT_TYPE.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (allocationSize == OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf1KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allocationSize == <span class="number">100</span> * OBJECT_SIZE) &#123;</span><br><span class="line">                          countOf100KBObjectAllocationInNewTLAB++;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unexpected size of TLAB event&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(event);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;countOf1KBObjectAllocationInNewTLAB: &quot;</span> + countOf1KBObjectAllocationInNewTLAB);</span><br><span class="line">      System.out.println(<span class="string">&quot;countOf100KBObjectAllocationInNewTLAB: &quot;</span> + countOf100KBObjectAllocationInNewTLAB);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么针对大部分应用不建议开启这个事件的采集"><a href="#为什么针对大部分应用不建议开启这个事件的采集" class="headerlink" title="为什么针对大部分应用不建议开启这个事件的采集?"></a>为什么针对大部分应用不建议开启这个事件的采集?</h3><ul><li><code>路径二分配一般不是核心问题点</code><ul><li>分配大对象一般是路径三和路径四：大对象一般是数组，比如某个数据库请求拉取了太多数据，会尝试路径三和路径四分配</li><li>分配小对象，导致的内存泄漏，一般是将小对象放入类似于 <code>ConcurrentHashMap</code> 或者一个数组结构中导致的内存泄漏，<code>ConcurrentHashMap</code>在 Rehash 以及数组在扩容的时候，一般会分配比较大的数组对象，也是走路径三和路径四。</li></ul></li><li><code>对于大部分应用，没有啥必要性</code><ul><li>重新申请 TLAB 分配，对于热点线程来说，虽然不如TLAB内分配那么多，但是也是比较频繁的</li><li>如果重新申请 TLAB 分配的次数，和 TLAB 内分配的次数差不多，这才会是问题</li><li>但是 TLAB 的大小是根据线程的分配情况动态调整的，所以 TLAB 内的分配的次数会比较多，而重新申请 TLAB 分配的次数会比较少</li><li>所以这个事件的采集，对于大部分的应用来说，并不是很有必要</li></ul></li><li><code>性能损耗</code><ul><li>这个事件的采集，会捕获堆栈信息，堆栈信息是比较耗性能的，如果开启这个事件的采集，会导致性能损耗比较大。并且这个事件的采集也相对频繁</li></ul></li></ul><h3 id="哪种情况下才会考虑开启这个事件的采集"><a href="#哪种情况下才会考虑开启这个事件的采集" class="headerlink" title="哪种情况下才会考虑开启这个事件的采集?"></a>哪种情况下才会考虑开启这个事件的采集?</h3><ul><li>正常的应用场景下，不需要调整TLAB的配置参数。一般情况下，JVM会根据应用的情况自动调整TLAB的大小</li><li>如果确实怀疑TLAB的配置参数有问题，第一步是开启 Java Application -&gt; Allocation In New TLAB(jdk.ObjectAllocationInNewTLAB) 和 Java Application -&gt;  Allocation outside TLAB(jdk.ObjectAllocationOutsideTLAB)</li><li>确认有大量的 Object Allocation Outside TLAB 事件发生（一般在应用稳定之后，如果很多线程的 Object Allocation Outside TLAB 相对于 Allocation In New TLAB 大于 5%以上就需要调整 TLAB 相关参数了），然后再考虑是否需要调整 TLAB 的配置参数。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/jfr/04.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;/images/jfr/05.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    <category term="TLAB" scheme="https://taeyang0126.github.io/tags/TLAB/"/>
    
  </entry>
  
  <entry>
    <title>Java对象分配过程</title>
    <link href="https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/22/jvm/java-dui-xiang-fen-pei-guo-cheng/posts/undefined/</id>
    <published>2025-02-22T06:13:52.000Z</published>
    <updated>2024-02-24T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路径一-TLAB-内分配"><a href="#路径一-TLAB-内分配" class="headerlink" title="路径一 TLAB 内分配"></a>路径一 TLAB 内分配</h3><ul><li>需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配</li><li>这是大多数对象的分配路径</li></ul><h3 id="路径二-申请新的-TLAB-分配"><a href="#路径二-申请新的-TLAB-分配" class="headerlink" title="路径二 申请新的 TLAB 分配"></a>路径二 申请新的 TLAB 分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间</li><li>重新分配一个 TLAB，然后在新的 TLAB 中分配</li></ul><h3 id="路径三-TLAB-外分配"><a href="#路径三-TLAB-外分配" class="headerlink" title="路径三 TLAB 外分配"></a>路径三 TLAB 外分配</h3><ul><li>需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间</li><li>或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小</li><li>或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁</li><li>以上三种情况都会直接在堆上分配</li></ul><h3 id="路径四-分配前触发GC或者等待GC"><a href="#路径四-分配前触发GC或者等待GC" class="headerlink" title="路径四 分配前触发GC或者等待GC"></a>路径四 分配前触发GC或者等待GC</h3><ul><li>路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁</li><li>这种情况下，会 <code>触发GC</code>(serial&#x2F;parallel&#x2F;G1 GC) 或者<code>等待GC释放对象</code>(ZGC)</li><li>路基四如果太多，那其实可能是整体 Java 堆内存就设置的太小了，需要考虑扩容</li><li>如果用的是 SerialGC，ParallelGC，G1GC，那么路径四会产生 <code>Allocation Requiring GC</code></li><li>如果使用的是 ZGC，那么路径四会产生 <code>Z Allocation Stall</code></li><li>如果用的是 ShenandoahGC，路径四会导致 Degenerated GC，这个目前没有对应的 JFR 事件，可以通过 GC 相关的时间看到，但是目前看不到是哪个对象触发</li></ul><h3 id="为什么有个最大浪费空间？？"><a href="#为什么有个最大浪费空间？？" class="headerlink" title="为什么有个最大浪费空间？？"></a>为什么有个最大浪费空间？？</h3><ul><li>这是为了避免更有效的利用空间</li><li>假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择<ul><li>丢弃掉当前这个TLAB，去申请一个新的</li><li>不在当前这个TLAB上配置，去堆上分配</li><li>最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><ul><li>TLAB 是动态的，一般分配频繁的线程TLAB&#x3D;2M</li><li>每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;路径一-TLAB-内分配&quot;&gt;&lt;a href=&quot;#路径一-TLAB-内分配&quot; class=&quot;headerlink&quot; title=&quot;路径一 TLAB 内分配&quot;&gt;&lt;/a&gt;路径一 TLAB 内分配&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配&lt;/li&gt;
&lt;li&gt;这是大多数对象的分配路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;路径二-申请新的-TLAB-分配&quot;&gt;&lt;a href=&quot;#路径二-申请新的-TLAB-分配&quot; class=&quot;headerlink&quot; title=&quot;路径二 申请新的 TLAB 分配&quot;&gt;&lt;/a&gt;路径二 申请新的 TLAB 分配&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="对象分配" scheme="https://taeyang0126.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM与JFR事件-准备工作</title>
    <link href="https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/20/jfr/2.jvm-yu-jfr-shi-jian-zhun-bei-gong-zuo/posts/undefined/</id>
    <published>2025-02-20T06:13:52.000Z</published>
    <updated>2025-02-20T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&vd_source=3950f615078c921132561647ae6a1ddd">本系列参考张哥JFR全系列</a></li></ul><h2 id="为什么需要JFR"><a href="#为什么需要JFR" class="headerlink" title="为什么需要JFR?"></a>为什么需要JFR?</h2><h3 id="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式"><a href="#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式" class="headerlink" title="我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式"></a>我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 <code>OpenTelemetry</code> 标准的监控方式</h3><ul><li>arthas: 主要用于实时定位问题，必须有问题线程，必须复现才能定位，没法事后定位，如果有应用问题也可能挂载不上。<br>JFR可以实现从JVM启动开始一直持续采集监控与事后定位，即使应用有问题卡住，也基本能通过JFR定位。</li><li>APM 框架: 例如 micrometer，open-telemetry，Skywalking 等等，大部分基于 <code>Java Agent</code> 和侵入代码的方式结合实现，<br>这些对于JFR来说：<ul><li>这些框架没办法采集JVM层面的指标</li><li>JVM协调安全点，JVM卡住，Java应用有问题，CPU吃满等等，这些框架会受很大影响</li></ul></li></ul><h3 id="结合学习-JVM-JDK-的最佳方式"><a href="#结合学习-JVM-JDK-的最佳方式" class="headerlink" title="结合学习 JVM + JDK 的最佳方式"></a>结合学习 JVM + JDK 的最佳方式</h3><ul><li>JFR 有哪些事件，为啥要采集这些事件</li><li>采集这些事件的机制</li><li>搞懂上面的问题，基本从 JVM 到 JDK 的任意一个细节都搞懂了，比如：<ul><li>JVM GC 的时候有哪些阶段，每个阶段耗时与做了什么？看 GC 相关 JFR 事件</li><li>JVM Safepoint 是啥，有啥原因会进入 safePoint？看 Safepoint 相关 JFR 事件</li><li>JDK 中的 AQS 究竟基于啥，实现原理是啥？看 Thread Park 事件属性与对应线程栈</li></ul></li></ul><h2 id="JFR-如何实现高效"><a href="#JFR-如何实现高效" class="headerlink" title="JFR 如何实现高效"></a>JFR 如何实现高效</h2><ul><li><img data-src="/images/jfr/01.png" alt="img"></li></ul><h2 id="JFR-如何从-JVM-启动一开始监控到任意时候"><a href="#JFR-如何从-JVM-启动一开始监控到任意时候" class="headerlink" title="JFR 如何从 JVM 启动一开始监控到任意时候"></a>JFR 如何从 JVM 启动一开始监控到任意时候</h2><blockquote><p>突破 JFR 本身限制，不用 dumponexit，不用主动 dump</p></blockquote><ul><li>JFR 写入磁盘的 Data Chunk，默认在临时目录(<code>java.io.tmpdir</code>)，这个可以通过<br>JFR 配置限制<ul><li><code>maxage</code>：限制保留的 JFR 事件的最早时间</li><li><code>maxsize</code>：限制保留在本地磁盘临时文件的最大总大小</li></ul></li><li>Java 14开始，增加了 JFR Event Streaming 机制<ul><li>写入的临时文件不再是.part，而是.jfr，这样即使JMC无法解析，也可以使用jfr命令解析</li><li>java 14 引入定时任务定时（默认1s）执行 JFR Flush 将元数据刷入本地文件 Data Chunk，这样大概率最新的文件就是数据完整的，即可以被JMC解析</li></ul></li></ul><h3 id="k8s环境下怎么监控jfr"><a href="#k8s环境下怎么监控jfr" class="headerlink" title="k8s环境下怎么监控jfr"></a>k8s环境下怎么监控jfr</h3><blockquote><p>JFR 与日志是同等定位，其实就是简单结构化的日志。先通过 Grafana 看 Metrics 指标，之后通过少量上报 span 大概定位时间段以及出问题的实例，最后看对应时段的 JFR</p></blockquote><p>升级了 SpringBoot 3.x，升级后，全面改造了原来的 Sleuth 以及 Micrometer 监控，最新的 io.micrometer.observation.Observation 抽象将链路追踪以及指标监控（opentracing 和 opentelemetry 两个标准）结合，这样，我们就可以在链路追踪中，同时记录指标监控数据了。<br>并且，在此基础上，我们还加入了全局的 io.micrometer.observation.ObservationHandler，用于在 Observation start 的时候，生成 JFR 事件，在 stop 的时候 commit JFR 事件。这样我们就实现了通过一个 Observation：</p><ul><li>暴露指标监控数据到 &#x2F;actuator&#x2F;prometheus，供 Prometheus 采集，Grafana 展示</li><li>上报链路追踪数据到 Grafana Tempo</li><li>生成 JFR 事件，供 JDK Mission Control 分析</li></ul><p>为什么要这么做呢？</p><ul><li>指标数据是统计数据，是聚合数据，是一段时间内的数据，而链路追踪数据是实时数据，是每个请求的数据</li><li>但是像是链路追踪上报在生产上肯定不能 100% 上报（上报性能，还有成本考虑，以及查询的存储性能有限，成本不能太高），而是采样上报，这样就会导致链路追数据不全</li><li>JFR 是保留详细数据的好选择，保留在本地，只有发生问题需要排查的时候，事后按需获取就行。</li><li>这样，既节约了成本，又能及时报警，又能容易通过 Tempo 通过链路追踪数据定位出问题的实例和时间段，然后通过获取对应实例的 JFR 事件定位详细问题。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Java-17-以上的-JDK"><a href="#Java-17-以上的-JDK" class="headerlink" title="Java 17 以上的 JDK"></a>Java 17 以上的 JDK</h3><blockquote><p>Azul、Corretto、OpenJdk随意</p></blockquote><h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><blockquote><p>下载最新版本即可，即 JMC 9</p></blockquote><h3 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h3><blockquote><p><code>WhiteBox API</code> 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的API暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解JVM并调优参数</p></blockquote><ul><li>编译 WhiteBox API<ol><li>拉取 openjdk 源码</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 --filter=blob:none --sparse https://github.com/openjdk/jdk</span><br><span class="line">cd jdk</span><br><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout set test/lib/jdk/test/whitebox</span><br></pre></td></tr></table></figure><ol start="2"><li>新建 maven 空项目，将刚刚拉取的代码复制进去，执行 <code>maven package</code> 即可</li><li>将编译的 jar 包放在项目根目录，通过 maven 本地 system 依赖的方式将 jar 包加入依赖<br><img data-src="/images/jfr/02.png" alt="img"></li><li>不想自己构建可以使用 <a href="/files/jfr/whitebox-1.0-SNAPSHOT.jar">whitebox-1.0-SNAPSHOT.jar</a></li><li>编写测试代码<ul><li>代码</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWhiteBox</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            主要用于添加WhiteBox测试API的jar包，这个jar必须通过引导类加载器加载，因为它需要访问JVM内部功能，/a 表示append，将指定的jar追加到引导类路径末尾</span></span><br><span class="line"><span class="comment">            -Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            解锁JVM诊断选项，启用一些默认被禁用的诊断/调试选项，这是使用WhiteBox API的前提条件</span></span><br><span class="line"><span class="comment">            -XX:+UnlockDiagnosticVMOptions</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            启用WhiteBox测试API，WhiteBox API提供了访问JVM内部状态的能力</span></span><br><span class="line"><span class="comment">            -XX:+WhiteBoxAPI</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">            开启GC日志记录，输出带有gc标签的日志</span></span><br><span class="line"><span class="comment">            -Xlog:gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">WhiteBox</span> <span class="variable">whiteBox</span> <span class="operator">=</span> WhiteBox.getWhiteBox();</span><br><span class="line">        <span class="comment">// 获取 ReservedCodeCacheSize 这个 JVM flag 的值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">reservedCodeCacheSize</span> <span class="operator">=</span> whiteBox.getUintxVMFlag(<span class="string">&quot;ReservedCodeCacheSize&quot;</span>);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        <span class="comment">// 打印内存各项指标</span></span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        <span class="comment">// 执行 full GC</span></span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        <span class="comment">// 保持进程不退出，打印完整日志</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动VM Options</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xbootclasspath/a:/Users/wulei/IdeaProjects/learn/jfr/whitebox-1.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure><ul><li>执行结果，出现 NoSuchMethodError 错误没关系，因为打包的是最新的 whitebox，使用的jdk版本可能没有某些最新的api<br><img data-src="/images/jfr/03.png" alt="img"></li></ul></li></ol></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1CBKLe9ECN?spm_id_from=333.788.videopod.sections&amp;vd_source=3950f615078c921132561647ae6a1ddd&quot;&gt;本系列参考张哥JFR全系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么需要JFR&quot;&gt;&lt;a href=&quot;#为什么需要JFR&quot; class=&quot;headerlink&quot; title=&quot;为什么需要JFR?&quot;&gt;&lt;/a&gt;为什么需要JFR?&lt;/h2&gt;&lt;h3 id=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot;&gt;&lt;a href=&quot;#我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于-OpenTelemetry-标准的监控方式&quot; class=&quot;headerlink&quot; title=&quot;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 OpenTelemetry 标准的监控方式&quot;&gt;&lt;/a&gt;我们需要一个持续的，低消耗的JVM层面与JDK层面的类似于 &lt;code&gt;OpenTelemetry&lt;/code&gt; 标准的监控方式&lt;/h3&gt;</summary>
    
    
    
    <category term="JFR" scheme="https://taeyang0126.github.io/categories/JFR/"/>
    
    
    <category term="JVM" scheme="https://taeyang0126.github.io/tags/JVM/"/>
    
    <category term="JFR" scheme="https://taeyang0126.github.io/tags/JFR/"/>
    
    <category term="监控" scheme="https://taeyang0126.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 单元测试最佳实践</title>
    <link href="https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/"/>
    <id>https://taeyang0126.github.io/2025/02/19/spring/springboot-dan-yuan-ce-shi-zui-jia-shi-jian/posts/undefined/</id>
    <published>2025-02-19T15:55:22.000Z</published>
    <updated>2025-02-19T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>标题党，各位大佬手下留情<del>_</del></p></blockquote><p>单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)</p><blockquote><p>!! 笔者使用的是 2.6.6 版本</p></blockquote><p><img data-src="/images/spring/boot/01.png" alt="image.png"></p><blockquote><p>SpringBoot 常规单元测试</p></blockquote><p>常规的单元测试如下图所示，这样会将整个容器启动起来，需要加载各种各样的外部化配置，耗时时间长且容易失败；大部分场景下我们只是测试某个功能，只需加载部分组件即可</p><p><img data-src="/images/spring/boot/02.png" alt="image.png"></p><blockquote><p>SpringBoot 单元测试指定加载配置</p></blockquote><p>为了解决以上问题，我们可以指定配置进行加载，避免加载整个容器；如下图所示，只会加载基础的Spring容器以及IdGenerator，大大提升了单测的效率</p><p><code>推荐学习</code><a href="https://github.com/chanjarster/spring-test-examples">spring-test-examples</a></p><p><img data-src="/images/spring/boot/03.png" alt="image.png"></p><blockquote><p>SprongBoot 固定组件单元测试</p></blockquote><p>以上指定配置加载已经基本满足了我们的需求(加载部分组件)；但在日常开发中，要求每次单测都指定加载的配置本身就是个伪命题，一是因为本身开发可能对于需要加载的配置不太熟悉，二是因为这种重复的工作过于啰嗦；那么我们该怎么优化这个流程呢？</p><ol><li>要简化配置，第一步就是禁用所有自动加载的配置</li></ol><ul><li>仿造<code>SpringBootTest</code>的注解，构建一个元注解，禁用所有自动加载的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(EmptyTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(EmptyTypeExcludeFilter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestEmptyEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTestContextBootstrapper</span> <span class="keyword">extends</span> <span class="title class_">SpringBootTestContextBootstrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getProperties(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestEmptyEnvironment</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">        <span class="keyword">return</span> (annotation != <span class="literal">null</span>) ? annotation.properties() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyTypeExcludeFilter</span> <span class="keyword">extends</span> <span class="title class_">AnnotationCustomizableTypeExcludeFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEmptyEnvironment annotation;</span><br><span class="line"></span><br><span class="line">    EmptyTypeExcludeFilter(<span class="keyword">final</span> Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, TestEmptyEnvironment.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ComponentScan.Filter[] getFilters(<span class="keyword">final</span> FilterType type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> INCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.includeFilters();</span><br><span class="line">            <span class="keyword">case</span> EXCLUDE:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.annotation.excludeFilters();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported type &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.annotation.useDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getDefaultIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getComponentIncludes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>TestEmptyEnvironment</strong>: 禁用所有自动配置，只加载最基础的spring容器</li><li><strong>EmptyTestContextBootstrapper</strong>: 重写properties加载方法，将TestEmptyEnvironment注解中的properties属性加载到容器中</li><li><strong>EmptyTypeExcludeFilter</strong>: 容器过滤</li><li><strong>@OverrideAutoConfiguration(enabled &#x3D; false)</strong>: 禁用自动配置加载，如果是boot2.2.x之前的版本，此配置不会生效，可以使用 @ContextConfiguration(classes &#x3D; EmptyConfiguration.class) 替代，其中 EmptyConfiguration 表示空的配置</li></ul><ol start="2"><li>要简化单测的流程，就需要将重复的工作声明化，即使用注解完成自动配置的大部分工作；具体需要如何处理呢，我们可以将常用单测注解进行声明化处理，编写单测时只需引入对应组件的注解即可</li></ol><ul><li><strong>service</strong> 仅对service进行单测，可声明以下注解，构建一个简单的spring容器即可，需要测试哪个service，直接Import加载即可；若此service中有其他注解，可进行mock处理，这里不再赘述mock的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TestService</span></span><br><span class="line"><span class="comment">// 若是boot2.2.x之后这里不再需要，因为元注解中已经增加了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// @RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;</span></span><br><span class="line"><span class="meta">        LabelService.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LabelService labelService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>redis</strong> 对redis进行单测，需要引入redis相关的自动配置，如下代码中的 RedisTestAutoConfiguration 类，不同项目使用的框架不同，自动装配也不相同，这里需要根据项目进行个性化设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        RedisTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRedis &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        LettuceAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRedis</span></span><br><span class="line"><span class="comment">// 优先级最高，可覆盖项目中的配置文件</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;</span></span><br><span class="line"><span class="meta">        &quot;redis.host=localhost:6379&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getRedisHost</span><span class="params">()</span> &#123;</span><br><span class="line">        assertThat(redisClient)</span><br><span class="line">        .isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>kafka</strong> kafka单测也和redis一样，进行个性化配置即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@TestEmptyEnvironment</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaTestAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestKafka &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        KafkaAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTestAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其他组件也都是一样的做法，笔者暂时用到的组件如下<ul><li>feign</li><li>kafka</li><li>mongodb</li><li>redis</li><li>service</li><li>controller</li><li>mybatis</li></ul></li></ul><p>tips: 如果不知道组件需要加载哪些配置，可通过完整启动项目打印所有装配的配置，然后再筛选需要的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderPrint</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;标题党，各位大佬手下留情&lt;del&gt;_&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单测是十分重要的，既能提升代码健壮性，又能降低代码重构的风险；但在当下国内环境中，单测又是不现实的，单测耗费的时间可能比开发还多，这对老板来说显然是不能接受的(万恶的资本家)；关键业务缺少单测不仅提高了测试回归的难度，也成为了代码重构的拦路虎，看着那一堆屎山代码，要是没有单测的保障，你敢去重构吗!!(不怕死的当我没说)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;!! 笔者使用的是 2.6.6 版本&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/categories/spring-boot/"/>
    
    
    <category term="spring boot" scheme="https://taeyang0126.github.io/tags/spring-boot/"/>
    
    <category term="单元测试" scheme="https://taeyang0126.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
