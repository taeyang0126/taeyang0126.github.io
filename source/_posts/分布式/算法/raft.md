---
title: raft
tags:
  - 分布式
  - 算法
  - raft
categories:
  - 分布式
abbrlink: 17349
date: 2025-02-09 19:50:22
---



## Raft 的核心目标和基本工作原理

核心目标：

- 在分布式系统中达成共识，实现强一致性。
- 在保证一致性的基础上进行可靠的数据复制。

基本工作原理：

- 领导者选举：使用随机化的选举超时机制。
- 日志复制：采用 WAL（Write-Ahead Logging）方式。
- 安全性保证：确保只有包含全部已提交日志的节点才能成为领导者。
- 成员管理：支持动态的成员变更。

关键特性：

- 将问题分解为相对独立的子问题：领导者选举、日志复制和安全性。
- 使用 term（任期）作为逻辑时钟，管理整个集群的时序。
- 要求多数节点确认以提交日志，保证数据安全性。

## Term 的概念和作用

定义：

- Term 是 Raft 中的逻辑时钟概念，表示领导者的任期。
- 每个 term 由一次选举开始，可能有一个领导者，也可能没有（选举失败）。

作用：

- 标识集群的逻辑时间，用于检测过时的信息。
- 在选举中确保新领导者包含所有已提交的日志。
- 在网络分区恢复后，帮助识别和废除旧的领导者。
- 在所有 Raft 的决策过程中起关键作用，如日志复制、提交判断等。

更新机制：

- 节点在开始新选举时增加自己的 term。
- 节点在收到包含更高 term 的消息时更新自己的 term。

## 领导者选举过程

触发条件：

- Follower 在选举超时时间内没有收到来自 Leader 的心跳。

选举步骤：

- Follower 转变为 Candidate，增加当前 term，投票给自己。
- 发送 RequestVote RPC 给其他节点，包含自己的 term 和最后一条日志的 index 和 term。
- 其他节点根据以下规则决定是否投票： 
  - 如果接收到的 term 大于自己的 term，则更新自己的 term 并投票。
  - 如果 term 相同，比较日志的新旧程度（先比较最后一条日志的 term，再比较 index）。
  - 如果接收到的 term 小于自己的 term，拒绝投票并返回自己的 term。
- 如果 Candidate 收到多数选票，则成为新的 Leader。
- 如果在等待过程中收到更高 term 的消息，则转为 Follower。

防止选票分裂：

- 使用随机化的选举超时时间，减少多个节点同时发起选举的可能性。

预选票机制（优化）：

- 在正式选举前进行预选票阶段，不增加 term。
- 有助于防止网络分区后的不必要 term 增加。

## 日志一致性保证

Log Matching Property: 

- 如果两个日志在相同索引位置的日志条目具有相同的 term，则这两个日志在该索引之前的所有条目都相同。

实现机制：

- Leader 在 AppendEntries RPC 中包含 prevLogIndex 和 prevLogTerm。
- Follower 在接收新日志前，检查自己在 prevLogIndex 位置的日志条目的 term 是否与 prevLogTerm 匹配。
- 如果匹配，则接受新的日志条目；如果不匹配，则拒绝并返回冲突信息。
- Leader 收到拒绝后，递减 nextIndex 并重试，直到找到匹配点。

这种机制通过递归性质保证了所有之前的日志也是一致的。

## commitIndex 和 lastApplied

commitIndex: 

- 主要在 Leader 上维护。
- 表示最后一个已知被提交（即，被多数节点复制）的日志条目的索引。
- 更新规则：Leader 找出 matchIndex 中超过半数节点都大于等于的最大值，且对应日志的 term 等于当前 term。

lastApplied: 

- 在所有节点上维护。
- 表示最后一个被应用到状态机的日志条目的索引。
- 更新规则：成功将日志应用到状态机后更新。

关系：lastApplied ≤ commitIndex

Follower 更新 commitIndex：通过 Leader 的 AppendEntries RPC 中的 leaderCommit 字段更新。

## 网络分区（脑裂）的处理

防止脑裂的核心机制：

- 要求多数节点的同意才能选举 Leader 和提交日志。

具体表现：

- 在网络分区情况下，只有包含多数节点的分区能选出新 Leader。
- 少数派分区可能会不断尝试选举，但无法获得多数选票，因此不会成功。
- 当网络分区恢复时，较高 term 的 Leader 会使其他节点回归到 Follower 状态。

优化：使用预选票机制减少不必要的 term 增加。

## 成员变更过程

两阶段过程：

第一阶段（联合共识）：

- Leader 创建包含新旧配置的特殊日志条目（C_old+C_new）。
- 复制这个日志到集群中的多数节点（包括新旧配置中的节点）。
- 在这个阶段，所有决策（日志提交、选举）需要同时满足新旧配置的多数要求。

第二阶段（新配置）：

- 当第一阶段的日志被提交，且新节点已经充分同步后，Leader 创建只包含新配置的日志条目（C_new）。
- 当这个新配置日志被提交后，集群完全切换到新配置。

设计原因：

- 确保在配置变更过程中不会出现决策冲突。
- 允许新节点在参与集群决策之前有时间同步日志。
- 保证在任何时候都有一个明确的、一致的集群配置。

## 日志压缩

快照机制：

- 定期创建包含完整状态机状态的快照。
- 创建快照后，可以安全地丢弃该点之前的所有日志。
- 快照包含：最后应用的日志的 index 和 term，最新的集群配置。

用途：

- 减少存储空间使用。
- 加速重启过程。
- 帮助落后太多的节点快速赶上（通过直接发送快照）。

针对特定应用的优化：

- 对于 KV 存储，可以只保留每个 key 的最新值。

## 读操作优化

挑战：确保读取的是最新数据。

优化策略：

- Leader 读取： 
  - Leader 在响应读请求前确认自己仍是当前 Leader（通过与多数节点通信）。
  - 使用租约机制减少确认开销。
- Follower 读取（非强一致性）： 
  - 直接从 Follower 读取，用于对一致性要求不高的场景。
  - 可能读到稍旧的数据，但减轻了 Leader 的负担。
- 读索引（Read Index）： 
  - Leader 记录当前的 commitIndex，确认 leadership，然后等待 applyIndex 赶上该 commitIndex。
- 租约读（Lease Read）： 
  - Leader 维护一个租约，在租约内不与 Followers 通信即可响应读请求。

## Raft vs Paxos

设计理念：

- Raft 设计目标是易于理解和实现。
- Paxos 更加理论化和通用。

结构：

- Raft 将问题分解为领导选举、日志复制等子问题。
- Paxos 是一个更单一的协议。

领导机制：

- Raft 有明确的领导者选举过程。
- Paxos 中领导角色不那么明确。

日志特性：

- Raft 保证日志是连续的。
- Paxos 允许日志中有"空洞"。

实现复杂度：

- Raft 通常更容易实现和调试。
- Paxos 的正确实现往往更复杂。
