---
title: 抓包相关xxx
tags:
  - linux
  - 网络
  - tcp
  - 抓包
categories:
  - 网络
abbrlink: 17349
date: 2025-02-09 17:50:22
---



- 查看路由表信息
  - 可以显示数据包的路由规则，告诉我们去往不同目标IP时会使用哪个网卡，方便指定网卡抓包
  - `netstat -nr` 所有系统均可使用，n表示以数字形式显示地址和端口，r表示route
  - `ip route` linux下使用，替代 netstat -r
  - `ss`linux下使用，替代 netstat 
- 确认号(ack)计算规则
  - 普通数据包：ack = 对方seq + len
  - SYN/FIN包：ack = 对方seq + len + 1
  - "我已经收到到这个位置的数据了"  "你下次就从这个位置继续发"
- seq 
  - 不是包的唯一标识，而是数据流的位置标记
  - 表示"我之后的数据会从这个位置开始发"
  - 下一个包的seq等于对端确认的ack，seq、ack本质上都是流的序号，ack表示对端确认到了这个位置，自然我端需要从此为止发送数据
- 某些场景下挥手时 FIN+ACK可能合并为一个包
  - 延迟确认的场景下，FIN+ACK可能合并为一个包
- LSO
  - 传输层不负责拆包处理，而是将数据直接传递给网卡，交给网卡负责分段
  - 传统网络是应用层把数据交给TCP层，TCP层根据MSS大小进行分段（cpu负责）
  - 启用LSO之后，TCP层直接把数据块传给网卡， 让网卡负责分段工作
  - 优点在于节省了cpu资源，缺点在数据发送方抓包的时候可能看到一个分段前，超过MSS的大包
- 数据包分段
  - 传输层分段(TCP分段)
    - tcp会根据mss进行分段，一般mss的长度是MTU-40，同时会将IP层的flags打上DF标记避免ip分片
    - tcp层分段的好处是支持超时重传和快速重传等机制保证可靠性
    - 有时候TCP头不止20字节，所以会侵占一些MSS的空间，比如用作 TCP Options，这样传输层真正用来承载的字节数 = MTU(1500) - 20(ip header) - 20(tcp header) - length(Tcp Options)
    - TCP连接必须进行三次握手，在前两个握手包中双方互相声明自己的MSS，双方适配得到共识的MTU，这样就不会出现客户端发送的MTU大于接收方的情况
  - 网络层分段(UDP)
    - ip层分片，丢失一个分片包就需要整个包重传
    - 使用udp协议若不在应用层做好分段处理，就可能由于分片丢包重传导致性能地下
    - Udp 没有MSS的概念，全部数据移交给网络层
  - 接收方如何重组分段包
    - 将ID相同的分片按照off值（偏移量）进行重组
    - 接收方通过Flags下面的的 `More Fragments = 0` 判断是不是最后一个分片，如果是最后一个分片了，可以开始重组分片了
- Windos Scale
  - TCP协议中只给接收窗口(win)预留了16个比特，意味着最大只能表示 65535 字节
  - 随着网络带宽越来越大，预留的16个比特已经不够用了，RFC 1323 提供了一个创意，在三次握手时双方都把一个叫 `Windows Scale` 的值告知对方，对方收到后会把这个值当做2的指数，算出来的值再作为接收窗口的系数
  - 假设 Windos Scale = 3，win = 10，那么实际的接收窗口 = 10 * 2^3 = 80
  - ！！如果在三次握手之后才开始抓包，就无法获取到Windos Scale，只能显示出没有系数的大小，这是不准确的
- TTL(Time to Live)
  - TTL 初始值一般为64
  - RFC 1812 一个网络包的TTL每减去1就意味着它经过一次路由
  - TTL一般可以用来验证网络拓扑，比如当前收到的包具体是哪个服务器发出的

### TCP 流量控制与窗口机制

1. #### TCP头部Win字段

- Win字段表示发送方的接收窗口大小(rwnd)
- 告知对方自己还能接收多少数据
- 动态变化：Win = 接收缓冲区大小 - 已接收但未处理的数据量

#### 2.  流量控制机制

##### 2.1   接收窗口(rwnd)

- 通过TCP头部Win字段告知对方
- 反映接收方的处理能力
- 防止接收方缓冲区溢出
- 由应用程序处理速度决定

##### 2.2  拥塞窗口(cwnd)

![img](/images/socket_02_11.jpeg)

![img](/images/socket_02_12.png)

- 发送方内部维护，不需要告知对方
- 反映网络的承载能力
- 防止网络拥塞
- 由网络状况动态调整
- 拥塞窗口可以通过估算在途字节数进行计算，在途字节数 = seq + len - ack，简单来说就是发送方这边发送过去的字节数减去对端ack的字节数得到在途字节数，那么拥塞窗口怎么确定最后一个数据包呢，找到第一个发生重传的数据包，根据此数据包进行过滤，得到最后一个发送的数据包以及ack包，就能计算在途字节数了，当然这种方式只是估算，需要采样几次，去最低的拥塞点作为拥塞窗口

##### 2.3 实际发送控制

> 发送窗口大小 = min(对方通告的win, 本地的cwnd)
