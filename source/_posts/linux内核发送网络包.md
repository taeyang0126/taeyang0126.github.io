---
title: linux内核发送网络包
tags:
  - linux
  - 网络
  - socket
categories:
  - 网络
abbrlink: 17349
date: 2025-02-09 17:47:22
---

### 网络发送过程汇总

![img](/images/socket_02_10.png)

- 上图中网络设备子系统在发送网络包的时候，是通过while循环不断地从队列中取出skb并进行发送。这时候其实都是占用的用户进程的系统态时间(sy)，只有当`quota` 用尽或者其他进程需要cpu时才触发软中断进行发送。
- 网络设备子系统的队列和网卡驱动的 Ring Buffer 实际上是两个不同的概念
  - 网络设备子系统的队列是在内核网络栈中的软件队列，当数据包（skb）准备发送时，它首先被放入这个软件队列，这个队列主要用于流量控制、QoS（服务质量）管理等目的
  - 网卡驱动的 Ring Buffer是一个硬件级别的队列，Ring Buffer 存储的不是完整的 skb，而是指向内存中数据包的描述符。
  - Ring Buffer 包含两个主要的数组，两个数组相同index下对应存储了同一个skb，只不过内核需要的是skb，网卡需要具体的物理地址，通过此设计当网卡发送完毕后，内核通过同一个index能定位到skb从而进行清理等工作。
    1. 描述符数组（Descriptor Ring）主要是网卡使用
    2. 缓冲区信息数组（Buffer Info Array）主要是内核使用
- 在监控内核发送数据消耗的cpu时，应该将sy、si都考虑进来
  - 网络包发送过程中，用户进程(在内核态)完成了绝大部分的工作，甚至连调用驱动的工作都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。
  - 只有一少部分情况才会触发软中断（NET_TX类型），由软中断ksoftirqd线程来发送。
- 在服务器上查看/proc/softirqs，为什么NET_RX比NET_TX大的多的多？
  - 当数据发送完毕后，通过硬中断的方式来通知驱动发送完成，但是硬中断无论是数据接收，还是发送完毕，触发的软中断都是NET_RX_SOFTIRQ。
  - 对于读来说，都是需要经过NET_RX软中断的，都走ksoftirqd内核线程，而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才发出NET_TX，让软中断上。

### 发送网络数据的时候都涉及哪些内存拷贝?

> 指待发送数据的内存拷贝

1. 第一次拷贝操作是在内核申请完skb之后，这时候会将用户传递进来的buffer里的数据内容都拷贝到skb。如果要发送的数据量比较大，这个拷贝操作开销不小。
2. 第二次拷贝操作是从传输层进入网络层的时候，每一个skb都会被克隆出来一个新的副本。目的是保留原始的skb，当网络发现对方没有返回ack的时候，还可以重新发送，以实现TCP中要求的可靠传输，不过这次只是浅拷贝，只拷贝skb描述符本身，所指向的数据还是复用的。
3. 第三次拷贝不是必须的，只有当IP层发现skb大于MTU时才需要进行。此时会再申请额外的skb，并讲究原来的skb拷贝为多个小的skb。
