---
title: MySQL
tags:
    - MySQL
    - 数据库
categories:
    - MySQL
abbrlink: 17349
date: 2025-02-10 19:52:22
---

- [《MySQL 是怎样运行的：从根儿上理解 MySQL》](https://relph1119.github.io/mysql-learning-notes/#/)

## 初识 MySQL


### 启动服务器程序

- **mysqld** 表示 mysql 服务器程序，运行这个可执行文件想可以直接启动一个 mysql 服务器进程，但这个可执行文件并不常用
- **mysqld_safe** 一个启动脚本，会间接调用 mysqld 并持续监控服务器的运行状态。当服务器进程出现错误时，还可以帮助重启服务器程序，另外，使用 mysqld_safe 启动 MYSQL 服务器程序时，它会将服务器程序的出错信息和其他诊断信息输出到错误日志，方便后期查找发生错误的原因（出错日志默认写到一个以 .err 为扩展名的文件中，该文件位于 mysql 的数据目录中）
- **mysqld.server** 也是一个启动脚本，会间接的调用 mysqld_safe。在执行 mysql.server 时，在后面添加 start 参数就可以启动服务器程序了。需要注意的是，mysqld.server 文件其实是一个链接文件，它对应的时机文件是 ../support-files/mysql.server
- **mysqld_multi** 在一台计算机上运行多个服务器实例

{% mermaid %}
flowchart LR
  A[mysqld.server]
  B[mysql_safe]
  C[mysqld]

  A-->|启动|B-->|监控并启动|C
{% endmermaid %}

### 启动客户端程序

#### TCP/IP 

- mysql -h127.0.0.1 -uroot -P3307 -p

#### UNIX 套接字

> 服务端进程与客户端进程运行在一台机器上，使用 UNIX 域套接字进行进程间通信。默认 mysql 服务端启动的套接字文件是 /tmp/mysql.sock

- mysql -S /tmp/mysql.sock
- mysql --socket /tmp/mysql.sock

### 启动多个 mysql 服务端进程

#### 配置文件

```C
[mysqld]
# 端口
port=3307
# 监听的套接字文件
socket=/tmp/mysql.sock2
# 数据文件地址
datadir=/opt/homebrew/var/mysql3307
# 指定进程文件，好处是可以快速根据此文件定位到进程是否启动 cat /opt/homebrew/logs/mysql/mysqld3307.pid
pid-file=/opt/homebrew/logs/mysql/mysqld3307.pid
# 日志文件
log-error=/opt/homebrew/logs/mysql/mysqld3307.log
# mysqlx 端口
mysqlx_port=33070
```

#### 初始化 mysql 数据目录

- `--initialize`： 这个选项告诉 MySQL 创建一个新的数据目录结构，包括必要的系统表。它会生成一个随机的临时 root 密码
- `--user=mysql`： 指定哪个系统用户将拥有这些新创建的文件。通常，这应该是运行 MySQL 服务器的用户
- `--datadir=/opt/homebrew/var/mysql3307`： 这指定新数据目录的位置

```Bash
mysqld --initialize --user=mysql --datadir=/opt/homebrew/var/mysql3307
```

#### 启动服务端程序

```Bash
mysqld --defaults-file=/opt/homebrew/etc/my_3307.cnf
```

#### 客户端连接服务端

- mysql -S /tmp/mysql.sock2 -uroot -p
- mysql -h127.0.0.1 -uroot -P3307 -p

### 服务端处理客户端请求

![img](/images/db/MySQL/01.png)

#### 连接管理

> 客户端进程可以采用我们上面介绍的`TCP/IP`、`命名管道或共享内存`、`Unix域套接字`这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。`MySQL`服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量。

- 如何限制？
- mysql 服务器给每一个客户端都分配了一个线程，这个线程和客户端是深度绑定的，即和客户端的 socket 是深度绑定的，会通过 read 方法阻塞式的获取客户端请求

#### 解析与优化

##### 查询缓存

> `MySQL`服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果`缓存`起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端 A 刚刚查询了一个语句，而客户端 B 之后发送了同样的查询请求，那么客户端 B 的这次查询就可以直接使用查询缓存中的数据

- 如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中
- 如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存
- MySQL 的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、 `UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或 `DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除
- 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除

##### 语法解析

> 如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来

##### 查询优化

> 语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用`EXPLAIN`语句来查看某个语句的执行计划

#### 存储引擎

> 截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里。我们知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。为了实现不同的功能，`MySQL`提供了各式各样的`存储引擎`，不同`存储引擎`管理的表具体的存储结构可能不同，采用的存取算法也可能不同

| 存储引擎  | 描述                                 |
| --------- | ------------------------------------ |
| ARCHIVE   | 用于数据存档（行被插入后不能再修改） |
| BLACKHOLE | 丢弃写操作，读操作会返回空内容       |
| CSV       | 在存储数据时，以逗号分隔各个数据项   |
| FEDERATED | 用来访问远程表                       |
| InnoDB    | 具备外键支持功能的事务存储引擎       |
| MEMORY    | 置于内存的表                         |
| MERGE     | 用来管理多个MyISAM表构成的表集合     |
| MyISAM    | 主要的非事务处理存储引擎             |
| NDB       | MySQL集群专用存储引擎                |

##### `InnoDB`是`MySQL`默认的存储引擎

##### 查看当前服务程序支持的存储引擎 

> `Support`列表示该存储引擎是否可用，`DEFAULT`值代表是当前服务器程序的默认存储引擎。`Comment`列是对存储引擎的一个描述。`Transactions`列代表该存储引擎是否支持事务处理。`XA`列代表该存储引擎是否支持分布式事务。`Savepoints`代表该列是否支持部分事务回滚

![img](/images/db/MySQL/02.png)

##### 设置表的存储引擎

- 创建表时指定存储引擎

> 创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎`InnoDB`

```Bash
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;
```

- 修改表的存储引擎

```Bash
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

- 查看表的存储引擎

![img](/images/db/MySQL/03.png)


## 启动选项和系统变量

### 启动选项

> 每个 MySQL 程序都有许多不同的选项。大多数程序提供了一个`--help`选项，可以查看该程序支持的全部启动选项以及它们的默认值。在命令行中设置启动选项只对当次启动生效！！

- `mysql --help`

![img](/images/db/MySQL/04.png)

- `mysqld_safe --help`
- `mysqld --verbose --help`

![img](/images/db/MySQL/05.png)

### 配置文件

> 在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的很烦呀！于是设计`MySQL`的大佬们提出一种`配置文件`（也称为`选项文件`）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，所以我们推荐使用配置文件的方式来设置启动选项。

#### 类 Unix 操作系统中的配置文件

> 在类`UNIX`操作系统中，`MySQL`会按照下列路径来寻找配置文件

- 这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在`~/.my.cnf`这个路径下创建一个配置文件
- 在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准（比如/etc/my.cnf 与～/。my.cnf 都配置了相同的启动选项，以～/。my.cnf 为准）

| 路径名              | 备注                                     |
| ------------------- | ---------------------------------------- |
| /etc/my.cnf         | homebrew安装的目录对应 /opt/homebrew/etc |
| /etc/mysql/my.cnf   |                                          |
| SYSCONFDIR/my.cnf   |                                          |
| $MYSQL_HOME/my.cnf  | 特定于服务器的选项（仅限服务器）         |
| defaults-extra-file | 命令行指定的额外配置文件路径             |
| ~/.my.cnf           | 用户特定选项                             |
| ~/.mylogin.cnf      | 用户特定的登录路径选项（仅限客户端）     |

#### 配置文件的内容

> 与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号`[]`扩起来，像这样：

```Bash
[server]
(具体的启动选项...)

[mysqld]
(具体的启动选项...)

[mysqld_safe]
(具体的启动选项...)

[client]
(具体的启动选项...)

[mysql]
(具体的启动选项...)

[mysqladmin]
(具体的启动选项...)
```

像这个配置文件里就定义了许多个组，组名分别是`server`、`mysqld`、`mysqld_safe`、`client`、`mysql`、`mysqladmin`。每个组下面可以定义若干个启动选项，我们以`[server]`组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：

```Bash
[server]
option1            #这是option1，该选项不需要选项值
option2 = value2      #这是option2，该选项需要选项值
...
```

在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加`--`前缀，并且每行只指定一个选项，而且`=`周围可以有空白字符（命令行中选项名、`=`、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用`#`来添加注释，从`#`出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。

配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如，`[mysqld]`和`[mysql]`组分别应用于`mysqld`服务器程序和`mysql`客户端程序。不过有两个选项组比较特别：

- `[server]`组下面的启动选项将作用于所有的服务器程序。
- `[client]`组下面的启动选项将作用于所有的客户端程序。

| 启动命令     | 类别       | 能读取的组                         |
| ------------ | ---------- | ---------------------------------- |
| mysqld       | 启动服务器 | [mysqld]、[server]                 |
| mysqld_safe  | 启动服务器 | [mysqld]、[server]、[mysqld_safe]  |
| mysql.server | 启动服务器 | [mysqld]、[server]、[mysql.server] |
| mysql        | 启动客户端 | [mysql]、[client]                  |
| mysqladmin   | 启动客户端 | [mysqladmin]、[client]             |
| mysqldump    | 启动客户端 | [mysqldump]、[client]              |

我们可以在选项组的名称后加上特定的`MySQL`版本号，比如对于`[mysqld]`选项组来说，我们可以定义一个`[mysqld-5.7]`的选项组，它的含义和`[mysqld]`一样，只不过只有版本号为`5.7`的`mysqld`程序才能使用这个选项组中的选项

#### 配置文件的优先级

1. 在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准，配置文件的读取顺序参考 [二、启动选项和系统变量](https://rq3nt70g815.feishu.cn/wiki/HBT2wcn8Ti4ONakGlG0c7jc6n7e#MAsXdQbjFoh6iVxH2x3cRpACnlc)
2. 同一个命令可以访问配置文件中的多个组，比如`mysqld`可以访问`[mysqld]`、`[server]`组，如果在同一个配置文件中，比如`~/.my.cnf`，在这些组里出现了同样的配置项，比如这样，将以最后一个出现的组中的启动选项为准，👇🏻例子以`[mysqld]`组中的配置项为准

```Bash
[server]
default-storage-engine=InnoDB

[mysqld]
default-storage-engine=MyISAM
```

3. 同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准

#### defaults-file 的使用

> 如果我们不想让`MySQL`到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定`defaults-file`选项，比如这样（以`UNIX`系统为例）

```Bash
mysqld --defaults-file=/tmp/myconfig.txt
```

### 系统变量

`MySQL`服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为`MySQL`系统变量，比如允许同时连入的客户端数量用系统变量`max_connections`表示，表的默认存储引擎用系统变量`default_storage_engine`表示，查询缓存的大小用系统变量`query_cache_size`表示，`MySQL`服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它

#### 查看系统变量

```Bash
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.01 sec)

mysql> SHOW VARIABLES like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

#### 设置系统变量

##### 通过启动选项设置

> 大部分的`系统变量`都可以通过启动服务器时传送启动选项的方式来进行设置

- 通过命令行添加启动选项

```Bash
mysqld --default-storage-engine=MyISAM --max-connections=10
```

- 通过配置文件添加启动选项

```Bash
[server]
default-storage-engine=MyISAM
max-connections=10
```

- 对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线`-`或者下划线`_`连接起来都可以，但是对应的系统变量之间必须使用下划线`_`连接起来

##### 服务器程序运行过程中设置

> `系统变量`比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中，进行动态修改而无需停止并重启服务器。

- 作用范围

  - `GLOBAL`：全局变量，影响服务器的整体操作。
  - `SESSION`：会话变量，影响某个客户端连接的操作。（注：`SESSION`有个别名叫`LOCAL`）

- 通过启动选项设置的系统变量的作用范围都是`GLOBAL`的，也就是对所有客户端都有效的

- 设置系统变量的语句中省略了作用范围，默认的作用范围就是`SESSION`

- 通过客户端程序设置系统变量的语法

  - ```Bash
    SET [GLOBAL|SESSION] 系统变量名 = 值;
    SET [@@(GLOBAL|SESSION).]var_name = XXX;
    
    # 全局设置
    语句一：SET GLOBAL default_storage_engine = MyISAM;
    语句二：SET @@GLOBAL.default_storage_engine = MyISAM;
    
    # 针对本客户端设置，选择下面三条语句中的任意一条来进行设置
    语句一：SET SESSION default_storage_engine = MyISAM;
    语句二：SET @@SESSION.default_storage_engine = MyISAM;
    语句三：SET default_storage_engine = MyISAM;
    ```

- `SHOW VARIABLES`语句默认查看的是`SESSION`作用范围的系统变量，也可以通过下面方式查看不同作用范围的系统变量

```Bash
SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];
```

- 并不是所有系统变量都具有`GLOBAL`和`SESSION`的作用范围
  - 有一些系统变量只具有`GLOBAL`作用范围，比方说`max_connections`，表示服务器程序支持同时最多有多少个客户端程序进行连接
  - 有一些系统变量只具有`SESSION`作用范围，比如`insert_id`，表示在对某个包含`AUTO_INCREMENT`列的表进行插入时，该列初始的值
- 有些系统变量是只读的，并不能设置值
  - 比方说`version`，表示当前`MySQL`的版本，我们客户端是不能设置它的值的，只能在`SHOW VARIABLES`语句里查看

### 启动选项与系统变量的区别

> `启动选项`是在程序启动时我们程序员传递的一些参数，而`系统变量`是影响服务器程序运行行为的变量

- 大部分的系统变量都可以被当作启动选项传入
- 有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如`auto_increment_offset`、`character_set_client`等
- 有些启动选项也不是系统变量，比如`defaults-file`

### 状态变量

为了让我们更好的了解服务器程序的运行情况，`MySQL`服务器程序中维护了很多关于程序运行状态的变量，它们被称为`状态变量`。比方说`Threads_connected`表示当前有多少客户端与服务器建立了连接，`Handler_update`表示已经更新了多少行记录等。

由于`状态变量`是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与`系统变量`类似，`状态变量`也有`GLOBAL`和`SESSION`两个作用范围的。

```Bash
SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];
```

如果我们不写明作用范围，默认的作用范围是`SESSION`

![img](/images/db/MySQL/06.png)

## 字符集和比较规则

### 一些重要的字符集

- `ASCII`字符集

共收录 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才 128 个字符，所以可以使用 1 个字节来进行编码，我们看一些字符的编码方式：

```Bash
'L' ->  01001100（十六进制：0x4C，十进制：76）
'M' ->  01001101（十六进制：0x4D，十进制：77）
```

- `ISO 8859-1`字符集

共收录 256 个字符，是在`ASCII`字符集的基础上又扩充了 128 个西欧常用字符（包括德法两国的字母），也可以使用 1 个字节来进行编码。这个字符集也有一个别名`latin1`

- `GB2312`字符集

收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字 6763 个，其他文字符号 682 个。同时这种字符集又兼容`ASCII`字符集，所以在编码方式上显得有些奇怪：

- 如果该字符在`ASCII`字符集中，则采用 1 字节编码
- 否则采用 2 字节编码

- `GBK`字符集

```
GBK`字符集只是在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容`GB2312
```

- `utf8`字符集

收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容`ASCII`字符集，采用变长编码方式，编码一个字符需要使用 1～4 个字节。其实准确的说，utf8 只是 Unicode 字符集的一种编码方案，Unicode 字符集可以采用 utf8、utf16、utf32 这几种编码方案，utf8 使用 1～4 个字节编码一个字符，utf16 使用 2 个或 4 个字节编码一个字符，utf32 使用 4 个字节编码一个字符。MySQL 中并不区分字符集和编码方案的概念，所以把 utf8、utf16、utf32 都当作一种字符集对待。

```Bash
'L' ->  01001100（十六进制：0x4C）
'啊' ->  111001011001010110001010（十六进制：0xE5958A）
```

### MySQL 中支持的字符集和排序规则

#### MySQL 中的 utf8 和 utf8mb4

`utf8`字符集表示一个字符需要使用 1～4 个字节，但是我们常用的一些字符使用 1～3 个字节就可以表示了。而在`MySQL`中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计`MySQL`的大佬偷偷的定义了两个概念：

- `utf8mb3`：阉割过的`utf8`字符集，只使用 1～3 个字节表示字符。在`MySQL`中`utf8`是`utf8mb3`的别名，所以之后在`MySQL`中提到`utf8`就意味着使用 1～3 个字节来表示一个字符。
- `utf8mb4`：正宗的`utf8`字符集，使用 1～4 个字节表示字符。存储一些 emoji 表情什么的。

#### 字符集的查看

`MySQL`支持好多好多种字符集，查看当前`MySQL`中支持的字符集可以用下面这个语句：

```Bash
# CHARACTER SET和CHARSET是同义词
SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
```

| 字符集名称 | Maxlen |
| ---------- | ------ |
| ascii      | 1      |
| latin1     | 1      |
| gb2312     | 2      |
| gbk        | 2      |
| utf8       | 3      |
| utf8mb4    | 4      |

#### 比较规则的查看

查看`MySQL`中支持的比较规则的命令如下：

```Bash
SHOW COLLATION [LIKE 匹配的模式];
```

- 比较规则名称以与其关联的字符集的名称开头
- 后边紧跟着该比较规则主要作用于哪种语言，比如`utf8_polish_ci`表示以波兰语的规则比较，`utf8_spanish_ci`是以西班牙语的规则比较，`utf8_general_ci`是一种通用的比较规则
- 名称后缀意味着该比较规则是否区分语言中的重音、大小写什么的，具体可以用的值如下

| 后缀 | 英文释义           | 描述             |
| ---- | ------------------ | ---------------- |
| _ai  | accent insensitive | 不区分重音       |
| _as  | accent sensitive   | 区分重音         |
| _ci  | case insensitive   | 不区分大小写     |
| _cs  | case sensitive     | 区分大小写       |
| _bin | binary             | 以二进制方式比较 |

#### 各级别的字符集和比较规则

##### 服务器级别

> `MySQL`提供了两个系统变量来表示服务器级别的字符集和比较规则

| 系统变量             | 描述                 |
| -------------------- | -------------------- |
| character_set_server | 服务器级别的字符集   |
| collation_server     | 服务器级别的比较规则 |

![img](/images/db/MySQL/07.png)

> 可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用`SET`语句修改这两个变量的值

```Bash
[server]
character_set_server=gbk
collation_server=gbk_chinese_ci
```

#####  数据库级别

> 在创建和修改数据库的时候可以指定该数据库的字符集和比较规则

```Bash
CREATE DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];

ALTER DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];
```

*character_set_database* 和 *collation_database* 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则

| 系统变量               | 描述                 |
| ---------------------- | -------------------- |
| character_set_database | 当前数据库的字符集   |
| collation_database     | 当前数据库的比较规则 |

##### 表级别

> 也可以在创建和修改表的时候指定表的字符集和比较规则

- 如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。

```Bash
CREATE TABLE 表名 (列的信息)
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]]

ALTER TABLE 表名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]
```

##### 列级别

> 对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则

- 如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则

```Bash
CREATE TABLE 表名(
    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
    其他列...
);

ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
```

##### 各级别字符集和比较规则小结

- 如果创建或修改列时，没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则
- 如果创建或修改表时，没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则
- 如果创建或修改数据库时，没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则

### 客户端和服务端通信中的字符集

#### MySQL 中字符集的转换

从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到 3 个系统变量

| 系统变量                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| character_set_client     | 服务器解码请求时使用的字符集                                 |
| character_set_connection | 服务器处理请求时会把请求字符串从character_set_client转为character_set_connection |
| character_set_results    | 服务器向客户端返回数据时使用的字符集                         |

![img](/images/db/MySQL/08.png)

- 服务器认为客户端发送过来的请求是用`character_set_client`编码的

> 假设你的客户端采用的字符集和 *character_set_client* 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是`utf8`字符集，如果把系统变量`character_set_client`的值设置为`ascii`的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了

- 服务器将把得到的结果集使用`character_set_results`编码后发送给客户端

> 假设你的客户端采用的字符集和 *character_set_results* 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是`utf8`字符集，如果把系统变量`character_set_results`的值设置为`ascii`的话，可能会产生乱码

- 通常都把 *character_set_client* 、*character_set_connection***、*character_set_results*** 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，`MySQL`提供了一条非常简便的语句

```Bash
SET NAMES 字符集名;
```

- 想在启动客户端的时候就把`character_set_client`、`character_set_connection`、`character_set_results`这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫`default-character-set`的启动选项，比如在配置文件里可以这么写

```Bash
[client]
default-character-set=utf8
```

## InnoDB 记录结构

### InnoDB 页简介

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB`存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，`InnoDB`采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 *16* KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

### InnoDB 行格式

> 记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`

#### 指定行格式的语法

```Bash
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

#### COMPACT 行格式

![img](/images/db/MySQL/09.png)

##### 记录的额外信息

- 变长字段长度列表

  - 各变长字段数据占用的字节数按照列的顺序逆序存放

  - 
    ```Plain
    为什么需要逆序存放呢？
    因为对于数据页中的数据是通过单链表进行连接的，每条记录中头信息中包含next_record字段，此字段指向的是下一条记录的头信息和真实数据之间的位置上，这样向左读取就是记录头信息，向右读取就是真实数据，所以按顺序存放的字段和逆序存放的变长字段列表和NULL值列表就对上了，这样每个字段的值以及它的长度和NULL标识在内存中更近，这样的话可能会提高高速缓存的命中率
    ```

  - 变长字段长度列表中只存储值为 非 NULL 的列内容占用的长度，值为 *NULL* 的列的长度是不储存的

  - 假设某个字符集中表示一个字符最多需要使用的字节数为`W`，对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是`M×W`，`L` 表示实际存储占用的字节数

    - `M×W <= 255`，那么使用 1 个字节来表示真正字符串占用的字节数
    - `M×W > 255 && L <= 127` 用 1 个字节来表示真正字符串占用的字节数
    - `M×W > 255 && L > 127`用 2 个字节来表示真正字符串占用的字节数
    - [疑问]为什么需要按👆🏻这种做法呢？？

```Plaintext
    InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，
    该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？
    设计InnoDB的大佬使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，
    那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），
    如果该字节的第一个位为1，那该字节就是半个字段长度。对于一些占用字节数非常多的字段，
    比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，
    InnoDB会把一部分数据存放到所谓的溢出页中，
    在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。
```

- NULL 值列表
  - 统计表中允许存储`NULL`的列，比如表中有三个列可以为空，那么 NULL 值列表就有 3 个二进制位存储当前这条数据对应字段是否为空
  - 如果表中没有允许存储 *NULL* 的列，则 *NULL 值列表* 也不存在了，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，值为`1`时，代表该列的值为`NULL`。
  - `NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`

```Plain
假设A表中包含字段c1,c2,c3,c4  其中c2,c3,c4字段可以为空 那么能得到下面的结果
1. NULL值列表只需要3个二进制位表示，只需要一个字段，00000C4C3C2 其中后面三位可以为1或者0
2. 某条记录所有字段均不为空，那么NULL值列表中一个字节上对应所有的二进制位均为0
3. 某条记录C3字段为空，对应的NULL值列表的二进制位是 00000010
```

- 记录头信息 

  - 用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思

  - ![img](/images/db/MySQL/10.png)

  - | 名称         | 大小（单位：bit） | 描述                                                         |
    | ------------ | ----------------- | ------------------------------------------------------------ |
    | 预留位1      | 1                 | 没有使用                                                     |
    | 预留位2      | 1                 | 没有使用                                                     |
    | delete_mask  | 1                 | 标记该记录是否被删除                                         |
    | min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
    | n_owned      | 4                 | 表示当前记录拥有的记录数。就是该记录是page directory 中的一个slot，代表这个组内共有多少条记录数(包含自己这条记录) |
    | heap_no      | 13                | 表示当前记录在本页的位置信息                                 |
    | record_type  | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
    | next_record  | 16                | 表示下一条记录的相对位置                                     |

  - `delete_mask` 标记着当前记录是否被删除，占用 1 个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了 

    - 
      ```Plain
      这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉
      ```

  - `min_rec_mask` B+树的每层非叶子节点中的最小记录都会添加该标记

  - `heap_no` 表示当前记录在本`页`中的位置，位置是从 2 开始，因为 0 和 1 被伪记录占据了，0 表示最小记录，1 表示最大记录，这两条伪记录不在页的 User Records 部分，被单独放在[ Infimum + Supermum](https://rq3nt70g815.feishu.cn/wiki/LCejwPlwqiofWbkDn86cotzPnfd#TyLUdGtCVoepiyx43A1c6zgXnNd) 的部分

  - ![img](/images/db/MySQL/11.png)

  - `next_record` 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。`下一条记录`指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 *Infimum 记录（也就是最小记录）* 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 *Supremum 记录（也就是最大记录）* ，为了更形象的表示一下这个`next_record`起到的作用，我们用箭头来替代一下`next_record`中的地址偏移量：

    - ![img](/images/db/MySQL/12.png)
    - ![img](/images/db/MySQL/13.png)
    - 第 2 条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`
    - 第 2 条记录的`next_record`值变为了 0，意味着该记录没有下一条记录了
    - 第 1 条记录的`next_record`指向了第 3 条记录

##### 记录的真实数据

- 隐藏列

| 列名                      | 是否必须 | 占用空间 | 描述                   |
| ------------------------- | -------- | -------- | ---------------------- |
| row_id(DB_ROW_ID)         | 否       | 6字节    | 行ID，唯一标识一条记录 |
| transaction_id(DB_TRX_ID) | 是       | 6字节    | 事务ID                 |
| roll_pointer(DB_ROLL_PTR) | 是       | 7字节    | 回滚指针               |

```Plain
InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，
则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，
则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键
```

- CHAR（M） 列的存储格式

  - 当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表

  - 采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表

  - 变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求

  - 
    ```SQL
    比方说对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。
    即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度
    大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，
    导致原有的记录空间成为所谓的碎片。
    ```

#### 行溢出数据

##### VARCHAR（M）最多能存储的数据

- 一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节！
- VARCHAR 类型需要占用 3 部分数据
  - 真实数据
  - 真实数据占用字节的长度
  - NULL 值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间
- 当 M 为 ascii 字符集时，一个字符表示一个字节，这样 VARCHAR（65535） 可用吗？不可用
  - 没有 NOT NULL，意味着 NULL 值标识需要占一个字节，长度需要占用两个字节，所以最多只能存储 65532 个字节的数据
  - 有 NOT NULL，意味着额外只需要长度占用两个节点，所以最多存储 65533 个字节
- 当 M 使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为`NULL`的情况下，`gbk`字符集表示一个字符最多需要`2`个字节，那在该字符集下，`M`的最大取值就是`32766`（也就是：65532/2），也就是说最多能存储`32766`个字符；`utf8`字符集表示一个字符最多需要`3`个字节，那在该字符集下，`M`的最大取值就是`21844`，就是说最多能存储`21844`（也就是：65532/3）个字符

##### 记录中的数据太多产生的溢出

- `MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节
- 一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况
- 在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用 20 个字节存储指向这些页的地址（当然这 20 个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页

![img](/images/db/MySQL/14.png)

##### 行溢出的临界点

- `MySQL`中规定一个页中至少存放两行记录
- 每个页除了存放记录以外，也需要存储一些额外的信息，额外信息加起来需要`136`个字节的空间
- 每个记录需要的额外信息是`27`字节 （以下表示的都是表中只有一个列）
  - 2 个字节用于存储真实数据的长度
  - 1 个字节用于存储列是否是 NULL 值
  - 5 个字节大小的头信息
  - 6 个字节的`row_id`列
  - 6 个字节的`transaction_id`列
  - 7 个字节的`roll_pointer`列
- 在表中只有一个列的情况下，如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`

#### `Dynamic`和`Compressed`行格式

- `MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`
- 和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址

![img](/images/db/MySQL/15.png)

- `Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。


## InnoDB 数据页

![img](/images/db/MySQL/16.png)

| 名称               | 中文名             | 占用空间大小 | 简单描述                                                     |
| ------------------ | ------------------ | ------------ | ------------------------------------------------------------ |
| File Header        | 文件头部           | 38字节       | 页的一些通用信息                                             |
| Page Header        | 页面头部           | 56字节       | 数据页专有的一些信息                                         |
| Infimum + Supremum | 最小记录和最大记录 | 26字节       | 两个虚拟的行记录，innoDB设计的最小记录和最大记录，最小记录和最大记录的heap_no分别是0和1 |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容                                         |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间                                           |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置                                     |
| File Trailer       | 文件尾部           | 8字节        | 校验页是否完整                                               |

### 记录在页中的存储

> 在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了

![img](/images/db/MySQL/17.png)

[数据在页中按照主键值从小打到顺序串联成一个单链表](https://rq3nt70g815.feishu.cn/wiki/Da7KwAdwOi3Ji3kYjU2clxF5n9f#SyksdUNdEoV959xpiTAcZLsAnOg)

### Page Directory 页目录

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。
   1. ![img](/images/db/MySQL/18.png)
   2. innoDB 对于每个分组中的条数有以下规定
      - 于最小记录所在的分组只能有 *1* 条记录
      - 最大记录所在的分组拥有的记录条数只能在 *1～8* 条之间
      - 剩下的分组中记录的条数范围只能在是 *4～8* 条之间
   3. Page Derectory 构建步骤
      - 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
      - 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。
      - 在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。
   4. ![img](/images/db/MySQL/19.png)
   5. 如何从 Page Derectory 中查找记录
      - 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。（由于 slot 存储的是该组中最大的记录，所以可以找到上一个 slot，上一个 slot 的指向的 next record 就是当前 slot 中最小的记录）
      - 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

### Page Header 数据页头部

| 名称              | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2字节        | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2字节        | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space   |
| PAGE_N_HEAP       | 2字节        | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| PAGE_FREE         | 2字节        | 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）可能是删除记录产生的空闲空间，也可能是页面末尾的未使用空间 |
| PAGE_GARBAGE      | 2字节        | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2字节        | 最后插入记录的位置。指向的是最后插入记录的起始位置，而不是记录的结束位置，所以不等于 free space。此字段是不考虑记录删除的，所以与PAGE_FREE相差巨大 |
| PAGE_DIRECTION    | 2字节        | 记录插入的方向。假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION |
| PAGE_N_DIRECTION  | 2字节        | 一个方向连续插入的记录数量。假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。 |
| PAGE_N_RECS       | 2字节        | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID   | 8字节        | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| PAGE_LEVEL        | 2字节        | 当前页在B+树中所处的层级                                     |
| PAGE_INDEX_ID     | 8字节        | 索引ID，表示当前页属于哪个索引                               |
| PAGE_BTR_SEG_LEAF | 10字节       | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| PAGE_BTR_SEG_TOP  | 10字节       | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

### File Header 文件头部

> `File Header`针对各种类型的页都通用，也就是说不同类型的页都会以`File Header`作为第一个组成部分，它描述了一些针对各种页都通用的一些信息

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4字节        | 页的校验和（checksum值） 代表当前页面的校验和（checksum）。什么是个校验和？就是对于一个很长很长的字节串来说，通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。 |
| FIL_PAGE_OFFSET                  | 4字节        | 页号 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。 |
| FIL_PAGE_PREV                    | 4字节        | 上一个页的页号，双向链表                                     |
| FIL_PAGE_NEXT                    | 4字节        | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8字节        | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2字节        | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8字节        | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4字节        | 页属于哪个表空间                                             |

- `FIL_PAGE_TYPE`

| 类型名称                | 十六进制 | 描述                           |
| ----------------------- | -------- | ------------------------------ |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用             |
| FIL_PAGE_UNDO_LOG       | 0x0002   | Undo日志页                     |
| FIL_PAGE_INODE          | 0x0003   | 段信息节点                     |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer空闲列表          |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer位图              |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                         |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据                   |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息                 |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页                     |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | BLOB页                         |
| FIL_PAGE_INDEX          | 0x45BF   | 索引页，也就是我们所说的数据页 |

- `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

> `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性。

![img](/images/db/MySQL/20.png)

### File Trailer

> 为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况）。因为可能断电导致内存中的页只有一部分刷新到了磁盘，所以需要通过这个来判断一个页是否完整。这个部分由 8 个字节组成

- 前 4 个字节代表页的校验和

这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前面，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trialer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）

## B+树索引

- [快速查询的秘籍-B+树索引](https://relph1119.github.io/mysql-learning-notes/#/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95)

![img](/images/db/MySQL/21.png)

### 聚簇索引

> 在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的索引即数据，数据即索引

1. 页内的记录是按照主键的大小顺序排成一个单向链表
2. 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
3. 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表
4. `B+`树的叶子节点存储的是完整的用户记录

### 二级索引

![img](/images/db/MySQL/22.png)

- 页内的记录是按照二级索引对应的列的大小顺序排成一个单向链表。
- 各个存放用户记录的页也是根据页中记录的二级索引对应的列大小顺序排成一个双向链表
- 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的二级索引对应的列大小顺序排成一个双向链表
- `B+`树的叶子节点存储的并不是完整的用户记录，而只是`二级索引对应的列+主键`这两个列的值
- 目录项记录中不再是`主键+页号`的搭配，而变成了`二级索引对应的列``+页号`的搭配
- 如果我们想根据`二级索引对应的列`的值查找到完整的用户记录的话，仍然需要到`聚簇索引`中再查一遍，这个过程也被称为`回表`
- 二级索引的内节点的目录项记录的内容由三部分构成，这样才能保证同一层内节点的目录项记录除`页号`这个字段以外是唯一的。
  - 索引列的值
  - 主键值
  - 页号

### 联合索引

![img](/images/db/MySQL/23.png)

- 先把各个记录和页按照`c2`列进行排序。
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序

### InnoDB的B+树索引的注意事项

#### 根页面万年不动窝

- 每当为某个表创建一个`B+`树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个`根节点`页面。最开始表中没有数据的时候，每个`B+`树索引对应的`根节点`中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中。
- 当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页，比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到`页a`或者`页b`中，而`根节点`便升级为存储目录项记录的页。
- 一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要对某个表建立一个索引，那么它的`根节点`的页号便会被记录到某个地方，然后凡是`InnoDB`存储引擎需要用到这个索引的时候，都会从那个固定的地方取出`根节点`的页号，从而来访问这个索引。

#### 一个页面最少存储2条记录

> 一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是什么效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以`InnoDB`的一个数据页至少可以存放两条记录

### 索引的代价

#### 空间上的代价

> 每建立一个索引都要为它建立一棵`B+`树，每一棵`B+`树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的`B+`树由许多数据页组成，那可是很大的一片存储空间呢

#### 时间上的代价

> 每次对表中的数据进行增、删、改操作时，都需要去修改各个`B+`树索引。`B+`树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收什么的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的`B+`树都要进行相关的维护操作，这还能不给性能拖后腿么?

一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

### B+树索引的适用条件

```SQL
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

![img](/images/db/MySQL/24.png)

- 先按照`name`列的值进行排序。
- 如果`name`列的值相同，则按照`birthday`列的值进行排序。
- 如果`birthday`列的值也相同，则按照`phone_number`的值进行排序。

#### 全值匹配

> 搜索条件中的列和索引列一致的话

比如👇🏻这个搜索sql，搜索条件与索引列完全一致

```SQL
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

#### 匹配左边的列

> 搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行

#### 匹配列前缀

#### 匹配范围值

#### 精确匹配某一列并范围匹配另外一列

> 对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找

```SQL
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

#### 用于排序

我们在写查询语句的时候经常需要对查询出来的记录通过`ORDER BY`子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、等等排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在`MySQL`中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`），跟`文件`这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果`ORDER BY`子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。

##### 使用联合索引进行排序注意事项

- `ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出
- `ORDER BY name`、`ORDER BY name, birthday`这种匹配索引左边的列的形式可以使用部分的`B+`树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序

```SQL
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
```

##### 不可以使用索引进行排序的几种情况

1. ASC、DESC混用

> 对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是`ASC`规则排序，要么都是`DESC`规则排序，如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。

1. WHERE子句中出现非排序使用到的索引列
2. 排序列包含非同一个索引的条件
3. 排序列使用了复杂的表达式，比如函数等

#### 用于分组

> 没有索引的话，这个分组过程全部需要在内存里实现

### 回表的代价

一般来说二级索引查询的数据在磁盘中的存储是相连的，集中分布在一个或几个数据页中，所以是顺序IO，但是回表的时候对应的ID可能分配在不同的页上，这时候读取就是随机IO，顺序IO相比于随机IO性能高的多，所以需要回表的记录越多，使用二级索引的性能就越低

- 访问二级索引使用`顺序I/O`，访问聚簇索引使用`随机I/O`
- 需要回表的记录越多，使用二级索引的性能就越低
- 回表数据量过大可能导致不使用二级索引，而是遍历聚簇索引

```SQL
SELECT * FROM person_info ORDER BY name, birthday, phone_number;
```

比如👆🏻这个例子中，由于查询列表是`*`，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（`filesort`）低，所以优化器会倾向于使用`全表扫描`的方式执行查询。

```SQL
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

但是如果增加了limit子句，需要回表的数据
