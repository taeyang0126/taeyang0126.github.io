---
title: rocksdb
tags:
  - rocksdb
  - 数据库
categories:
  - rocksdb
abbrlink: 17349
date: 2025-02-19 23:52:22
---

#### 数据写入流程
![image1.png](/images/db/rocksdb/image1.png)

#### 数据读取流程
![image2.png](/images/db/rocksdb/image2.png)

#### db 相关属性
| 类别 | 属性名 | 描述 |
|------|--------|------|
| 总体统计 | rocksdb.stats | 提供详细的数据库统计信息，包括压缩、读写操作、块缓存等数据 |
| 数据库大小 | rocksdb.total-sst-files-size | 所有 SST 文件的总大小 |
| | rocksdb.estimate-table-readers-mem | 估计表读取器使用的内存 |
| | rocksdb.estimate-live-data-size | 估计的活跃数据大小 |
| 内存使用 | rocksdb.cur-size-all-mem-tables | 所有 MemTable 的当前大小 |
| | rocksdb.block-cache-usage | 块缓存的使用量 |
| 压缩 | rocksdb.background-errors | 后台工作（如压缩）中的错误数 |
| | rocksdb.num-running-compactions | 当前运行的压缩任务数 |
| 写入 | rocksdb.num-immutable-mem-table | 不可变 MemTable 的数量 |
| | rocksdb.mem-table-flush-pending | 是否有待处理的 MemTable 刷新 |
| | rocksdb.is-write-stopped | 写入是否已停止 |
| | rocksdb.actual-delayed-write-rate | 实际的延迟写入速率 |
| 读取 | rocksdb.estimate-num-keys | 估计的键数量 |
| 文件 | rocksdb.num-files-at-level<N> | 第 N 层的文件数量（如 rocksdb.num-files-at-level0） |
| | rocksdb.live-sst-files-size | 活跃 SST 文件的大小 |

注意：
1. 使用方法示例：`String value = db.getProperty("rocksdb.stats");`
2. 某些属性可能会影响性能，应谨慎使用。
3. 属性值可能会频繁变化，建议定期获取以监控趋势。
4. 在生产环境中使用时，可能需要限制获取这些属性的频率。

#### 事务操作使用场景
- 为单个 key 提供并发控制
  1. 事务开始时获取逻辑锁
  2. 提交时检查冲突
  3. 避免显式锁定，提高并发性
  4. 减少死锁风险
  5. 计数器更新
  6. 用户状态修改
- 确保多个 key 的一致性更新
  1. 将多个 key 操作组合为单一事务
  2. 全部成功或全部失败
  3. 维护相关数据的一致性
  4. 简化复杂操作的实现
  5. 用户注册（创建账户 + 初始化设置）
  6. 订单处理（更新库存 + 记录订单）

#### RocksDB 默认冲突检测机制
##### 事务间冲突检测
1. 触发时机：事务提交时
2. 检测对象：活跃事务之间的写集
3. 检测方式：
   1. 每个事务的 put 操作都会记录在写集中
   2. 提交时检查本事务的写集是否与其他活跃事务的写集冲突
   3. 结果：如果发现冲突，后提交的事务通常会失败

##### 非事务性写入检测
1. 触发时机：执行非事务性写入时（如 txnDb.put()）
2. 检测对象：所有活跃事务的锁和写意图
3. 检测方式：
   1. 检查目标键是否被任何活跃事务锁定
   2. 检查是否有活跃事务对该键有写意图
   3. 结果：如果存在冲突，非事务性写入会失败并抛出异常

##### 关键机制
1. 写意图（Write Intents）：事务执行写操作时登记，用于冲突检测
2. 锁定机制：事务的 put 操作会为相应的键设置锁
3. 快照隔离：事务开始时获取数据快照，影响可见的数据版本
4. 乐观并发控制（默认）：大多数冲突检测在提交时进行
5. 悲观锁定（可配置）：启用后，冲突检测在写操作执行时就会进行

#### RocksDB 读取策略
##### 读已提交(默认)
内部事务对于外部事务提交的立马可见

##### 快照读
```java
readOptions.setSnapshot(snapshot);
```
快照读类比于读已提交，对于外部事务只能看到当前快照创建时提交的数据，对于当前事务，所有写入都是可见的


#### RocksDB 事务版本号管理
- 对于冲突检测来说，使用事务开始时的快照序列号作为基准，比较操作键的当前序列号与快照序列号
- 对于提交来说，获取新的全局序列号作为起始点，将事务内部的临时序列号映射到连续的全局序列号，最终序列号 = 新全局序列号 + 临时序列号偏移
- 所以会出现某个事务过程中，外部事务修改了键，内部事务再使用getForUpdate就会报错，因为比较实用的是快照的序列号
- getForUpdate还有个好处就是能检测外部非事务性操作，因为本质上使用的是序列号比较，所以能检测，但是默认的写写冲突是无法检测的，因为默认是读已提交，rocksdb认为这是合理的，内部事务会覆盖外部事物的值

| 方面 | 描述 |
|------|------|
| 全局序列号 | - 全局递增的序列号作为版本标识<br>- 每次非事务写入或事务提交时分配 |
| 事务开始 | - 创建数据库快照<br>- 记录当前最大序列号作为事务"基线" |
| 读操作 | - 使用事务开始时的快照序列号<br>- 只读取序列号≤快照序列号的数据 |
| 写操作 | - 不立即分配全局序列号<br>- 事务内部使用临时本地序列号 |
| 事务提交 | - 获取新的全局序列号<br>- 将事务内写操作映射到连续的全局序列号<br>- 用新序列号更新数据库 |
| 回滚处理 | - 丢弃事务内的所有本地序列号<br>- 不影响全局序列号 |
| 冲突检测 | - 读写冲突：比较快照序列号与当前数据序列号<br>- 写写冲突：提交时检查数据是否被其他事务修改 |
| OptimisticTransactionDB | - 延迟冲突检测到提交阶段<br>- 提交时比较数据当前序列号与事务开始序列号 |
| TransactionDB | - 可能在操作过程中进行冲突检测<br>- 使用锁机制预防冲突 |
| 隔离级别影响 | - 读已提交：每次读操作使用最新快照<br>- 可重复读：整个事务使用开始时的快照<br>- 快照隔离：类似可重复读，但有额外写冲突检测 |
| 注意事项 | - 版本号管理是实现 MVCC 的基础<br>- 有助于理解和处理事务冲突和并发问题 |

#### getForUpdate总结
1. 用来解决读写冲突，这里的冲突可以是事务与其他事务之间，也可以是事务与非事务操作之间
2. 我认为是使用序列号进行检测的，当前快照的序列号与键的序列号之间的比较判断是否冲突
3. 对于OptimisticTransactionDB和TransactionDB检测的时机不一样，前者属于乐观型的，在commit才会检测，后者会立即检测