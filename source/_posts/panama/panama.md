---
title: panama
tags:
  - panama
  - ffi
  - java
categories:
  - panama
abbrlink: 17349
date: 2025-02-19 21:51:22
---

- [JEP 454: Foreign Function & Memory API](https://openjdk.org/jeps/454)

### Summary
> 通过引入一个允许 Java 程序与 Java 运行时外部的代码和数据进行交互的 API，可以高效地调用外部函数（即，JVM 外部的代码）并安全地访问外部内存（即，不是由 JVM 管理的内存），从而使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样易碎和危险。

### JNI
- JNI 涉及几个繁琐的人工制品：一个 Java API（ native 方法）、一个从 Java API 派生的 C 头文件和一个调用目标原生库的 C 实现。Java 开发人员必须跨多个工具链工作以保持平台相关的人工制品同步，而这在原生库快速演化时尤其繁重。
- JNI 只能与用操作系统和 CPU 的调用约定编写的语言（通常是 C 和 C++）编写的库进行交互，这是 JVM 为其构建的。native 方法不能用于调用以使用不同约定的语言编写的函数。
- JNI 无法协调 Java 类型系统和 C 类型系统。Java 代码使用对象表示聚合数据，但 C 代码使用结构表示聚合数据，因此任何传递给 native 方法的 Java 对象都必须由本机代码费力地解包。例如，考虑一个 Java 记录类 Person ：将一个 Person 对象传递给 native 方法，要求本机代码使用 JNI 的 C API 从该对象中提取字段（例如， firstName 和 lastName ）。因此，Java 开发人员有时会将他们的数据展平到单个对象中（例如，字节数组或直接字节缓冲区），但更多情况下，由于通过 JNI 传递 Java 对象速度很慢，他们使用 Unsafe API 分配堆外内存并将其地址作为 long 传递给 native 方法 - 这使得 Java 代码非常不安全！

### Features
1. 控制外内存的分配和释放
2. 操控和访问结构化的外部内存
3. 调用外部函数（ Linker 、 SymbolLookup 、 FunctionDescriptor 和 MethodHandle ）

### Memory segments and arenas
- 内存段是一个由一块连续的内存区域支持的抽象概念，该区域可以位于堆外或堆上。
  1. 从非堆内存中从头分配的本机段（如同通过 malloc)
  2. 映射段，围绕一块映射的非堆内存（如通过 mmap ）
  3. 一个数组或缓冲区段，它被包装在一个与现有 Java 数组或字节缓冲区关联的堆上内存区域周围
- 所有内存段都提供空间和时间边界，这些边界确保内存访问操作是安全的。简而言之，这些边界保证不使用未分配的内存，也不进行释放后使用。
- `global arena` 全局区域，它提供无限的生命周期：它始终保持活动状态，只有在JVM退出的时候才会被自动卸载
- `Auto arena` 自动 arena 提供了有限的生命周期：由自动 arena 分配的段可以被访问，直到 JVM 的垃圾回收器检测到该内存段不可访问，此时该段背后的内存区域将被释放
- `confined arena` 提供了一种有界限且确定性的生存期：从客户端打开区域到客户端关闭区域之间的这段时间它将一直存在。在受限区域中分配的内存段只能在关闭区域之前访问，在关闭区域时，支持该段的内存区域将被取消分配。在区域关闭后尝试访问内存段将失败并引发异常。!!只有一个线程可以访问
- `shared arena` 在共享区域中分配的内存段可以被多个线程访问，并且任何线程——无论是否访问该区域——都可以关闭该区域以释放这些段。关闭区域会原子地使这些段无效，尽管支持这些段的内存区域的释放可能不会立即发生，因为需要昂贵的同步操作来检测和取消对这些段的挂起并发访问操作

### Zero-length memory segments
- FFM API 将外函数返回的指针表示为零长度的内存段。该段的地址是该指针的值，该段的大小为零。类似地，当客户端从内存段读取指针时，将返回一个零长度的内存段。
- 任何 Address 布局返回的MemorySegment都是 Zero-length memory segments
- 零长度段具有微不足道的空间边界，因此任何访问此类段的尝试都会失败，并带有 IndexOutOfBoundsException 。这是一个至关重要的安全特性：由于这些段与大小未知的内存区域相关联，因此涉及这些段的访问操作无法验证。实际上，零长度内存段封装了一个地址，在没有明确意图的情况下无法使用它。
- 可以使用 MemorySegment::reinterpret 方法将零长度内存段转换为特定大小的本机段。 此方法将新的空间和时间边界附加到零长度内存段，以便允许解除引用操作。 此方法返回的内存段不安全：零长度内存段可能由 10 字节长的内存区域支持，但客户端可能会高估该区域的大小并使用 MemorySegment::reinterpret 获取 100 字节长的段。 稍后，这可能会导致尝试在该区域边界之外解除引用内存，从而可能导致 JVM 崩溃或更糟的情况，导致静默内存损坏。