---
title: Java对象分配过程
abbrlink: 19346
date: 2025-02-22 14:13:52
updated: 2024-02-24 21:09:00
tags: [JVM, JFR, 对象分配]
categories:
  - JVM
---

### 路径一 TLAB 内分配
- 需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配
- 这是大多数对象的分配路径

### 路径二 申请新的 TLAB 分配
- 需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间
- 重新分配一个 TLAB，然后在新的 TLAB 中分配

### 路径三 TLAB 外分配
- 需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间
- 或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小
- 或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁
- 以上三种情况都会直接在堆上分配

### 路径四 分配前触发GC或者等待GC
- 路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁
- 这种情况下，会 `触发GC`(serial/parallel/G1 GC) 或者`等待GC释放对象`(ZGC)
- 路基四如果太多，那其实可能是整体 Java 堆内存就设置的太小了，需要考虑扩容
- 如果用的是 SerialGC，ParallelGC，G1GC，那么路径四会产生 `Allocation Requiring GC`
- 如果使用的是 ZGC，那么路径四会产生 `Z Allocation Stall`
- 如果用的是 ShenandoahGC，路径四会导致 Degenerated GC，这个目前没有对应的 JFR 事件，可以通过 GC 相关的时间看到，但是目前看不到是哪个对象触发

### 为什么有个最大浪费空间？？
- 这是为了避免更有效的利用空间
- 假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择
    - 丢弃掉当前这个TLAB，去申请一个新的
    - 不在当前这个TLAB上配置，去堆上分配
    - 最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了

### TLAB
- TLAB 是动态的，一般分配频繁的线程TLAB=2M
- 每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB