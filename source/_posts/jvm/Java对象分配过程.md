---
title: Java对象分配过程
abbrlink: 19346
date: 2025-02-22 14:13:52
tags: [JVM, JFR, 对象分配]
categories:
  - JVM
---

### 路径一 TLAB 内分配
- 需要分配的大小小于 TLAB (Thread Local Alloction Buffer) 的剩余空间，直接在 TLAB 中分配
- 这是大多数对象的分配路径

### 路径二 申请新的 TLAB 分配
- 需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间小于 TLAB 的最大浪费空间
- 重新分配一个 TLAB，然后在新的 TLAB 中分配

### 路径三 TLAB 外分配
- 需要分配的大小大于 TLAB 的剩余空间，TLAB 的当前剩余空间大于 TLAB 的最大浪费空间
- 或者是申请新的 TLAB，TLAB 扩容也无法满足需要的大小
- 或者是申请新的 TLAB，堆剩余空间不足以分配新的 TLAB，但是足够分配这个对象并且这个线程抢到了全局堆锁
- 以上三种情况都会直接在堆上分配

### 路径四 分配前触发GC或者等待GC
- 路径二和路径三都失败，即堆剩余空间不足导致申请TLAB失败，堆剩余空间也不足以分配这个对象或者没有抢到全局堆锁
- 这种情况下，会触发 GC 或者等待 GC 释放对象

### 为什么有个最大浪费空间？？
- 这是为了避免更有效的利用空间
- 假设当前剩余12KB，最大浪费空间是10KB，有个对象需要分配20KB，因为TLAB剩余空间不够，这时候面临两个选择
    - 丢弃掉当前这个TLAB，去申请一个新的
    - 不在当前这个TLAB上配置，去堆上分配
    - 最大浪费空间就是以上两种选择的决定者，假设剩余空间大于最大浪费空间，那么就保留当前这个TLAB，因为下次很可能在分配成功，所以要去堆上分配；假设剩余空间小于最大浪费空间，说明下次分配的可能性也不大了，可以丢弃掉当前TLAB去申请一个新的TLAB了

### TLAB
- TLAB 是动态的，一般分配频繁的线程TLAB=2M
- 每次fullGC都会触发所有线程填充自己的TLAB，然后退回堆，申请一个新的TLAB